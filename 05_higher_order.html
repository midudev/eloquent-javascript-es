<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Funciones de Orden Superior :: Eloquent JavaScript</title>
  <link rel="stylesheet" href="css/ejs.css"><script>
      var page = {"type":"chapter","number":5,"load_files":["code/scripts.js","code/chapter/05_higher_order.js","code/intro.js"]}</script></head>

<body><article>
<nav><a href="04_data.html" title="cap√≠tulo anterior" aria-label="cap√≠tulo anterior">‚óÇ</a>&nbsp;<a href="index.html" title="portada" aria-label="portada">‚óè</a>&nbsp;<a href="06_object.html" title="pr√≥ximo cap√≠tulo" aria-label="pr√≥ximo cap√≠tulo">‚ñ∏</a>&nbsp;<button class="help" title="ayuda" aria-label="ayuda"><strong>?</strong></button>
</nav>

<h1>Funciones de Orden Superior</h1>

<blockquote>

<p><a class="p_ident" id="p-MZD8y19lPz" href="#p-MZD8y19lPz" tabindex="-1" role="presentation"></a>Hay dos maneras de construir un dise√±o de software: Una es hacerlo tan simple que obviamente no tenga deficiencias, y la otra es hacerlo tan complicado que no haya deficiencias obvias.</p>

<footer>C.A.R. Hoare, <cite>Conferencia del Premio Turing de la ACM de 1980</cite></footer>

</blockquote><figure class="chapter true"><img src="images/chapter_picture_5.jpg" alt="Ilustraci√≥n mostrando letras y jerogl√≠ficos de diferentes escrituras: lat√≠n, griego, √°rabe, egipcia antigua, entre otras"></figure>

<p><a class="p_ident" id="p-1SpKr5NIrc" href="#p-1SpKr5NIrc" tabindex="-1" role="presentation"></a>Un programa grande es un programa costoso, y no solo por el tiempo que lleva construirlo. El tama√±o casi siempre implica complejidad, y la complejidad confunde a los programadores. Los programadores confundidos, a su vez, introducen errores (<em>bugs</em>) en los programas. Un programa grande entonces proporciona mucho espacio para que estos errores se escondan, haci√©ndolos dif√≠ciles de encontrar.</p>

<p><a class="p_ident" id="p-nR+iebr1Ci" href="#p-nR+iebr1Ci" tabindex="-1" role="presentation"></a>Volvamos brevemente a los dos programas de ejemplo finales en la introducci√≥n. El primero es aut√≥nomo y tiene seis l√≠neas.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-uIkg9pj99q" href="#c-uIkg9pj99q" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">total</span> = <span class="tok-number">0</span>, <span class="tok-definition">count</span> = <span class="tok-number">1</span>;
<span class="tok-keyword">while</span> (count &lt;= <span class="tok-number">10</span>) {
  total += count;
  count += <span class="tok-number">1</span>;
}
console.log(total);</pre>

<p><a class="p_ident" id="p-Sy8N6Qcb09" href="#p-Sy8N6Qcb09" tabindex="-1" role="presentation"></a>El segundo depende de dos funciones externas y tiene una l√≠nea de longitud.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-KTbQMmMCli" href="#c-KTbQMmMCli" tabindex="-1" role="presentation"></a>console.log(sum(range(<span class="tok-number">1</span>, <span class="tok-number">10</span>)));</pre><p><a class="p_ident" id="p-srOi7846QY" href="#p-srOi7846QY" tabindex="-1" role="presentation"></a>¬øCu√°l es m√°s probable que contenga un error?</p>

<p><a class="p_ident" id="p-G+ApGqjOk4" href="#p-G+ApGqjOk4" tabindex="-1" role="presentation"></a>Si contamos el tama√±o de las definiciones de <code>sum</code> y <code>range</code>, el segundo programa tambi√©n es grande, incluso m√°s grande que el primero. Pero a√∫n as√≠, yo argumentar√≠a que es m√°s probable que sea correcto.</p>

<p><a class="p_ident" id="p-+zWXfXVM//" href="#p-+zWXfXVM//" tabindex="-1" role="presentation"></a>Esto se debe a que la soluci√≥n se expresa en un vocabulario que corresponde al problema que se est√° resolviendo. Sumar un rango de n√∫meros no se trata de bucles y contadores. Se trata de rangos y sumas.</p>

<p><a class="p_ident" id="p-VwxmDNivhe" href="#p-VwxmDNivhe" tabindex="-1" role="presentation"></a>Las definiciones de este vocabulario (las funciones <code>sum</code> y <code>range</code>) seguir√°n involucrando bucles, contadores y otros detalles incidentales. Pero debido a que expresan conceptos m√°s simples que el programa en su totalidad, son m√°s f√°ciles de hacer correctos.</p>

<h2><a class="h_ident" id="h-j9ps8qrlyo" href="#h-j9ps8qrlyo" tabindex="-1" role="presentation"></a>Abstracci√≥n</h2>

<p><a class="p_ident" id="p-siavLDE8I0" href="#p-siavLDE8I0" tabindex="-1" role="presentation"></a>En el contexto de la programaci√≥n, estos tipos de vocabularios suelen ser llamados <em>abstracciones</em>. Las abstracciones nos proporcionan la capacidad de hablar sobre problemas en un nivel m√°s alto (o m√°s abstracto), sin distraernos con detalles poco interesantes.</p>

<p><a class="p_ident" id="p-bZjfawaGXi" href="#p-bZjfawaGXi" tabindex="-1" role="presentation"></a>Como analog√≠a, compara estas dos recetas para sopa de guisantes. La primera es as√≠:</p>

<blockquote>

<p><a class="p_ident" id="p-F+PunfZCXq" href="#p-F+PunfZCXq" tabindex="-1" role="presentation"></a>Pon 1 taza de guisantes secos por persona en un recipiente. A√±ade agua hasta que los guisantes est√©n bien cubiertos. Deja los guisantes en agua durante al menos 12 horas. Saca los guisantes del agua y ponlos en una olla. A√±ade 4 tazas de agua por persona. Cubre la olla y deja que los guisantes hiervan a fuego lento durante dos horas. Toma media cebolla por persona. C√≥rtala en trozos con un cuchillo. A√±√°dela a los guisantes. Toma un tallo de apio por persona. C√≥rtalo en trozos con un cuchillo. A√±√°delo a los guisantes. Toma una zanahoria por persona. C√≥rtala en trozos. ¬°Con un cuchillo! A√±√°dela a los guisantes. Cocina durante 10 minutos m√°s.</p>

</blockquote>

<p><a class="p_ident" id="p-K0c2hwcDfp" href="#p-K0c2hwcDfp" tabindex="-1" role="presentation"></a>Y esta es la segunda receta:</p>

<blockquote>

<p><a class="p_ident" id="p-iNBZReprTd" href="#p-iNBZReprTd" tabindex="-1" role="presentation"></a>Por persona: 1 taza de guisantes secos partidos, 4 tazas de agua, media cebolla picada, un tallo de apio, y una zanahoria.</p>

<p><a class="p_ident" id="p-k5rI5P5p5u" href="#p-k5rI5P5p5u" tabindex="-1" role="presentation"></a>Remoja los guisantes durante 12 horas. Hierve a fuego lento durante 2 horas. Pica y a√±ade las verduras. Cocina durante 10 minutos m√°s.</p></blockquote>

<p><a class="p_ident" id="p-cSeY164LbX" href="#p-cSeY164LbX" tabindex="-1" role="presentation"></a>El segundo es m√°s corto y m√°s f√°cil de interpretar. Pero necesitas entender algunas palabras m√°s relacionadas con la cocina como <em>soak</em>, <em>simmer</em>, <em>chop</em>, y, supongo, <em>vegetable</em>.</p>

<p><a class="p_ident" id="p-b7pOrv2VKr" href="#p-b7pOrv2VKr" tabindex="-1" role="presentation"></a>Cuando programamos, no podemos depender de que todas las palabras que necesitamos est√©n esper√°ndonos en el diccionario. As√≠, podr√≠amos caer en el patr√≥n de la primera receta‚Äîtrabajar en los pasos precisos que la computadora tiene que realizar, uno por uno, ciegos a los conceptos de nivel superior que expresan.</p>

<p><a class="p_ident" id="p-Hp26gkGVxA" href="#p-Hp26gkGVxA" tabindex="-1" role="presentation"></a>Es una habilidad √∫til, en programaci√≥n, notar cuando est√°s trabajando a un nivel de abstracci√≥n demasiado bajo.</p>

<h2><a class="h_ident" id="h-8AV6kA9jcD" href="#h-8AV6kA9jcD" tabindex="-1" role="presentation"></a>Abstrayendo la repetici√≥n</h2>

<p><a class="p_ident" id="p-kYV0l7wLUe" href="#p-kYV0l7wLUe" tabindex="-1" role="presentation"></a>Las funciones simples, como las hemos visto hasta ahora, son una buena manera de construir abstracciones. Pero a veces se quedan cortas.</p>

<p><a class="p_ident" id="p-1v9Uha9PnV" href="#p-1v9Uha9PnV" tabindex="-1" role="presentation"></a>Es com√∫n que un programa haga algo un n√∫mero dado de veces. Puedes escribir un bucle <code>for</code> para eso, as√≠:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-5c+C2+9IG1" href="#c-5c+C2+9IG1" tabindex="-1" role="presentation"></a><span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; i &lt; <span class="tok-number">10</span>; i++) {
  console.log(i);
}</pre>

<p><a class="p_ident" id="p-cNB+u+7TGa" href="#p-cNB+u+7TGa" tabindex="-1" role="presentation"></a>¬øPodemos abstraer "hacer algo <em>N</em> veces" como una funci√≥n? Bueno, es f√°cil escribir una funci√≥n que llama a <code>console.log</code> <em>N</em> veces:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-/gKhlra9P+" href="#c-/gKhlra9P+" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">repeatLog</span>(<span class="tok-definition">n</span>) {
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; i &lt; n; i++) {
    console.log(i);
  }
}</pre>

<p><a class="p_ident" id="p-q8hNTrfIYb" href="#p-q8hNTrfIYb" tabindex="-1" role="presentation"></a>Pero ¬øy si queremos hacer algo distinto a imprimir los n√∫meros? Dado que "hacer algo" se puede representar como una funci√≥n y las funciones son solo valores, podemos pasar nuestra acci√≥n como un valor de funci√≥n:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-p03rPqGmn9" href="#c-p03rPqGmn9" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">repeat</span>(<span class="tok-definition">n</span>, <span class="tok-definition">action</span>) {
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; i &lt; n; i++) {
    action(i);
  }
}repeat(<span class="tok-number">3</span>, console.log);
<span class="tok-comment">// ‚Üí 0</span>
<span class="tok-comment">// ‚Üí 1</span>
<span class="tok-comment">// ‚Üí 2</span></pre>

<p><a class="p_ident" id="p-zYjmzihkkN" href="#p-zYjmzihkkN" tabindex="-1" role="presentation"></a>No es necesario pasar una funci√≥n predefinida a <code>repeat</code>. A menudo, es m√°s f√°cil crear un valor de funci√≥n en el momento:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-EiK2Y8M/Mh" href="#c-EiK2Y8M/Mh" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">labels</span> = [];
repeat(<span class="tok-number">5</span>, <span class="tok-definition">i</span> =&gt; {
  labels.push(<span class="tok-string2">`Unit </span>${i + <span class="tok-number">1</span>}<span class="tok-string2">`</span>);
});
console.log(labels);
<span class="tok-comment">// ‚Üí ["Unit 1", "Unit 2", "Unit 3", "Unit 4", "Unit 5"]</span></pre>

<p><a class="p_ident" id="p-iuDYWrtCLy" href="#p-iuDYWrtCLy" tabindex="-1" role="presentation"></a>Esto est√° estructurado un poco como un ciclo <code>for</code>‚Äîprimero describe el tipo de ciclo y luego proporciona un cuerpo. Sin embargo, el cuerpo se escribe como un valor de funci√≥n, que est√° envuelto entre par√©ntesis en la llamada a <code>repeat</code>. Por eso debe cerrarse con el corchete de cierre <em>y</em> el par√©ntesis de cierre. En casos como este ejemplo donde el cuerpo es una sola expresi√≥n peque√±a, tambi√©n se podr√≠an omitir los corchetes y escribir el ciclo en una sola l√≠nea.</p>

<h2><a class="h_ident" id="h-xxCc98lOBK" href="#h-xxCc98lOBK" tabindex="-1" role="presentation"></a>Funciones de orden superior</h2>

<p><a class="p_ident" id="p-cao2fH68Tj" href="#p-cao2fH68Tj" tabindex="-1" role="presentation"></a>Las funciones que operan sobre otras funciones, ya sea tomando funciones como argumentos o devolvi√©ndolas, se llaman <em>funciones de orden superior</em>. Dado que ya hemos visto que las funciones son valores regulares, no hay nada particularmente notable sobre el hecho de que existan tales funciones. El t√©rmino viene de las matem√°ticas, donde se toma m√°s en serio la distinci√≥n entre funciones y otros valores.</p>

<p><a class="p_ident" id="p-+cgNTV2i2y" href="#p-+cgNTV2i2y" tabindex="-1" role="presentation"></a>Las funciones de orden superior nos permiten abstraer sobre <em>acciones</em>, no solo sobre valores. Vienen en varias formas. Por ejemplo, podemos tener funciones que crean nuevas funciones:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-kHXugeV8Vn" href="#c-kHXugeV8Vn" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">greaterThan</span>(<span class="tok-definition">n</span>) {
  <span class="tok-keyword">return</span> <span class="tok-definition">m</span> =&gt; m &gt; n;
}
<span class="tok-keyword">let</span> <span class="tok-definition">greaterThan10</span> = greaterThan(<span class="tok-number">10</span>);
console.log(greaterThan10(<span class="tok-number">11</span>));
<span class="tok-comment">// ‚Üí true</span></pre><p><a class="p_ident" id="p-BphGdvX3Sa" href="#p-BphGdvX3Sa" tabindex="-1" role="presentation"></a>Tambi√©n podemos tener funciones que cambian otras funciones:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-17dfYaooPK" href="#c-17dfYaooPK" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">ruidosa</span>(<span class="tok-definition">f</span>) {
  <span class="tok-keyword">return</span> (...<span class="tok-definition">args</span>) =&gt; {
    console.log(<span class="tok-string">"llamando con"</span>, args);
    <span class="tok-keyword">let</span> <span class="tok-definition">resultado</span> = f(...args);
    console.log(<span class="tok-string">"llamada con"</span>, args, <span class="tok-string">", devolvi√≥"</span>, resultado);
    <span class="tok-keyword">return</span> resultado;
  };
}
ruidosa(Math.min)(<span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>);
<span class="tok-comment">// ‚Üí llamando con [3, 2, 1]</span>
<span class="tok-comment">// ‚Üí llamada con [3, 2, 1] , devolvi√≥ 1</span></pre>

<p><a class="p_ident" id="p-lObEs7dS9+" href="#p-lObEs7dS9+" tabindex="-1" role="presentation"></a>Incluso podemos escribir funciones que proporcionen nuevos tipos de flujo de control:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-of6iH06dyE" href="#c-of6iH06dyE" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">aMenosQue</span>(<span class="tok-definition">prueba</span>, <span class="tok-definition">entonces</span>) {
  <span class="tok-keyword">if</span> (!prueba) entonces();
}

repetir(<span class="tok-number">3</span>, <span class="tok-definition">n</span> =&gt; {
  aMenosQue(n % <span class="tok-number">2</span> == <span class="tok-number">1</span>, () =&gt; {
    console.log(n, <span class="tok-string">"es par"</span>);
  });
});
<span class="tok-comment">// ‚Üí 0 es par</span>
<span class="tok-comment">// ‚Üí 2 es par</span></pre>

<p><a class="p_ident" id="p-/zKXdveDWD" href="#p-/zKXdveDWD" tabindex="-1" role="presentation"></a>Hay un m√©todo de array incorporado, <code>forEach</code>, que proporciona algo similar a un bucle <code>for</code>/<code>of</code> como una funci√≥n de orden superior:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-v9jL6NafRj" href="#c-v9jL6NafRj" tabindex="-1" role="presentation"></a>[<span class="tok-string">"A"</span>, <span class="tok-string">"B"</span>].forEach(<span class="tok-definition">l</span> =&gt; console.log(l));
<span class="tok-comment">// ‚Üí A</span>
<span class="tok-comment">// ‚Üí B</span></pre>

<h2 id="scripts"><a class="h_ident" id="h-/SVokn16u9" href="#h-/SVokn16u9" tabindex="-1" role="presentation"></a>Conjunto de datos de script</h2>

<p><a class="p_ident" id="p-t0gePcJ5To" href="#p-t0gePcJ5To" tabindex="-1" role="presentation"></a>Un √°rea donde las funciones de orden superior brillan es el procesamiento de datos. Para procesar datos, necesitaremos algunos datos de ejemplo reales. Este cap√≠tulo utilizar√° un conjunto de datos sobre scripts, sistemas de escritura como el lat√≠n, cir√≠lico o √°rabe.</p><p><a class="p_ident" id="p-Bwxmym8KXD" href="#p-Bwxmym8KXD" tabindex="-1" role="presentation"></a>Recuerda Unicode de <a href="01_values.html#unicode">Cap√≠tulo 1</a>, ¬øel sistema que asigna un n√∫mero a cada car√°cter en el lenguaje escrito? La mayor√≠a de estos caracteres est√°n asociados con un script espec√≠fico. El est√°ndar contiene 140 scripts diferentes, de los cuales 81 a√∫n se utilizan hoy en d√≠a y 59 son hist√≥ricos.</p>

<p><a class="p_ident" id="p-0ebPJMgh6D" href="#p-0ebPJMgh6D" tabindex="-1" role="presentation"></a>Aunque solo puedo leer con fluidez caracteres latinos, aprecio el hecho de que las personas est√©n escribiendo textos en al menos 80 otros sistemas de escritura, muchos de los cuales ni siquiera reconocer√≠a. Por ejemplo, aqu√≠ tienes una muestra de escritura tamil:</p><figure><img src="images/tamil.png" alt="Una l√≠nea de verso en escritura tamil. Los caracteres son relativamente simples y est√°n separados de manera ordenada, pero completamente diferentes del lat√≠n."></figure>

<p><a class="p_ident" id="p-RWVZnsc/dS" href="#p-RWVZnsc/dS" tabindex="-1" role="presentation"></a>El conjunto de datos de ejemplo contiene algunas piezas de informaci√≥n sobre los 140 scripts definidos en Unicode. Est√° disponible en el <a href="https://eloquentjavascript.net/code#5">sandbox de codificaci√≥n</a> de este cap√≠tulo como el enlace <code>SCRIPTS</code>. Este enlace contiene una matriz de objetos, cada uno de los cuales describe un script:</p>

<pre class="snippet" data-language="json"><a class="c_ident" id="c-YkfuyBG2fl" href="#c-YkfuyBG2fl" tabindex="-1" role="presentation"></a>{
  <span class="tok-definition">name</span>: <span class="tok-string">"Copto"</span>,
  <span class="tok-definition">ranges</span>: [[<span class="tok-number">994</span>, <span class="tok-number">1008</span>], [<span class="tok-number">11392</span>, <span class="tok-number">11508</span>], [<span class="tok-number">11513</span>, <span class="tok-number">11520</span>]],
  <span class="tok-definition">direction</span>: <span class="tok-string">"ltr"</span>,
  <span class="tok-definition">year</span>: -<span class="tok-number">200</span>,
  <span class="tok-definition">living</span>: false,
  <span class="tok-definition">link</span>: <span class="tok-string">"https://en.wikipedia.org/wiki/Alfabeto_copto"</span>
}</pre>

<p><a class="p_ident" id="p-rrPU5ybF5Y" href="#p-rrPU5ybF5Y" tabindex="-1" role="presentation"></a>Un objeto como este nos indica el nombre del script, los rangos Unicode asignados a √©l, la direcci√≥n en la que se escribe, el momento (aproximado) de origen, si a√∫n se usa, y un enlace para obtener m√°s informaci√≥n. La direcci√≥n puede ser <code>"ltr"</code> para izquierda a derecha, <code>"rtl"</code> para derecha a izquierda (como se escribe el texto √°rabe y hebreo), o <code>"ttb"</code> para arriba hacia abajo (como en la escritura mongola).</p>

<p><a class="p_ident" id="p-AvCZCbMsgs" href="#p-AvCZCbMsgs" tabindex="-1" role="presentation"></a>La propiedad <code>ranges</code> contiene una matriz de rangos de caracteres Unicode, cada uno de los cuales es un array de dos elementos que contienen un l√≠mite inferior y un l√≠mite superior. Cualquier c√≥digo de car√°cter dentro de estos rangos es asignado al script. El l√≠mite inferior es inclusivo (el c√≥digo 994 es un car√°cter copto) y el l√≠mite superior no es inclusivo (el c√≥digo 1008 no lo es).</p><h2><a class="h_ident" id="h-MM7RF32uzF" href="#h-MM7RF32uzF" tabindex="-1" role="presentation"></a>Filtrado de arreglos</h2>

<p><a class="p_ident" id="p-EQ8xGHltWu" href="#p-EQ8xGHltWu" tabindex="-1" role="presentation"></a>Si queremos encontrar los scripts en el conjunto de datos que a√∫n est√°n en uso, la siguiente funci√≥n podr√≠a ser √∫til. Filtra los elementos de un arreglo que no pasan una prueba.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-POEf7pMCk0" href="#c-POEf7pMCk0" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">filter</span>(<span class="tok-definition">array</span>, <span class="tok-definition">test</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">passed</span> = [];
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">element</span> <span class="tok-keyword">of</span> array) {
    <span class="tok-keyword">if</span> (test(element)) {
      passed.push(element);
    }
  }
  <span class="tok-keyword">return</span> passed;
}

console.log(filter(SCRIPTS, <span class="tok-definition">script</span> =&gt; script.living));
<span class="tok-comment">// ‚Üí [{name: "Adlam", ‚Ä¶}, ‚Ä¶]</span></pre>

<p><a class="p_ident" id="p-rUWludD494" href="#p-rUWludD494" tabindex="-1" role="presentation"></a>La funci√≥n utiliza el argumento llamado <code>test</code>, un valor de funci√≥n, para llenar un "hueco" en la computaci√≥n: el proceso de decidir qu√© elementos recolectar.</p>

<p><a class="p_ident" id="p-vcnUQxte/7" href="#p-vcnUQxte/7" tabindex="-1" role="presentation"></a>F√≠jate c√≥mo la funci√≥n <code>filter</code>, en lugar de eliminar elementos del arreglo existente, construye un nuevo arreglo con solo los elementos que pasan la prueba. Esta funci√≥n es <em>pura</em>. No modifica el arreglo que se le da.</p>

<p><a class="p_ident" id="p-nxWtg+vobY" href="#p-nxWtg+vobY" tabindex="-1" role="presentation"></a>Al igual que <code>forEach</code>, <code>filter</code> es un m√©todo est√°ndar de arreglos. El ejemplo defini√≥ la funci√≥n solo para mostrar qu√© hace internamente. A partir de ahora, lo usaremos de esta manera en su lugar:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-x8e0PmGGB1" href="#c-x8e0PmGGB1" tabindex="-1" role="presentation"></a>console.log(SCRIPTS.filter(<span class="tok-definition">s</span> =&gt; s.direction == <span class="tok-string">"ttb"</span>));
<span class="tok-bgc-comment">// ‚Üí [{name: "Mongolian", ‚Ä¶}, ‚Ä¶]</span></pre>

<h2 id="map"><a class="h_ident" id="h-lJEtQ+qjXz" href="#h-lJEtQ+qjXz" tabindex="-1" role="presentation"></a>Transformaci√≥n con map</h2>

<p><a class="p_ident" id="p-z7ZYMFMZh1" href="#p-z7ZYMFMZh1" tabindex="-1" role="presentation"></a>Imaginemos que tenemos un arreglo de objetos que representan scripts, producidos filtrando de alguna manera el arreglo <code>SCRIPTS</code>. Queremos un arreglo solo con los nombres, lo cual es m√°s f√°cil de inspeccionar.</p>

<p><a class="p_ident" id="p-6b1/g51xNK" href="#p-6b1/g51xNK" tabindex="-1" role="presentation"></a>El m√©todo <code>map</code> transforma un arreglo aplicando una funci√≥n a todos sus elementos y construyendo un nuevo arreglo a partir de los valores retornados. El nuevo arreglo tendr√° la misma longitud que el arreglo de entrada, pero su contenido habr√° sido <em>mapeado</em> a una nueva forma por la funci√≥n:</p><pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-03caQcQElo" href="#c-03caQcQElo" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">map</span>(<span class="tok-definition">array</span>, <span class="tok-definition">transform</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">mapeado</span> = [];
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">elemento</span> <span class="tok-keyword">of</span> array) {
    mapeado.push(transform(elemento));
  }
  <span class="tok-keyword">return</span> mapeado;
}

<span class="tok-keyword">let</span> <span class="tok-definition">scriptsDerecha</span> = SCRIPTS.filter(<span class="tok-definition">s</span> =&gt; s.direction == <span class="tok-string">"rtl"</span>);
console.log(map(scriptsDerecha, <span class="tok-definition">s</span> =&gt; s.name));
<span class="tok-comment">// ‚Üí ["Adlam", "Arabic", "Imperial Aramaic", ‚Ä¶]</span></pre>

<p><a class="p_ident" id="p-337o6zaWyY" href="#p-337o6zaWyY" tabindex="-1" role="presentation"></a>Like <code>forEach</code> and <code>filter</code>, <code>map</code> is a standard array method.</p>

<h2><a class="h_ident" id="h-fx3e34kT/k" href="#h-fx3e34kT/k" tabindex="-1" role="presentation"></a>Summarizing with reduce</h2>

<p><a class="p_ident" id="p-k7Wm2bpGwn" href="#p-k7Wm2bpGwn" tabindex="-1" role="presentation"></a>Another common thing to do with arrays is to compute a single value from them. Our recurring example, summing a collection of numbers, is an instance of this. Another example is finding the script with the most characters.</p>

<p><a class="p_ident" id="p-AQTWjyAzxS" href="#p-AQTWjyAzxS" tabindex="-1" role="presentation"></a>The higher-order operation that represents this pattern is called <em>reduce</em> (sometimes also called <em>fold</em>). It builds a value by repeatedly taking a single element from the array and combining it with the current value. When summing numbers, you‚Äôd start with the number zero and, for each element, add that to the sum.</p>

<p><a class="p_ident" id="p-f2gNWZyiAV" href="#p-f2gNWZyiAV" tabindex="-1" role="presentation"></a>The parameters to <code>reduce</code> are, apart from the array, a combining function and a start value. This function is a little less straightforward than <code>filter</code> and <code>map</code>, so take a close look at it:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-k5GDHjqpSc" href="#c-k5GDHjqpSc" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">reduce</span>(<span class="tok-definition">array</span>, <span class="tok-definition">combinar</span>, <span class="tok-definition">inicio</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">actual</span> = inicio;
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">elemento</span> <span class="tok-keyword">of</span> array) {
    actual = combinar(actual, elemento);
  }
  <span class="tok-keyword">return</span> actual;
}

console.log(reduce([<span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>], (<span class="tok-definition">a</span>, <span class="tok-definition">b</span>) =&gt; a + b, <span class="tok-number">0</span>));
<span class="tok-comment">// ‚Üí 10</span></pre>

<p><a class="p_ident" id="p-r9cFmJJTar" href="#p-r9cFmJJTar" tabindex="-1" role="presentation"></a>El m√©todo est√°ndar de arrays <code>reduce</code>, que por supuesto corresponde a esta funci√≥n, tiene una conveniencia a√±adida. Si tu array contiene al menos un elemento, se te permite omitir el argumento <code>start</code>. El m√©todo tomar√° el primer elemento del array como su valor de inicio y comenzar√° a reducir a partir del segundo elemento.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-Dxn7muuMkk" href="#c-Dxn7muuMkk" tabindex="-1" role="presentation"></a>console.log([<span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>].reduce((<span class="tok-definition">a</span>, <span class="tok-definition">b</span>) =&gt; a + b));
<span class="tok-comment">// ‚Üí 10</span></pre>

<p><a class="p_ident" id="p-co+X+c08nc" href="#p-co+X+c08nc" tabindex="-1" role="presentation"></a>Para usar <code>reduce</code> (dos veces) y encontrar el script con m√°s caracteres, podemos escribir algo como esto:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-x76Ukt5X+H" href="#c-x76Ukt5X+H" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">characterCount</span>(<span class="tok-definition">script</span>) {
  <span class="tok-keyword">return</span> script.ranges.reduce((<span class="tok-definition">count</span>, [<span class="tok-definition">from</span>, <span class="tok-definition">to</span>]) =&gt; {
    <span class="tok-keyword">return</span> count + (to - from);
  }, <span class="tok-number">0</span>);
}

console.log(SCRIPTS.reduce((<span class="tok-definition">a</span>, <span class="tok-definition">b</span>) =&gt; {
  <span class="tok-keyword">return</span> characterCount(a) &lt; characterCount(b) ? b : a;
}));
<span class="tok-comment">// ‚Üí {name: "Han", ‚Ä¶}</span></pre>

<p><a class="p_ident" id="p-Zk/GcSOyra" href="#p-Zk/GcSOyra" tabindex="-1" role="presentation"></a>La funci√≥n <code>characterCount</code> reduce los rangos asignados a un script sumando sus tama√±os. Observa el uso de la destructuraci√≥n en la lista de par√°metros de la funci√≥n reductora. La segunda llamada a <code>reduce</code> luego utiliza esto para encontrar el script m√°s grande al comparar repetidamente dos scripts y devolver el m√°s grande.</p>

<p><a class="p_ident" id="p-z8su8U5bcc" href="#p-z8su8U5bcc" tabindex="-1" role="presentation"></a>El script Han tiene m√°s de 89,000 caracteres asignados en el est√°ndar Unicode, lo que lo convierte en el sistema de escritura m√°s grande de lejos en el conjunto de datos. El Han es un script a veces utilizado para textos en chino, japon√©s y coreano. Estos idiomas comparten muchos caracteres, aunque tienden a escribirlos de manera diferente. El Consorcio Unicode (basado en EE. UU.) decidi√≥ tratarlos como un √∫nico sistema de escritura para ahorrar c√≥digos de caracteres. Esto se llama <em>Unificaci√≥n del Han</em> y todav√≠a hace que algunas personas se enojen mucho.</p><h2><a class="h_ident" id="h-+NeFt8aXxf" href="#h-+NeFt8aXxf" tabindex="-1" role="presentation"></a>Composabilidad</h2>

<p><a class="p_ident" id="p-UHvCjnmGjM" href="#p-UHvCjnmGjM" tabindex="-1" role="presentation"></a>Considera c√≥mo habr√≠amos escrito el ejemplo anterior (encontrar el script m√°s grande) sin funciones de orden superior. El c√≥digo no es mucho peor:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-1FmIKHNB24" href="#c-1FmIKHNB24" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">biggest</span> = <span class="tok-keyword">null</span>;
<span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">script</span> <span class="tok-keyword">of</span> SCRIPTS) {
  <span class="tok-keyword">if</span> (biggest == <span class="tok-keyword">null</span> ||
      characterCount(biggest) &lt; characterCount(script)) {
    biggest = script;
  }
}
console.log(biggest);
<span class="tok-comment">// ‚Üí {name: "Han", ‚Ä¶}</span></pre>

<p><a class="p_ident" id="p-rW1l2uIQYQ" href="#p-rW1l2uIQYQ" tabindex="-1" role="presentation"></a>Hay algunas m√°s asignaciones, y el programa tiene cuatro l√≠neas m√°s, pero sigue siendo muy legible.</p>

<p id="average_function"><a class="p_ident" id="p-3RRtt5qlOL" href="#p-3RRtt5qlOL" tabindex="-1" role="presentation"></a>Las abstracciones proporcionadas por estas funciones realmente brillan cuando necesitas <em>componer</em> operaciones. Como ejemplo, escribamos un c√≥digo que encuentre el a√±o promedio de origen de los scripts vivos y muertos en el conjunto de datos:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-rumPqbzokK" href="#c-rumPqbzokK" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">average</span>(<span class="tok-definition">array</span>) {
  <span class="tok-keyword">return</span> array.reduce((<span class="tok-definition">a</span>, <span class="tok-definition">b</span>) =&gt; a + b) / array.length;
}

console.log(Math.round(average(
  SCRIPTS.filter(<span class="tok-definition">s</span> =&gt; s.living).map(<span class="tok-definition">s</span> =&gt; s.year))));
<span class="tok-comment">// ‚Üí 1165</span>
console.log(Math.round(average(
  SCRIPTS.filter(<span class="tok-definition">s</span> =&gt; !s.living).map(<span class="tok-definition">s</span> =&gt; s.year))));
<span class="tok-comment">// ‚Üí 204</span></pre>

<p><a class="p_ident" id="p-nrGxJjJYLA" href="#p-nrGxJjJYLA" tabindex="-1" role="presentation"></a>Como puedes ver, los scripts muertos en Unicode son, en promedio, m√°s antiguos que los vivos. Esta no es una estad√≠stica terriblemente significativa o sorprendente. Pero espero que est√©s de acuerdo en que el c√≥digo utilizado para calcularlo no es dif√≠cil de leer. Puedes verlo como un pipeline: empezamos con todos los scripts, filtramos los vivos (o muertos), tomamos los a√±os de esos, los promediamos y redondeamos el resultado.</p>

<p><a class="p_ident" id="p-FNSiaZ2hBC" href="#p-FNSiaZ2hBC" tabindex="-1" role="presentation"></a>Tambi√©n podr√≠as escribir esta computaci√≥n como un solo gran bucle:</p><pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-noyYOD0Kiy" href="#c-noyYOD0Kiy" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">total</span> = <span class="tok-number">0</span>, <span class="tok-definition">count</span> = <span class="tok-number">0</span>;
<span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">script</span> <span class="tok-keyword">of</span> SCRIPTS) {
  <span class="tok-keyword">if</span> (script.living) {
    total += script.year;
    count += <span class="tok-number">1</span>;
  }
}
console.log(Math.round(total / count));
<span class="tok-comment">// ‚Üí 1165</span></pre>

<p><a class="p_ident" id="p-HFiahJwjXk" href="#p-HFiahJwjXk" tabindex="-1" role="presentation"></a>However, it is harder to see what was being computed and how. And because intermediate results aren‚Äôt represented as coherent values, it‚Äôd be a lot more work to extract something like <code>average</code> into a separate function.</p>

<p><a class="p_ident" id="p-CiGDWoU0I9" href="#p-CiGDWoU0I9" tabindex="-1" role="presentation"></a>In terms of what the computer is actually doing, these two approaches are also quite different. The first will build up new arrays when running <code>filter</code> and <code>map</code>, whereas the second computes only some numbers, doing less work. You can usually afford the readable approach, but if you‚Äôre processing huge arrays and doing so many times, the less abstract style might be worth the extra speed.</p>

<h2><a class="h_ident" id="h-gQf5HZNGpM" href="#h-gQf5HZNGpM" tabindex="-1" role="presentation"></a>Strings and character codes</h2>

<p><a class="p_ident" id="p-lX1fs4gEvw" href="#p-lX1fs4gEvw" tabindex="-1" role="presentation"></a>One interesting use of this data set would be figuring out what script a piece of text is using. Let‚Äôs go through a program that does this.</p>

<p><a class="p_ident" id="p-aEEZgRpp75" href="#p-aEEZgRpp75" tabindex="-1" role="presentation"></a>Remember that each script has an array of character code ranges associated with it. Given a character code, we could use a function like this to find the corresponding script (if any):</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-Q8918ecfHn" href="#c-Q8918ecfHn" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">characterScript</span>(<span class="tok-definition">code</span>) {
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">script</span> <span class="tok-keyword">of</span> SCRIPTS) {
    <span class="tok-keyword">if</span> (script.ranges.some(([<span class="tok-definition">from</span>, <span class="tok-definition">to</span>]) =&gt; {
      <span class="tok-keyword">return</span> code &gt;= from &amp;&amp; code &lt; to;
    })) {
      <span class="tok-keyword">return</span> script;
    }
  }
  <span class="tok-keyword">return</span> <span class="tok-keyword">null</span>;
}console.log(characterScript(<span class="tok-number">121</span>));
<span class="tok-comment">// ‚Üí {nombre: "Lat√≠n", ‚Ä¶}</span></pre>

<p><a class="p_ident" id="p-j3Y+wD1N4H" href="#p-j3Y+wD1N4H" tabindex="-1" role="presentation"></a>El m√©todo <code>some</code> es otra funci√≥n de orden superior. Toma una funci√≥n de prueba y te dice si esa funci√≥n devuelve verdadero para alguno de los elementos en el array.</p>

<p id="code_units"><a class="p_ident" id="p-NZ3lS1jnJX" href="#p-NZ3lS1jnJX" tabindex="-1" role="presentation"></a>Pero ¬øc√≥mo obtenemos los c√≥digos de caracteres en una cadena?</p>

<p><a class="p_ident" id="p-UsDhhqR3EH" href="#p-UsDhhqR3EH" tabindex="-1" role="presentation"></a>En <a href="01_values.html">Cap√≠tulo 1</a> mencion√© que las cadenas de JavaScript est√°n codificadas como una secuencia de n√∫meros de 16 bits. Estos se llaman <em>unidades de c√≥digo</em>. Se supon√≠a inicialmente que un c√≥digo de car√°cter Unicode cabr√≠a dentro de dicha unidad (lo que te da un poco m√°s de 65,000 caracteres). Cuando qued√≥ claro que eso no iba a ser suficiente, muchas personas se opusieron a la necesidad de usar m√°s memoria por car√°cter. Para abordar estas preocupaciones, se invent√≥ UTF-16, el formato tambi√©n utilizado por las cadenas de JavaScript. Describe los caracteres m√°s comunes con un solo c√≥digo de 16 bits pero usa un par de dos tales unidades para otros.</p>

<p><a class="p_ident" id="p-np3GxNBA5E" href="#p-np3GxNBA5E" tabindex="-1" role="presentation"></a>UTF-16 generalmente se considera una mala idea hoy en d√≠a. Parece casi dise√±ado intencionalmente para invitar a cometer errores. Es f√°cil escribir programas que pretendan que las unidades de c√≥digo y los caracteres son lo mismo. Y si tu lenguaje no usa caracteres de dos unidades, eso parecer√° funcionar muy bien. Pero tan pronto como alguien intente usar dicho programa con algunos caracteres chinos menos comunes, fallar√°. Afortunadamente, con la llegada de los emojis, todo el mundo ha comenzado a usar caracteres de dos unidades, y la carga de lidiar con estos problemas se distribuye de manera m√°s justa.</p>

<p><a class="p_ident" id="p-iQl/Gok4Mf" href="#p-iQl/Gok4Mf" tabindex="-1" role="presentation"></a>Desafortunadamente, las operaciones obvias en las cadenas de JavaScript, como obtener su longitud a trav√©s de la propiedad <code>length</code> y acceder a su contenido usando corchetes cuadrados, tratan solo con unidades de c√≥digo.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-50Oes+9anA" href="#c-50Oes+9anA" tabindex="-1" role="presentation"></a><span class="tok-comment">// Dos caracteres emoji, caballo y zapato</span>
<span class="tok-keyword">let</span> <span class="tok-definition">horseShoe</span> = <span class="tok-string">"üê¥üëü"</span>;
console.log(horseShoe.length);
<span class="tok-comment">// ‚Üí 4</span>
console.log(horseShoe[<span class="tok-number">0</span>]);
<span class="tok-comment">// ‚Üí (Car√°cter medio inv√°lido)</span>
console.log(horseShoe.charCodeAt(<span class="tok-number">0</span>));
<span class="tok-comment">// ‚Üí 55357 (C√≥digo del car√°cter medio)</span>
console.log(horseShoe.codePointAt(<span class="tok-number">0</span>));
<span class="tok-comment">// ‚Üí 128052 (C√≥digo real para el emoji de caballo)</span></pre><p><a class="p_ident" id="p-whNOOL2UUI" href="#p-whNOOL2UUI" tabindex="-1" role="presentation"></a>El m√©todo <code>charCodeAt</code> de JavaScript te da una unidad de c√≥digo, no un c√≥digo de car√°cter completo. El m√©todo <code>codePointAt</code>, a√±adido m√°s tarde, s√≠ da un car√°cter Unicode completo, por lo que podr√≠amos usarlo para obtener caracteres de una cadena. Pero el argumento pasado a <code>codePointAt</code> sigue siendo un √≠ndice en la secuencia de unidades de c√≥digo. Para recorrer todos los caracteres de una cadena, a√∫n necesitar√≠amos enfrentar la pregunta de si un car√°cter ocupa una o dos unidades de c√≥digo.</p>

<p><a class="p_ident" id="p-AEbxGojOu6" href="#p-AEbxGojOu6" tabindex="-1" role="presentation"></a>En el <a href="04_data.html#for_of_loop">cap√≠tulo anterior</a>, mencion√© que un bucle <code>for</code>/<code>of</code> tambi√©n se puede usar en cadenas. Al igual que <code>codePointAt</code>, este tipo de bucle fue introducido en un momento en el que las personas eran muy conscientes de los problemas con UTF-16. Cuando lo usas para recorrer una cadena, te da caracteres reales, no unidades de c√≥digo:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-9QIfA1qjtG" href="#c-9QIfA1qjtG" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">roseDragon</span> = <span class="tok-string">"üåπüêâ"</span>;
<span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">char</span> <span class="tok-keyword">of</span> roseDragon) {
  console.log(char);
}
<span class="tok-comment">// ‚Üí üåπ</span>
<span class="tok-comment">// ‚Üí üêâ</span></pre>

<p><a class="p_ident" id="p-1lRKu8d5oS" href="#p-1lRKu8d5oS" tabindex="-1" role="presentation"></a>Si tienes un car√°cter (que ser√° una cadena de una o dos unidades de c√≥digo), puedes usar <code>codePointAt(0)</code> para obtener su c√≥digo.</p>

<h2><a class="h_ident" id="h-qYzPQMwIvv" href="#h-qYzPQMwIvv" tabindex="-1" role="presentation"></a>Reconociendo texto</h2>

<p><a class="p_ident" id="p-rg3rI97v85" href="#p-rg3rI97v85" tabindex="-1" role="presentation"></a>Tenemos una funci√≥n <code>characterScript</code> y una forma de recorrer correctamente los caracteres. El siguiente paso es contar los caracteres que pertenecen a cada script. La siguiente abstracci√≥n de conteo ser√° √∫til all√≠:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-b8ZEeu/LH5" href="#c-b8ZEeu/LH5" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">countBy</span>(<span class="tok-definition">items</span>, <span class="tok-definition">groupName</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">counts</span> = [];
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">item</span> <span class="tok-keyword">of</span> items) {
    <span class="tok-keyword">let</span> <span class="tok-definition">name</span> = groupName(item);
    <span class="tok-keyword">let</span> <span class="tok-definition">known</span> = counts.find(<span class="tok-definition">c</span> =&gt; c.name == name);
    <span class="tok-keyword">if</span> (!known) {
      counts.push({<span class="tok-definition">name</span>, <span class="tok-definition">count</span>: <span class="tok-number">1</span>});
    } <span class="tok-keyword">else</span> {
      known.count++;
    }
  }
  <span class="tok-keyword">return</span> counts;
}console.log(countBy([<span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>], <span class="tok-definition">n</span> =&gt; n &gt; <span class="tok-number">2</span>));
<span class="tok-comment">// ‚Üí [{name: false, count: 2}, {name: true, count: 3}]</span></pre>

<p><a class="p_ident" id="p-XJKbcULdUw" href="#p-XJKbcULdUw" tabindex="-1" role="presentation"></a>La funci√≥n <code>countBy</code> espera una colecci√≥n (cualquier cosa sobre la que podamos iterar con <code>for</code>/<code>of</code>) y una funci√≥n que calcule un nombre de grupo para un elemento dado. Devuelve un array de objetos, cada uno de los cuales nombra un grupo y te indica la cantidad de elementos que se encontraron en ese grupo.</p>

<p><a class="p_ident" id="p-YjH+mbwxM+" href="#p-YjH+mbwxM+" tabindex="-1" role="presentation"></a>Utiliza otro m√©todo de array, <code>find</code>, que recorre los elementos del array y devuelve el primero para el cual una funci√≥n devuelve true. Devuelve <code>undefined</code> cuando no se encuentra tal elemento.</p>

<p><a class="p_ident" id="p-T2D/Ix5YaM" href="#p-T2D/Ix5YaM" tabindex="-1" role="presentation"></a>Usando <code>countBy</code>, podemos escribir la funci√≥n que nos dice qu√© scripts se usan en un fragmento de texto:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-TyAeKAD0HB" href="#c-TyAeKAD0HB" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">textScripts</span>(<span class="tok-definition">texto</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">scripts</span> = countBy(texto, <span class="tok-definition">caracter</span> =&gt; {
    <span class="tok-keyword">let</span> <span class="tok-definition">script</span> = characterScript(caracter.codePointAt(<span class="tok-number">0</span>));
    <span class="tok-keyword">return</span> script ? script.name : <span class="tok-string">"ninguno"</span>;
  }).filter(({name}) =&gt; name != <span class="tok-string">"ninguno"</span>);

  <span class="tok-keyword">let</span> <span class="tok-definition">total</span> = scripts.reduce((<span class="tok-definition">n</span>, {count}) =&gt; n + count, <span class="tok-number">0</span>);
  <span class="tok-keyword">if</span> (total == <span class="tok-number">0</span>) <span class="tok-keyword">return</span> <span class="tok-string">"No se encontraron scripts"</span>;

  <span class="tok-keyword">return</span> scripts.map(({name, count}) =&gt; {
    <span class="tok-keyword">return</span> <span class="tok-string2">`</span>${Math.round(count * <span class="tok-number">100</span> / total)}<span class="tok-string2>% </span>${name}<span class="tok-string2">`</span>;
  }).join(<span class="tok-string">", "</span>);
}

console.log(textScripts(<span class="tok-string">'Ëã±ÂõΩÁöÑÁãóËØ¥"woof", ‰øÑÁΩóÊñØÁöÑÁãóËØ¥"—Ç—è–≤"'</span>));
<span class="tok-comment">// ‚Üí 61% Han, 22% Latin, 17% Cyrillic</span></pre><p><a class="p_ident" id="p-ydjmkrkJ8Y" href="#p-ydjmkrkJ8Y" tabindex="-1" role="presentation"></a>La funci√≥n cuenta primero los caracteres por nombre, usando <code>characterScript</code> para asignarles un nombre y retrocediendo a la cadena <code>"none"</code> para los caracteres que no forman parte de ning√∫n script. La llamada a <code>filter</code> elimina la entrada de <code>"none"</code> del array resultante, ya que no nos interesan esos caracteres.</p>

<p><a class="p_ident" id="p-avwH1AKErw" href="#p-avwH1AKErw" tabindex="-1" role="presentation"></a>Para poder calcular porcentajes, primero necesitamos el n√∫mero total de caracteres que pertenecen a un script, lo cual podemos calcular con <code>reduce</code>. Si no se encuentran caracteres de este tipo, la funci√≥n devuelve una cadena espec√≠fica. De lo contrario, transforma las entradas de conteo en cadenas legibles con <code>map</code> y luego las combina con <code>join</code>.</p>

<h2><a class="h_ident" id="h-ErccPg/l98" href="#h-ErccPg/l98" tabindex="-1" role="presentation"></a>Resumen</h2>

<p><a class="p_ident" id="p-N6wo+JYLCW" href="#p-N6wo+JYLCW" tabindex="-1" role="presentation"></a>La capacidad de pasar valores de funciones a otras funciones es un aspecto muy √∫til de JavaScript. Nos permite escribir funciones que modelan c√°lculos con "brechas" en ellos. El c√≥digo que llama a estas funciones puede rellenar las brechas proporcionando valores de funci√≥n.</p>

<p><a class="p_ident" id="p-RSm+n5dlJf" href="#p-RSm+n5dlJf" tabindex="-1" role="presentation"></a>Los arrays proporcionan varios m√©todos de orden superior √∫tiles. Puedes usar <code>forEach</code> para recorrer los elementos de un array. El m√©todo <code>filter</code> devuelve un nuevo array que contiene solo los elementos que pasan la funci√≥n de predicado. Transformar un array poniendo cada elemento a trav√©s de una funci√≥n se hace con <code>map</code>. Puedes usar <code>reduce</code> para combinar todos los elementos en un array en un √∫nico valor. El m√©todo <code>some</code> prueba si alg√∫n elemento coincide con una funci√≥n de predicado dada, mientras que <code>find</code> encuentra el primer elemento que coincide con un predicado.</p>

<h2><a class="h_ident" id="h-TcUD2vzyMe" href="#h-TcUD2vzyMe" tabindex="-1" role="presentation"></a>Ejercicios</h2>

<h3><a class="i_ident" id="i-aIOczlLyX1" href="#i-aIOczlLyX1" tabindex="-1" role="presentation"></a>Aplanamiento</h3>

<p><a class="p_ident" id="p-6CVUmjaoYw" href="#p-6CVUmjaoYw" tabindex="-1" role="presentation"></a>Usa el m√©todo <code>reduce</code> en combinaci√≥n con el m√©todo <code>concat</code> para "aplanar" un array de arrays en un √∫nico array que contenga todos los elementos de los arrays originales.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-I+o+qLGLXB" href="#c-I+o+qLGLXB" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">arrays</span> = [[<span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>], [<span class="tok-number">4</span>, <span class="tok-number">5</span>], [<span class="tok-number">6</span>]];
<span class="tok-comment">// Tu c√≥digo aqu√≠.</span>
<span class="tok-comment">// ‚Üí [1, 2, 3, 4, 5, 6]</span></pre><h3><a class="i_ident" id="i-gKQ1S54F4o" href="#i-gKQ1S54F4o" tabindex="-1" role="presentation"></a>Tu propio bucle</h3>

<p><a class="p_ident" id="p-LWMRzXlJIe" href="#p-LWMRzXlJIe" tabindex="-1" role="presentation"></a>Escribe una funci√≥n de orden superior <code>loop</code> que proporcione algo similar a una declaraci√≥n de bucle <code>for</code>. Deber√≠a tomar un valor, una funci√≥n de prueba, una funci√≥n de actualizaci√≥n y una funci√≥n de cuerpo. En cada iteraci√≥n, primero deber√≠a ejecutar la funci√≥n de prueba en el valor actual del bucle y detenerse si eso devuelve falso. Luego deber√≠a llamar a la funci√≥n de cuerpo, d√°ndole el valor actual, y finalmente llamar a la funci√≥n de actualizaci√≥n para crear un nuevo valor y comenzar de nuevo desde el principio.</p>

<p><a class="p_ident" id="p-56Gym1d0eB" href="#p-56Gym1d0eB" tabindex="-1" role="presentation"></a>Cuando definas la funci√≥n, puedes usar un bucle normal para hacer el bucle real.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-Fv1rc97GEM" href="#c-Fv1rc97GEM" tabindex="-1" role="presentation"></a><span class="tok-comment">// Tu c√≥digo aqu√≠.</span>

loop(<span class="tok-number">3</span>, <span class="tok-definition">n</span> =&gt; n &gt; <span class="tok-number">0</span>, <span class="tok-definition">n</span> =&gt; n - <span class="tok-number">1</span>, console.log);
<span class="tok-comment">// ‚Üí 3</span>
<span class="tok-comment">// ‚Üí 2</span>
<span class="tok-comment">// ‚Üí 1</span></pre>

<h3><a class="i_ident" id="i-SmbRSAd5GA" href="#i-SmbRSAd5GA" tabindex="-1" role="presentation"></a>Todo</h3>

<p><a class="p_ident" id="p-mCva3ZA9gp" href="#p-mCva3ZA9gp" tabindex="-1" role="presentation"></a>Los arrays tambi√©n tienen un m√©todo <code>every</code> an√°logo al m√©todo <code>some</code>. Este m√©todo devuelve verdadero cuando la funci√≥n dada devuelve verdadero para <em>cada</em> elemento en el array. De cierta manera, <code>some</code> es una versi√≥n del operador <code>||</code> que act√∫a en arrays, y <code>every</code> es como el operador <code>&amp;&amp;</code>.</p>

<p><a class="p_ident" id="p-m8iHZxZZwf" href="#p-m8iHZxZZwf" tabindex="-1" role="presentation"></a>Implementa <code>every</code> como una funci√≥n que tome un array y una funci√≥n predicado como par√°metros. Escribe dos versiones, una usando un bucle y otra usando el m√©todo <code>some</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-NludaTWDls" href="#c-NludaTWDls" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">every</span>(<span class="tok-definition">array</span>, <span class="tok-definition">test</span>) {
  <span class="tok-comment">// Tu c√≥digo aqu√≠.</span>
}

console.log(every([<span class="tok-number">1</span>, <span class="tok-number">3</span>, <span class="tok-number">5</span>], <span class="tok-definition">n</span> =&gt; n &lt; <span class="tok-number">10</span>));
<span class="tok-comment">// ‚Üí true</span>
console.log(every([<span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">16</span>], <span class="tok-definition">n</span> =&gt; n &lt; <span class="tok-number">10</span>));
<span class="tok-comment">// ‚Üí false</span>
console.log(every([], <span class="tok-definition">n</span> =&gt; n &lt; <span class="tok-number">10</span>));
<span class="tok-comment">// ‚Üí true</span></pre><details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-6hANimSBBy" href="#p-6hANimSBBy" tabindex="-1" role="presentation"></a>Al igual que el operador <code>&amp;&amp;</code>, el m√©todo <code>every</code> puede dejar de evaluar m√°s elementos en cuanto encuentra uno que no coincide. Por lo tanto, la versi√≥n basada en bucles puede salir del bucle‚Äîcon <code>break</code> o <code>return</code>‚Äîtan pronto como se encuentra con un elemento para el cual la funci√≥n de predicado devuelve falso. Si el bucle llega a su fin sin encontrar tal elemento, sabemos que todos los elementos coincidieron y deber√≠amos devolver true.</p>

<p><a class="p_ident" id="p-Ox5LquJ8IQ" href="#p-Ox5LquJ8IQ" tabindex="-1" role="presentation"></a>Para construir <code>every</code> sobre <code>some</code>, podemos aplicar las <em>leyes de De Morgan</em>, que establecen que <code>a &amp;&amp; b</code> es igual a <code>!(!a || !b)</code>. Esto puede generalizarse a arrays, donde todos los elementos en el array coinciden si no hay ning√∫n elemento en el array que no coincida.</p>

</div></details>

<h3><a class="i_ident" id="i-4ccl4J1nOw" href="#i-4ccl4J1nOw" tabindex="-1" role="presentation"></a>Direcci√≥n de escritura dominante</h3>

<p><a class="p_ident" id="p-9kMfnY4I1g" href="#p-9kMfnY4I1g" tabindex="-1" role="presentation"></a>Escribe una funci√≥n que calcule la direcci√≥n de escritura dominante en una cadena de texto. Recuerda que cada objeto de script tiene una propiedad <code>direction</code> que puede ser <code>"ltr"</code> (izquierda a derecha), <code>"rtl"</code> (derecha a izquierda) o <code>"ttb"</code> (de arriba a abajo).</p>

<p><a class="p_ident" id="p-WGH1oH+EyU" href="#p-WGH1oH+EyU" tabindex="-1" role="presentation"></a>La direcci√≥n dominante es la direcci√≥n de la mayor√≠a de los caracteres que tienen un script asociado. Las funciones <code>characterScript</code> y <code>countBy</code> definidas anteriormente en el cap√≠tulo probablemente sean √∫tiles aqu√≠.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-CNawUvyti3" href="#c-CNawUvyti3" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">dominantDirection</span>(<span class="tok-definition">texto</span>) {
  <span class="tok-comment">// Tu c√≥digo aqu√≠.</span>
}

console.log(dominantDirection(<span class="tok-string">"¬°Hola!"</span>));
<span class="tok-comment">// ‚Üí ltr</span>
console.log(dominantDirection(<span class="tok-string">"Hey, ŸÖÿ≥ÿßÿ° ÿßŸÑÿÆŸäÿ±"</span>));
<span class="tok-comment">// ‚Üí rtl</span></pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-Z2nEY1sOaH" href="#p-Z2nEY1sOaH" tabindex="-1" role="presentation"></a>Tu soluci√≥n puede parecerse mucho a la primera mitad del ejemplo <code>textScripts</code>. Una vez m√°s, debes contar caracteres seg√∫n un criterio basado en <code>characterScript</code> y luego filtrar la parte del resultado que se refiere a caracteres sin inter√©s (sin script).</p><p><a class="p_ident" id="p-1yNhVH0QH9" href="#p-1yNhVH0QH9" tabindex="-1" role="presentation"></a>Encontrar la direcci√≥n con el conteo de caracteres m√°s alto se puede hacer con <code>reduce</code>. Si no est√° claro c√≥mo hacerlo, consulta el ejemplo anterior en el cap√≠tulo, donde se utiliz√≥ <code>reduce</code> para encontrar el script con m√°s caracteres.</p>

</div></details><nav><a href="04_data.html" title="cap√≠tulo anterior" aria-label="cap√≠tulo anterior">‚óÇ</a>&nbsp;<a href="index.html" title="portada" aria-label="portada">‚óè</a>&nbsp;<a href="06_object.html" title="pr√≥ximo cap√≠tulo" aria-label="pr√≥ximo cap√≠tulo">‚ñ∏</a>&nbsp;<button class="help" title="ayuda" aria-label="ayuda"><strong>?</strong></button>
</nav>
</article>

<script src="js/ejs.js"></script>
</body></html>