<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Valores, Tipos y Operadores :: Eloquent JavaScript</title>
  <link rel=stylesheet href="css/ejs.css"><script>
      var page = {"type":"chapter","number":1}</script></head>

<article>
<nav><a href="00_intro.html" title="previous chapter" aria-label="previous chapter">◂</a> <a href="index.html" title="cover" aria-label="cover">●</a> <a href="02_program_structure.html" title="next chapter" aria-label="next chapter">▸</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>
</nav>

<h1>Valores, Tipos y Operadores</h1>

<blockquote>

<p><a class="p_ident" id="p-ILDglix78z" href="#p-ILDglix78z" tabindex="-1" role="presentation"></a>Bajo de la superficie de la máquina, el programa se mueve. Sin esfuerzo, se expande y contrae. En gran armonía, los electrones se dispersan y reagrupan. Las formas en el monitor no son sino ondas en el agua. La esencia permanece invisible debajo.</p>

<footer>Master Yuan-Ma, <cite>The Book of Programming</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_1.jpg" alt="Una foto de un mar de bits"></figure>

<p><a class="p_ident" id="p-8y5+SFCMLf" href="#p-8y5+SFCMLf" tabindex="-1" role="presentation"></a>En el mundo de la computadora, solo existe la información. Puedes leer datos, modificar datos, crear nuevos datos, pero no se puede hablar de nada que no sean datos. Todos estos datos se almacenan como largas secuencias de bits, y, por tanto, en el fondo, son todos iguales.</p>

<p><a class="p_ident" id="p-9HVAw+hhzG" href="#p-9HVAw+hhzG" tabindex="-1" role="presentation"></a>Llamamos <em>bits</em> a cualquier tipo de cosa con dos posibles valores, y generalmente los describimos usando ceros y unos. Dentro de la computadora, aparecen en forma de una carga eléctrica alta o baja, una señal fuerte o débil, o un punto brillante u opaco en la superficie de un CD. Cualquier pieza de información discreta puede reducirse a una secuencia de ceros y unos y por lo tanto representarse en bits.</p>

<p><a class="p_ident" id="p-e7UmOUc3PL" href="#p-e7UmOUc3PL" tabindex="-1" role="presentation"></a>Por ejemplo, podemos expresar el número 13 en bits de la misma manera que lo hacemos como número decimal, pero en lugar de utilizando diez dígitos diferentes, usando solo 2, aumentando el peso de cada dígito de la representación por un factor de 2 de derecha a izquierda. Aquí están los bits que componen el número 13, con los pesos de los dígitos mostrados debajo de ellos:</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-+fMMNc3yUt" href="#c-+fMMNc3yUt" tabindex="-1" role="presentation"></a>   0   0   0   0   1   1   0   1
 128  64  32  16   8   4   2   1</pre>

<p><a class="p_ident" id="p-jb21kV7NPC" href="#p-jb21kV7NPC" tabindex="-1" role="presentation"></a>Ese es el número binario 00001101. Sus dígitos no nulos representan 8, 4 y 1, y suman 13.</p>

<h2><a class="h_ident" id="h-U9F8ZU147i" href="#h-U9F8ZU147i" tabindex="-1" role="presentation"></a>Valores</h2>

<p><a class="p_ident" id="p-ueMEhoC62i" href="#p-ueMEhoC62i" tabindex="-1" role="presentation"></a>Imagina una mar de bits—un océano de ellos. Una computadora corriente de hoy en día tiene más de 100 mil millones de bits en su almacenamiento de datos volátil (memoria de trabajo o memoria RAM). El almacenamiento no volátil (el disco duro o cualquier equivalente) tiende a tener aún unos cuantos órdenes de magnitud más.</p>

<p><a class="p_ident" id="p-UZXNHNgZfk" href="#p-UZXNHNgZfk" tabindex="-1" role="presentation"></a>Para poder trabajar con tales cantidades de bits sin perdernos, los separamos en trozos que representan piezas de información. En un entorno de JavaScript, esos trozos se llaman <em>valores</em>. Aunque todos los valores están hechos de bits, desempeñan roles diferentes. Cada valor tiene un tipo que determina su función. Algunos valores son números, otros son fragmentos de texto, otros son funciones, etc.</p>

<p><a class="p_ident" id="p-Iamt82VWK9" href="#p-Iamt82VWK9" tabindex="-1" role="presentation"></a>Para crear un valor, basta con invocar su nombre. Esto es conveniente. No tienes que recolectar material de construcción para tus valores ni pagar por ellos. Solo solicitas uno, y ¡pum!, ahí está. Por supuesto, los valores no se crean realmente de la nada. Cada uno tiene que almacenarse en algún lugar, y, si deseas usar gigantescas cantidades de ellos al mismo tiempo, podrías quedarte sin memoria en la computadora. Por suerte, esto es un problema solo si los necesitas todos a la vez. Tan pronto como dejes de usar un valor, se disipará, dejando atrás sus bits para ser reciclados como material de construcción para la próxima generación de valores.</p>

<p><a class="p_ident" id="p-1IM4xyT/lZ" href="#p-1IM4xyT/lZ" tabindex="-1" role="presentation"></a>El resto de este capítulo presenta los elementos atómicos de los programas de JavaScript, es decir, los tipos de valores simples y los operadores que pueden actuar sobre dichos valores.</p>

<h2><a class="h_ident" id="h-2eDSr4FTTr" href="#h-2eDSr4FTTr" tabindex="-1" role="presentation"></a>Números</h2>

<p><a class="p_ident" id="p-bOZDjE7yem" href="#p-bOZDjE7yem" tabindex="-1" role="presentation"></a>Los valores del tipo <em>number</em> son, como era de esperar, valores numéricos. En un programa de JavaScript, se escriben de la siguiente manera:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-/u5ErTZbax" href="#c-/u5ErTZbax" tabindex="-1" role="presentation"></a><span class="tok-number">13</span></pre>

<p><a class="p_ident" id="p-2b0WdUMWiY" href="#p-2b0WdUMWiY" tabindex="-1" role="presentation"></a>Usar esto en un programa hará que el patrón de bits para el número 13 exista en la memoria del ordenador.</p>

<p><a class="p_ident" id="p-HXtKQ7s/e2" href="#p-HXtKQ7s/e2" tabindex="-1" role="presentation"></a>JavaScript utiliza una cantidad fija de bits, 64 de ellos, para almacenar cada valor numérico. Hay una cantidad limitada de patrones que puedes formar con 64 bits, lo que limita la cantidad de números diferentes que se pueden representar. Con <em>N</em> dígitos decimales, puedes representar 10<sup>N</sup> números distintos. De manera similar, utilizando 64 dígitos binarios, puedes representar 2<sup>64</sup> números diferentes, que son alrededor de 18 mil trillones (un 18 seguido de 18 ceros). Eso es un montón.</p>

<p><a class="p_ident" id="p-rvmt60g/XE" href="#p-rvmt60g/XE" tabindex="-1" role="presentation"></a>La memoria de la computadora solía ser mucho más pequeña, y la gente solía utilizar grupos de 8 o 16 bits para representar sus números. Era fácil acabar por error con un <em>desbordamiento</em> (comúnmente conocido como <em>overflow</em>) con un conjunto posible de números tan pequeño —es decir, terminar con un número que no puede ser representado con la cantidad dada de bits. Hoy en día, incluso un dispositivo que cabe en tu bolsillo tiene mucha memoria, por lo que puedes utilizar trozos de 64 bits para representar números, y solo necesitas preocuparte por el desbordamiento cuando pretendes representar cantidades realmente astronómicas.</p>

<p><a class="p_ident" id="p-3B3trY1G3F" href="#p-3B3trY1G3F" tabindex="-1" role="presentation"></a>En cualquier caso, no todos los números naturales menores que 18 mil trillones caben en un número de JavaScript. Esos bits también almacenan números negativos, por lo que un bit se usa para indicar el signo del número. Y aún más complicado es representar números no enteros. Para hacer esto, algunos de los bits se utilizan para almacenar la posición del punto decimal. El número entero más grande que en realidad se puede almacenar está más en el rango de los 9 mil billones (15 ceros), que sigue siendo increíblemente grande.</p>

<p><a class="p_ident" id="p-A5C6OiK5VV" href="#p-A5C6OiK5VV" tabindex="-1" role="presentation"></a>Para representar números con parte decimal se utiliza un punto:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-tM8nqv41Gp" href="#c-tM8nqv41Gp" tabindex="-1" role="presentation"></a><span class="tok-number">9.81</span></pre>

<p><a class="p_ident" id="p-swGkw2BgKN" href="#p-swGkw2BgKN" tabindex="-1" role="presentation"></a>Para números muy grandes o muy pequeños, también se puede usar notación científica agregando una <em>e</em> (de <em>exponente</em>), seguida del exponente del número:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-6ew5w+VhSM" href="#c-6ew5w+VhSM" tabindex="-1" role="presentation"></a><span class="tok-number">2.998e8</span></pre>

<p><a class="p_ident" id="p-jwQzz0n15f" href="#p-jwQzz0n15f" tabindex="-1" role="presentation"></a>Esto representaría al número 2.998 × 10<sup>8</sup> = 299,800,000.</p>

<p><a class="p_ident" id="p-HfKizr1nUC" href="#p-HfKizr1nUC" tabindex="-1" role="presentation"></a>La precisión de cualquier cálculo con números <em>enteros</em> con valor absoluto menor a los 9 mil billones antes mencionados está siempre garantizada. Por desgracia, la de los cálculos con números no enteros generalmente no está. Así como π (pi) no puede expresarse con total precisión mediante un número finito de dígitos decimales, muchos números pierden algo de precisión en su representación cuando solo tenemos 64 bits para almacenarlos. Es una lástima, pero solo provoca problemas prácticos en situaciones específicas. Lo importante tenerlo en cuenta y tratar los números digitales con parte decimal como aproximaciones, no como valores precisos.</p>

<h3><a class="i_ident" id="i-aIf95z3S0d" href="#i-aIf95z3S0d" tabindex="-1" role="presentation"></a>Aritmética</h3>

<p><a class="p_ident" id="p-DGirvf5riQ" href="#p-DGirvf5riQ" tabindex="-1" role="presentation"></a>Con números, lo principal que uno puede hacer es aritmética. Operaciones aritméticas como la suma o la multiplicación toman dos valores numéricos y producen un nuevo número a partir de ellos. Esta es la pinta que tienen en JavaScript:</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-meta="expr"><a class="c_ident" id="c-bSU4Vtv/mt" href="#c-bSU4Vtv/mt" tabindex="-1" role="presentation"></a><span class="tok-number">100</span> + <span class="tok-number">4</span> * <span class="tok-number">11</span></pre>

<p><a class="p_ident" id="p-PNPKgKWrHK" href="#p-PNPKgKWrHK" tabindex="-1" role="presentation"></a>Los símbolos <code>+</code> y <code>*</code> se llaman <em>operadores</em>. El primero representa la suma y el segundo representa la multiplicación. Colocar un operador entre dos valores aplicará ese operador a esos valores y producirá un nuevo valor.</p>

<p><a class="p_ident" id="p-rbQOL3GnYq" href="#p-rbQOL3GnYq" tabindex="-1" role="presentation"></a>¿Significa este ejemplo “sumar 4 y 100, y luego multiplicar el resultado por 11”, o se realiza primero la multiplicación antes de la suma? Como habrás adivinado, la multiplicación se realiza primero. Pero igual que en matemáticas, esto se puede cambiar escribiendo la suma entre paréntesis:</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-meta="expr"><a class="c_ident" id="c-ij6V90ZZBQ" href="#c-ij6V90ZZBQ" tabindex="-1" role="presentation"></a>(<span class="tok-number">100</span> + <span class="tok-number">4</span>) * <span class="tok-number">11</span></pre>

<p><a class="p_ident" id="p-e9lhSXZbdW" href="#p-e9lhSXZbdW" tabindex="-1" role="presentation"></a>Para la resta, está el operador <code>-</code>. La división se puede hacer con el operador <code>/</code>.</p>

<p><a class="p_ident" id="p-OJONCWoI1T" href="#p-OJONCWoI1T" tabindex="-1" role="presentation"></a>Cuando los operadores aparecen juntos sin paréntesis, el orden en que se aplican se determina por la <em>precedencia</em> de los operadores. El ejemplo muestra que la multiplicación se realiza antes que la suma. El operador <code>/</code> tiene la misma precedencia que <code>*</code>. Igualmente, <code>+</code> y <code>-</code> tienen la misma precedencia. Cuando varios operadores con la misma precedencia aparecen uno al lado del otro, como en <code>1 - 2 + 1</code>, se aplican de izquierda a derecha: <code>(1 - 2) + 1</code>.</p>

<p><a class="p_ident" id="p-icq/wIw6Tp" href="#p-icq/wIw6Tp" tabindex="-1" role="presentation"></a>No te preocupes demasiado por estas reglas de precedencia. Cuando tengas dudas, simplemente agrega paréntesis.</p>

<p><a class="p_ident" id="p-6mDQ8afNaM" href="#p-6mDQ8afNaM" tabindex="-1" role="presentation"></a>Hay un operador aritmético más que quizás no te suene tanto. El símbolo <code>%</code> se utiliza para representar la operación de <em>resto</em>. <code>X % Y</code> es el resto de la división entera de <code>X</code> entre <code>Y</code>. Por ejemplo, <code>314 % 100</code> produce <code>14</code>, y <code>144 % 12</code> da <code>0</code>. La precedencia del operador de resto es la misma que la de multiplicación y división. También verás a menudo a este operador referido como <em>módulo</em>.</p>

<h3><a class="i_ident" id="i-zFIgofBZed" href="#i-zFIgofBZed" tabindex="-1" role="presentation"></a>Números especiales</h3>

<p><a class="p_ident" id="p-Yzdmqjc9np" href="#p-Yzdmqjc9np" tabindex="-1" role="presentation"></a>Hay tres valores especiales en JavaScript que se consideran números pero no se comportan como números normales. Los dos primeros son <code>Infinity</code> y <code>-Infinity</code>, que representan el infinito positivo y negativo. <code>Infinity - 1</code> sigue siendo <code>Infinity</code>, etc. De todos modos, no te fíes demasiado de las cuentas que involucren al infinito. No suele tener sentido matemáticamente y rápidamente te llevará a encontrarte con el siguiente número especial: <code>NaN</code>.</p>

<p><a class="p_ident" id="p-O0KRWbmkvj" href="#p-O0KRWbmkvj" tabindex="-1" role="presentation"></a><code>NaN</code> significa “no es un número” (en inglés, <em>not a number</em>), aunque <em>es</em> un valor del tipo <em>number</em>. Obtendrás este resultado cuando, por ejemplo, intentes calcular <code>0 / 0</code> (cero dividido por cero), <code>Infinity - Infinity</code>, o cualquier otra cuanta que no tenga un sentido determinado.</p>

<h2><a class="h_ident" id="h-J4o1MED4vw" href="#h-J4o1MED4vw" tabindex="-1" role="presentation"></a>Cadenas</h2>

<p><a class="p_ident" id="p-LSngdQYH80" href="#p-LSngdQYH80" tabindex="-1" role="presentation"></a>El siguiente tipo de dato básico es la <em>cadena</em> (en inglés, <em>string</em>). Las cadenas se utilizan para representar texto. Se escriben encerrando su contenido entre comillas.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-qjwe3Dgr5R" href="#c-qjwe3Dgr5R" tabindex="-1" role="presentation"></a><span class="tok-string2">`En el mar`</span>
<span class="tok-string">&quot;Acostado en el océano&quot;</span>
<span class="tok-string">'Flotando en el océano'</span></pre>

<p><a class="p_ident" id="p-IHr2y937ks" href="#p-IHr2y937ks" tabindex="-1" role="presentation"></a>Puedes usar comillas simples, comillas dobles o acentos graves para marcar las cadenas, siempre y cuando el tipo de comillas al principio y al final de la cadena coincidan.</p>

<p><a class="p_ident" id="p-FbJ7LdbtTG" href="#p-FbJ7LdbtTG" tabindex="-1" role="presentation"></a>Puedes poner casi cualquier cosa entre comillas para que JavaScript genere un valor de tipo cadena a partir de ello. Pero algunos caracteres son más difíciles. Ya te puedes imaginar lo complicado que sería poner comillas entre comillas, ya que parecerían el final de la cadena. <em>Saltos de línea</em> (los caracteres que obtienes cuando le das al <span class="keyname">enter</span>) solo se pueden incluir cuando la cadena está entre acentos graves (<code>`</code>).</p>

<p><a class="p_ident" id="p-EcZzTv5ywl" href="#p-EcZzTv5ywl" tabindex="-1" role="presentation"></a>Para poder incluir tales caracteres en una cadena, se utiliza la siguiente notación: una barra invertida (<code>\</code>) dentro de un texto entre comillas indica que el carácter posterior tiene un significado especial. A esto se le llama <em>escapar</em> el carácter. Una comilla que va precedida por una barra invertida no finalizará la cadena, sino que formará parte de ella. Cuando un carácter <code>n</code> aparece después de una barra invertida, se interpreta como un salto de línea. De manera similar, un <code>t</code> después de una barra invertida significa un carácter de tabulación. Consideremos la siguiente cadena:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-3CI2v7hMPn" href="#c-3CI2v7hMPn" tabindex="-1" role="presentation"></a><span class="tok-string">&quot;Esta es la primera línea</span><span class="tok-string2">\n</span><span class="tok-string">Y esta es la segunda&quot;</span></pre>

<p><a class="p_ident" id="p-WlFCbJE05Z" href="#p-WlFCbJE05Z" tabindex="-1" role="presentation"></a>Este es el texto real de esa cadena:</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-fV5QN7Aj+D" href="#c-fV5QN7Aj+D" tabindex="-1" role="presentation"></a>Esta es la primera línea
Y esta es la segunda</pre>

<p><a class="p_ident" id="p-RWoLLBFRNt" href="#p-RWoLLBFRNt" tabindex="-1" role="presentation"></a>Por supuesto, hay situaciones en las que te gustaría que una barra invertida en una cadena fuera simplemente una barra invertida, no un código especial. Si aparecen dos barras invertidas seguidas en una cadena, estas colapsarán en una en el valor de cadena resultante. Así es como se puede expresar la cadena “<em>Un carácter de salto de línea se escribe como <code>&quot;</code>\n<code>&quot;</code>.</em>”:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-r8ADhqGojW" href="#c-r8ADhqGojW" tabindex="-1" role="presentation"></a><span class="tok-string">&quot;Un carácter de salto de línea se escribe como </span><span class="tok-string2">\&quot;</span><span class="tok-string2">\\</span><span class="tok-string">n</span><span class="tok-string2">\&quot;</span><span class="tok-string">.&quot;</span></pre>

<p id="unicode"><a class="p_ident" id="p-mbzJaYAs/g" href="#p-mbzJaYAs/g" tabindex="-1" role="presentation"></a>Las cadenas también hay que modelarlas como una serie de bits para que puedan existir dentro de la computadora. La forma en que JavaScript lo hace se basa en el estándar <em>Unicode</em>. Este estándar asigna un número a prácticamente cada carácter que puedas necesitar, incluidos los caracteres griegos, árabes, japoneses, armenios, etc. Si tenemos un número para cada carácter, una cadena puede ser descrita por una secuencia de números. Y eso es lo que hace JavaScript.</p>

<p><a class="p_ident" id="p-bmXKm5HFnp" href="#p-bmXKm5HFnp" tabindex="-1" role="presentation"></a>Pero hay una complicación: la representación de JavaScript utiliza 16 bits por cada elemento de tipo cadena, lo que puede describir hasta 2<sup>16</sup> caracteres diferentes. Sin embargo, Unicode define más caracteres (alrededor del doble que eso, de momento). Por lo tanto, algunos caracteres, como muchos emoji, ocupan dos “posiciones de caracteres” en las cadenas de JavaScript. Volveremos a esto en el <a href="05_higher_order.html#code_units">Capítulo 5</a>.</p>

<p><a class="p_ident" id="p-yVQTjTfX8O" href="#p-yVQTjTfX8O" tabindex="-1" role="presentation"></a>Las cadenas no se pueden dividir, multiplicar o restar. El operador <code>+</code> se puede usar en ellas, no para sumar, sino para <em>concatenar</em> (unir dos cadenas). La siguiente línea producirá la cadena <code>&quot;concatenar&quot;</code>:</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-meta="expr"><a class="c_ident" id="c-AF1pg1pIWq" href="#c-AF1pg1pIWq" tabindex="-1" role="presentation"></a><span class="tok-string">&quot;con&quot;</span> + <span class="tok-string">&quot;cat&quot;</span> + <span class="tok-string">&quot;e&quot;</span> + <span class="tok-string">&quot;nar&quot;</span></pre>

<p><a class="p_ident" id="p-lOVOo+omcp" href="#p-lOVOo+omcp" tabindex="-1" role="presentation"></a>Los valores de tipo cadena tienen una serie de funciones asociadas (<em>métodos</em>) que se pueden utilizar para realizar otras operaciones con ellos. Hablaré más sobre esto en el <a href="04_data.html#methods">Capítulo 4</a>.</p>

<p><a class="p_ident" id="p-ihSs5peL7s" href="#p-ihSs5peL7s" tabindex="-1" role="presentation"></a>Las cadenas escritas con comillas simples o dobles se comportan de manera muy similar, la única diferencia radica en qué tipo de comilla necesitas escapar dentro de ellas. Las cadenas entre acentos graves, generalmente llamadas <em>template literals</em>, pueden hacer algunas cosas más. Aparte de poder abarcar varias líneas, también pueden incrustar otros valores.</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-meta="expr"><a class="c_ident" id="c-Q70paqTNYa" href="#c-Q70paqTNYa" tabindex="-1" role="presentation"></a><span class="tok-string2">`la mitad de 100 es </span>${<span class="tok-number">100</span> / <span class="tok-number">2</span>}<span class="tok-string2">`</span></pre>

<p><a class="p_ident" id="p-6tfJCNVaMB" href="#p-6tfJCNVaMB" tabindex="-1" role="presentation"></a>Cuando escribes algo dentro de <code>${}</code> en un <em>template literal</em>, su resultado se calculará, se convertirá en una cadena, y se incluirá en esa posición. Este ejemplo produce “<em>la mitad de 100 es 50</em>”.</p>

<h2><a class="h_ident" id="h-Ba/lVluC/D" href="#h-Ba/lVluC/D" tabindex="-1" role="presentation"></a>Operadores unarios</h2>

<p><a class="p_ident" id="p-301hsEim2E" href="#p-301hsEim2E" tabindex="-1" role="presentation"></a>No todos los operadores son símbolos. Algunos se representan con palabras. Un ejemplo es el operador <code>typeof</code>, que produce un valor de cadena que indica el tipo del valor que le proporcionas.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-iWT//VyY7j" href="#c-iWT//VyY7j" tabindex="-1" role="presentation"></a>console.log(<span class="tok-keyword">typeof</span> <span class="tok-number">4.5</span>)
<span class="tok-comment">// → number</span>
console.log(<span class="tok-keyword">typeof</span> <span class="tok-string">&quot;x&quot;</span>)
<span class="tok-comment">// → string</span></pre>

<p id="console.log"><a class="p_ident" id="p-8bF6kfCQe4" href="#p-8bF6kfCQe4" tabindex="-1" role="presentation"></a>Utilizaremos <code>console.log</code> en ejemplos de código para indicar que queremos ver el resultado de evaluar algo (veremos más sobre esto en el <a href="02_program_structure.html">próximo capítulo</a>).</p>

<p><a class="p_ident" id="p-IOtfkjfLvQ" href="#p-IOtfkjfLvQ" tabindex="-1" role="presentation"></a>Los otros operadores mostrados hasta ahora en este capítulo operaron sobre dos valores, pero <code>typeof</code> toma solo uno. Los operadores que utilizan dos valores se llaman operadores <em>binarios</em>, mientras que aquellos que toman uno se llaman operadores <em>unarios</em>. El operador menos (<code>-</code>) se puede usar tanto como un operador binario como un operador unario.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-VpL89RFAPj" href="#c-VpL89RFAPj" tabindex="-1" role="presentation"></a>console.log(- (<span class="tok-number">10</span> - <span class="tok-number">2</span>))
<span class="tok-comment">// → -8</span></pre>

<h2><a class="h_ident" id="h-hcL3SuiDyH" href="#h-hcL3SuiDyH" tabindex="-1" role="presentation"></a>Valores booleanos</h2>

<p><a class="p_ident" id="p-a0eGPQEgO5" href="#p-a0eGPQEgO5" tabindex="-1" role="presentation"></a>A menudo es útil tener un valor que distinga solo entre dos posibilidades, como “sí&quot; y “no” o “encendido” y “apagado”. Para este propósito, JavaScript tiene un tipo <em>Booleano</em>, que tiene solo dos valores, true y false, y que se escriben tal cual como esas palabras.</p>

<h3><a class="i_ident" id="i-j8pkHXp4wK" href="#i-j8pkHXp4wK" tabindex="-1" role="presentation"></a>Comparación</h3>

<p><a class="p_ident" id="p-9jdGN2oSxe" href="#p-9jdGN2oSxe" tabindex="-1" role="presentation"></a>Aquí hay una forma de producir valores booleanos:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-GaxnXrIPwC" href="#c-GaxnXrIPwC" tabindex="-1" role="presentation"></a>console.log(<span class="tok-number">3</span> &gt; <span class="tok-number">2</span>)
<span class="tok-comment">// → true</span>
console.log(<span class="tok-number">3</span> &lt; <span class="tok-number">2</span>)
<span class="tok-comment">// → false</span></pre>

<p><a class="p_ident" id="p-o9ffjM6Row" href="#p-o9ffjM6Row" tabindex="-1" role="presentation"></a>Los signos <code>&gt;</code> y <code>&lt;</code> son símbolos tradicionales para “es mayor que” y “es menor que”, respectivamente. Son operadores binarios. Aplicarlos da como resultado un valor booleano que indica si son verdaderos en el caso en cuestión.</p>

<p><a class="p_ident" id="p-Ch4A0mWDGs" href="#p-Ch4A0mWDGs" tabindex="-1" role="presentation"></a>Las cadenas se pueden comparar de la misma manera:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Qud5plnVuV" href="#c-Qud5plnVuV" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">&quot;Aardvark&quot;</span> &lt; <span class="tok-string">&quot;Zoroaster&quot;</span>)
<span class="tok-comment">// → true</span></pre>

<p><a class="p_ident" id="p-P6ToKNBzPW" href="#p-P6ToKNBzPW" tabindex="-1" role="presentation"></a>El orden entre casenas es más o menos el alfabético pero no exactamente como se hace en un diccionario: las letras mayúsculas son siempre “menores” que las minúsculas, conque <code>&quot;Z&quot; &lt; &quot;a&quot;</code>; y los caracteres no alfabéticos (!, -, etc.) también se incluyen en la ordenación. Para comparar cadenas, lo que JavaScript hace es recorrer los caracteres de izquierda a derecha, comparando los códigos Unicode uno por uno.</p>

<p><a class="p_ident" id="p-LWMB/exwEI" href="#p-LWMB/exwEI" tabindex="-1" role="presentation"></a>Otros operadores similares son <code>&gt;=</code> (mayor o igual que), <code>&lt;=</code> (menor o igual que), <code>==</code> (igual a), y <code>!=</code> (no igual a).</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-iej8kEEcWL" href="#c-iej8kEEcWL" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">&quot;Granate&quot;</span> != <span class="tok-string">&quot;Rubí&quot;</span>)
<span class="tok-comment">// → true</span>
console.log(<span class="tok-string">&quot;Perla&quot;</span> == <span class="tok-string">&quot;Amatista&quot;</span>)
<span class="tok-comment">// → false</span></pre>

<p><a class="p_ident" id="p-Dhc9EDqGi3" href="#p-Dhc9EDqGi3" tabindex="-1" role="presentation"></a>Solo hay un valor en JavaScript que no es igual a sí mismo, y ese es <code>NaN</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Vhz09Rgw3h" href="#c-Vhz09Rgw3h" tabindex="-1" role="presentation"></a>console.log(NaN == NaN)
<span class="tok-comment">// → false</span></pre>

<p><a class="p_ident" id="p-sYaVOKvJs0" href="#p-sYaVOKvJs0" tabindex="-1" role="presentation"></a><code>NaN</code> se supone que denota el resultado de un cálculo sin sentido y, como tal, no es igual al resultado de ningún otro cálculo sin sentido.</p>

<h3><a class="i_ident" id="i-gt6oADpxuG" href="#i-gt6oADpxuG" tabindex="-1" role="presentation"></a>Operadores lógicos</h3>

<p><a class="p_ident" id="p-bDUM8R6qD8" href="#p-bDUM8R6qD8" tabindex="-1" role="presentation"></a>También hay algunas operaciones que se pueden aplicar a los propios valores Booleanos. JavaScript soporta tres operadores lógicos: <em>and</em> (y), <em>or</em> (o), y <em>not</em> (no). Estos se pueden usar para “razonar” sobre valores Booleanos.</p>

<p><a class="p_ident" id="p-IlZiB/NoWt" href="#p-IlZiB/NoWt" tabindex="-1" role="presentation"></a>El operador <code>&amp;&amp;</code> representa el <em>and</em> lógico. Es un operador binario, y su resultado es verdadero solo si los dos valores dados son verdaderos.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-SHi38sNkwM" href="#c-SHi38sNkwM" tabindex="-1" role="presentation"></a>console.log(true &amp;&amp; false)
<span class="tok-comment">// → false</span>
console.log(true &amp;&amp; true)
<span class="tok-comment">// → true</span></pre>

<p><a class="p_ident" id="p-CUv4iRpVzs" href="#p-CUv4iRpVzs" tabindex="-1" role="presentation"></a>El operador <code>||</code> representa el <em>or</em> lógico. Produce verdadero si cualquiera de los valores dados es verdadero.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-diXyv7iPd1" href="#c-diXyv7iPd1" tabindex="-1" role="presentation"></a>console.log(false || true)
<span class="tok-comment">// → true</span>
console.log(false || false)
<span class="tok-comment">// → false</span></pre>

<p><a class="p_ident" id="p-yd+g1Em++r" href="#p-yd+g1Em++r" tabindex="-1" role="presentation"></a><em>Not</em> se escribe con un signo de exclamación (<code>!</code>). Es un operador unario que invierte el valor del valor dado; <code>!true</code> produce <code>false</code> y <code>!false</code> produce <code>true</code>.</p>

<p><a class="p_ident" id="p-93dQyS+qYG" href="#p-93dQyS+qYG" tabindex="-1" role="presentation"></a>Al combinar estos operadores Booleanos con operadores aritméticos y otros operadores, no siempre es obvio cuándo se necesitan paréntesis. En la práctica, generalmente puedes tirar para alante sabiendo que, de los operadores que hemos visto hasta ahora, <code>||</code> tiene la menor precedencia, luego viene <code>&amp;&amp;</code>, luego los operadores de comparación (<code>&gt;</code>, <code>==</code>, etc.), y luego el resto. Este orden ha sido elegido de tal manera que, en expresiones típicas como la siguiente, se necesite la menor cantidad de paréntesis posible:</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-meta="expr"><a class="c_ident" id="c-6eZ07bDo11" href="#c-6eZ07bDo11" tabindex="-1" role="presentation"></a><span class="tok-number">1</span> + <span class="tok-number">1</span> == <span class="tok-number">2</span> &amp;&amp; <span class="tok-number">10</span> * <span class="tok-number">10</span> &gt; <span class="tok-number">50</span></pre>

<p><a class="p_ident" id="p-Wlk+fDzW24" href="#p-Wlk+fDzW24" tabindex="-1" role="presentation"></a>El último operador lógico que veremos no es unario ni binario, sino <em>ternario</em>, operando en tres valores. Se escribe con un signo de interrogación y dos puntos, como sigue:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-G7eVm8ilWm" href="#c-G7eVm8ilWm" tabindex="-1" role="presentation"></a>console.log(true ? <span class="tok-number">1</span> : <span class="tok-number">2</span>);
<span class="tok-comment">// → 1</span>
console.log(false ? <span class="tok-number">1</span> : <span class="tok-number">2</span>);
<span class="tok-comment">// → 2</span></pre>

<p><a class="p_ident" id="p-le+07C59qk" href="#p-le+07C59qk" tabindex="-1" role="presentation"></a>Este es el llamado operador <em>condicional</em> (o a veces simplemente <em>el operador ternario</em> ya que es el único operador de este tipo en el lenguaje). El operador usa el valor a la izquierda del signo de interrogación para decidir cuál de los otros dos valores “elegir”. Si escribes <code>a ? b : c</code>, el resultado será <code>b</code> cuando <code>a</code> es verdadero y <code>c</code> en caso contrario.</p>

<h2><a class="h_ident" id="h-u3yR/DNtwV" href="#h-u3yR/DNtwV" tabindex="-1" role="presentation"></a>Valores vacíos</h2>

<p><a class="p_ident" id="p-u9OVOcj2FK" href="#p-u9OVOcj2FK" tabindex="-1" role="presentation"></a>Hay dos valores especiales que se escriben <code>null</code> y <code>undefined</code> y que se utilizan para denotar la ausencia de un valor <em>significativo</em>. Son valores en sí mismos, pero no llevan ninguna información. Muchas operaciones en el lenguaje que no producen un valor significativo devuelven <code>undefined</code> simplemente porque tienen que devolver <em>algún</em> valor.</p>

<p><a class="p_ident" id="p-jFuq0AZiyF" href="#p-jFuq0AZiyF" tabindex="-1" role="presentation"></a>La diferencia en el significado entre <code>undefined</code> y <code>null</code> es un accidente del diseño de JavaScript, y la mayoría de las veces no es relevante. En casos en los que tienes que tratar con estos valores, recomiendo tratarlos como esencialmente intercambiables.</p>

<h2><a class="h_ident" id="h-d0EfIV+05Q" href="#h-d0EfIV+05Q" tabindex="-1" role="presentation"></a>Conversión automática de tipos</h2>

<p><a class="p_ident" id="p-hiiKbgQYbK" href="#p-hiiKbgQYbK" tabindex="-1" role="presentation"></a>En la <a href="00_intro.html">Introducción</a>, mencioné que JavaScript se pasa por aceptando cualquier programa que le des, incluso programas que hacen cosas extrañas. Esto se demuestra claramente con las siguientes expresiones:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-QqYG9KqZ2/" href="#c-QqYG9KqZ2/" tabindex="-1" role="presentation"></a>console.log(<span class="tok-number">8</span> * <span class="tok-keyword">null</span>)
<span class="tok-comment">// → 0</span>
console.log(<span class="tok-string">&quot;5&quot;</span> - <span class="tok-number">1</span>)
<span class="tok-comment">// → 4</span>
console.log(<span class="tok-string">&quot;5&quot;</span> + <span class="tok-number">1</span>)
<span class="tok-comment">// → 51</span>
console.log(<span class="tok-string">&quot;five&quot;</span> * <span class="tok-number">2</span>)
<span class="tok-comment">// → NaN</span>
console.log(false == <span class="tok-number">0</span>)
<span class="tok-comment">// → true</span></pre>

<p><a class="p_ident" id="p-kB8tbSpJvt" href="#p-kB8tbSpJvt" tabindex="-1" role="presentation"></a>Cuando se aplica un operador al tipo de valor “incorrecto”, JavaScript convertirá silenciosamente ese valor al tipo que necesita, utilizando una serie de reglas que a menudo no son las que buscas o esperas. Esto se llama <em>coerción de tipos</em>. El <code>null</code> en la primera expresión se convierte en <code>0</code> y el <code>&quot;5&quot;</code> en la segunda expresión se convierte en <code>5</code> (de cadena a número). Sin embargo, en la tercera expresión, <code>+</code> intenta la concatenación de cadenas antes que la suma de números, por lo que el <code>1</code> se convierte en <code>&quot;1&quot;</code> (de número a cadena).</p>

<p><a class="p_ident" id="p-Od4I2t6RG4" href="#p-Od4I2t6RG4" tabindex="-1" role="presentation"></a>Cuando se convierte en un número algo que no se corresponde de manera obvia con un número (como <code>&quot;five&quot;</code> o <code>undefined</code>), obtienes el valor <code>NaN</code>. Más operaciones aritméticas en <code>NaN</code> siguen produciendo <code>NaN</code>, así que si ves que te sale uno de estos en un lugar inesperado, busca conversiones de tipo accidentales.</p>

<p><a class="p_ident" id="p-UKIAT7ZHGQ" href="#p-UKIAT7ZHGQ" tabindex="-1" role="presentation"></a>Cuando se comparan valores del mismo tipo usando el operador <code>==</code>, el resultado es fácil de predecir: deberías obtener verdadero cuando ambos valores son iguales, excepto en el caso de <code>NaN</code>. Pero cuando los tipos difieren, JavaScript utiliza una serie de reglas extrañas para determinar qué hacer. En la mayoría de los casos, simplemente intenta convertir uno de los valores al tipo del otro valor. Sin embargo, cuando <code>null</code> o <code>undefined</code> aparecen en cualquiera de los lados del operador, este produce verdadero solo si el valor de ambos lados está entre <code>null</code> y <code>undefined</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-qmGDPdETlf" href="#c-qmGDPdETlf" tabindex="-1" role="presentation"></a>console.log(<span class="tok-keyword">null</span> == undefined);
<span class="tok-comment">// → true</span>
console.log(<span class="tok-keyword">null</span> == <span class="tok-number">0</span>);
<span class="tok-comment">// → false</span></pre>

<p><a class="p_ident" id="p-Xtu7tKxIxD" href="#p-Xtu7tKxIxD" tabindex="-1" role="presentation"></a>Ese comportamiento a menudo es útil. Cuando quieres comprobar si un valor tiene un valor real en lugar de <code>null</code> o <code>undefined</code>, puedes simplemente compararlo con <code>null</code> usando el operador <code>==</code> o <code>!=</code>.</p>

<p><a class="p_ident" id="p-B5GeEdriT6" href="#p-B5GeEdriT6" tabindex="-1" role="presentation"></a>¿Qué sucede si quieres probar si algo se refiere al valor preciso <code>false</code>? Expresiones como <code>0 == false</code> y <code>&quot;&quot; == false</code> también dan verdadero debido a la conversión automática de tipos. Cuando <em>no</em> deseas que ocurran conversiones de tipo, hay dos operadores adicionales: <code>===</code> y <code>!==</code>. El primero prueba si un valor es <em>precisamente</em> igual al otro, y el segundo prueba si no es precisamente igual. Por lo tanto, <code>&quot;&quot; === false</code> es falso, como era de esperar.</p>

<p><a class="p_ident" id="p-qXj7SOKlWI" href="#p-qXj7SOKlWI" tabindex="-1" role="presentation"></a>Recomiendo usar los operadores de comparación de tres caracteres de manera preventiva para evitar conversiones de tipo inesperadas que puedan complicarte las cosas. Pero cuando estés seguro de que los tipos en ambos lados serán los mismos, no hay problema en usar los otros operadores más cortos.</p>

<h3><a class="i_ident" id="i-SOUbB0ZSTp" href="#i-SOUbB0ZSTp" tabindex="-1" role="presentation"></a>Cortocircuito de operadores lógicos</h3>

<p><a class="p_ident" id="p-uieZyUDZJD" href="#p-uieZyUDZJD" tabindex="-1" role="presentation"></a>Los operadores lógicos <code>&amp;&amp;</code> y <code>||</code> manejan valores de tipos distintos de una forma peculiar. Convierten el valor del lado izquierdo a tipo Booleano para decidir qué hacer, pero, dependiendo del operador y el resultado de esa conversión, devuelven el valor <em>original</em> del lado izquierdo o el valor del lado derecho.</p>

<p><a class="p_ident" id="p-d+fK5uFMGA" href="#p-d+fK5uFMGA" tabindex="-1" role="presentation"></a>El operador <code>||</code>, por ejemplo, devolverá el valor de su izquierda cuando ese valor pueda convertirse en true y devolverá el valor de su derecha de lo contrario. Esto tiene el efecto esperado cuando los valores son Booleanos y hace algo análogo para valores de otros tipos.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-2QvcXTa0ga" href="#c-2QvcXTa0ga" tabindex="-1" role="presentation"></a>console.log(<span class="tok-keyword">null</span> || <span class="tok-string">&quot;usuario&quot;</span>)
<span class="tok-comment">// → usuario</span>
console.log(<span class="tok-string">&quot;Agnes&quot;</span> || <span class="tok-string">&quot;usuario&quot;</span>)
<span class="tok-comment">// → Agnes</span></pre>

<p><a class="p_ident" id="p-x9D4HrfdZX" href="#p-x9D4HrfdZX" tabindex="-1" role="presentation"></a>Podemos utilizar esta funcionalidad como una forma de utilizar un valor predeterminado. Si tienes un valor que podría estar vacío, puedes colocar <code>||</code> después de él con un valor de reemplazo. Si el valor inicial se puede convertir en false, obtendrás el valor de reemplazo en su lugar. Las reglas para convertir cadenas y números en valores Booleanos establecen que <code>0</code>, <code>NaN</code> y la cadena vacía (<code>&quot;&quot;</code>) cuentan como <code>false</code>, mientras que todos los demás valores serán <code>true</code>. Esto significa que <code>0 || -1</code> produce <code>-1</code>, y <code>&quot;&quot; || &quot;!?&quot;</code> da como resultado <code>&quot;!?&quot;</code>.</p>

<p><a class="p_ident" id="p-E/l93sJCpQ" href="#p-E/l93sJCpQ" tabindex="-1" role="presentation"></a>El operador <code>??</code> se parece a <code>||</code>, pero devuelve el valor de la derecha solo si el de la izquierda es null o undefined, no si es algún otro valor que se pueda convertir en <code>false</code>. Normalmente, este comportamiento es preferible al de <code>||</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-UVdLwFRz8U" href="#c-UVdLwFRz8U" tabindex="-1" role="presentation"></a>console.log(<span class="tok-number">0</span> || <span class="tok-number">100</span>);
<span class="tok-comment">// → 100</span>
console.log(<span class="tok-number">0</span> ?? <span class="tok-number">100</span>);
<span class="tok-comment">// → 0</span>
console.log(<span class="tok-keyword">null</span> ?? <span class="tok-number">100</span>);
<span class="tok-comment">// → 100</span></pre>

<p><a class="p_ident" id="p-NtTtZBsnPX" href="#p-NtTtZBsnPX" tabindex="-1" role="presentation"></a>El operador <code>&amp;&amp;</code> funciona de manera parecida pero en sentido contrario. Cuando el valor a su izquierda es algo que se convierte en false, devuelve ese valor, y de lo contrario devuelve el valor de su derecha.</p>

<p><a class="p_ident" id="p-DfC6QQzgoh" href="#p-DfC6QQzgoh" tabindex="-1" role="presentation"></a>Otra propiedad importante de estos dos operadores es que la parte de su derecha se evalúa solo cuando es necesario. En el caso de <code>true || X</code>, no importa lo que sea <code>X</code> —incluso si es una parte del programa que hace algo <em>terrible</em>—, el resultado será true, y <code>X</code> nunca se evaluará. Lo mismo ocurre con <code>false &amp;&amp; X</code>, que es false e ignorará <code>X</code>. Esto se llama <em>evaluación de cortocircuito</em> (o <em>evaluación mínima</em>).</p>

<p><a class="p_ident" id="p-tWKK3353PD" href="#p-tWKK3353PD" tabindex="-1" role="presentation"></a>El operador condicional funciona de manera similar. De los valores segundo y tercero, solo se evalúa el que sea seleccionado.</p>

<h2><a class="h_ident" id="h-NUFOUyK+lw" href="#h-NUFOUyK+lw" tabindex="-1" role="presentation"></a>Resumen</h2>

<p><a class="p_ident" id="p-zHupHOsvBq" href="#p-zHupHOsvBq" tabindex="-1" role="presentation"></a>En este capítulo examinamos cuatro tipos de valores en JavaScript: números, cadenas, Booleanos y valores indefinidos. Tales valores son creados escribiendo su nombre (<code>true</code>, <code>null</code>) o valor (<code>13</code>, <code>&quot;abc&quot;</code>).</p>

<p><a class="p_ident" id="p-V2oU2tKrEz" href="#p-V2oU2tKrEz" tabindex="-1" role="presentation"></a>Puedes combinar y transformar valores con operadores. Hemos visto operadores binarios para aritmética (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> y <code>%</code>), concatenación de cadenas (<code>+</code>), comparación (<code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) y lógica (<code>&amp;&amp;</code>, <code>||</code>, <code>??</code>), así como varios operadores unarios (<code>-</code> para obtener el opuesto de un número, <code>!</code> para negar lógicamente, y <code>typeof</code> para descubrir el tipo de un valor) y un operador ternario (<code>?:</code>) para elegir uno de dos valores basado en un tercer valor.</p>

<p><a class="p_ident" id="p-b3ceu9ngIK" href="#p-b3ceu9ngIK" tabindex="-1" role="presentation"></a>Esto es información suficiente para usar JavaScript como una calculadora de bolsillo, pero no mucho más. El <a href="02_program_structure.html">próximo capítulo</a> comenzará a unir estas expresiones en programas básicos.</p><nav><a href="00_intro.html" title="previous chapter" aria-label="previous chapter">◂</a> <a href="index.html" title="cover" aria-label="cover">●</a> <a href="02_program_structure.html" title="next chapter" aria-label="next chapter">▸</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>
</nav>
</article>

<script src="ejs.js"></script>
