<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Valores, Tipos y Operadores :: Eloquent JavaScript</title>
  <link rel=stylesheet href="css/ejs.css"><script>
      var page = {"type":"chapter","number":1}</script></head>

<article>
<nav><a href="00_intro.html" title="previous chapter" aria-label="previous chapter">◂</a> <a href="index.html" title="cover" aria-label="cover">●</a> <a href="02_program_structure.html" title="next chapter" aria-label="next chapter">▸</a>&nbsp;<button class="help" title="help" aria-label="help"><strong>?</strong></button>
</nav>

<h1>Valores, Tipos y Operadores</h1>

<p><a class="p_ident" id="p-CfZ0i1g49l" href="#p-CfZ0i1g49l" tabindex="-1" role="presentation"></a>“Debajo de la superficie de la máquina, el programa se mueve. Sin esfuerzo, se expande y contrae. En gran armonía, los electrones se dispersan y se reagrupan. Las formas en el monitor no son más que ondas en el agua. La esencia permanece invisible debajo.”<br>—Master Yuan-Ma, <em>El Libro de la Programación</em></p>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_1.jpg" alt="Ilustración de un destornillador junto a una placa de circuitos de aproximadamente el mismo tamaño"></figure>

<p><a class="p_ident" id="p-5q3V1d0pX9" href="#p-5q3V1d0pX9" tabindex="-1" role="presentation"></a>En el mundo de la computadora, solo existe data. Puedes leer data, modificar data, crear nueva data, pero aquello que no es data no puede ser mencionado. Toda esta data se almacena como largas secuencias de bits y, por lo tanto, es fundamentalmente similar.</p>

<p><a class="p_ident" id="p-ufYtysiybY" href="#p-ufYtysiybY" tabindex="-1" role="presentation"></a><em>Los bits</em> son cualquier tipo de cosas de dos valores, generalmente descritos como ceros y unos. Dentro de la computadora, toman formas como una carga eléctrica alta o baja, una señal fuerte o débil, o un punto brillante o opaco en la superficie de un CD. Cualquier pieza de información discreta puede reducirse a una secuencia de ceros y unos y por lo tanto representarse en bits.</p>

<p><a class="p_ident" id="p-e7UmOUc3PL" href="#p-e7UmOUc3PL" tabindex="-1" role="presentation"></a>Por ejemplo, podemos expresar el número 13 en bits. Esto funciona de la misma manera que un número decimal, pero en lugar de diez dígitos diferentes, tenemos solo 2, y el peso de cada uno aumenta por un factor de 2 de derecha a izquierda. Aquí están los bits que componen el número 13, con los pesos de los dígitos mostrados debajo de ellos:</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-+fMMNc3yUt" href="#c-+fMMNc3yUt" tabindex="-1" role="presentation"></a>   0   0   0   0   1   1   0   1
 128  64  32  16   8   4   2   1</pre>

<p><a class="p_ident" id="p-jb21kV7NPC" href="#p-jb21kV7NPC" tabindex="-1" role="presentation"></a>Ese es el número binario 00001101. Sus dígitos no nulos representan 8, 4 y 1, y suman 13.</p>

<h2><a class="h_ident" id="h-U9F8ZU147i" href="#h-U9F8ZU147i" tabindex="-1" role="presentation"></a>Valores</h2>

<p><a class="p_ident" id="p-ueMEhoC62i" href="#p-ueMEhoC62i" tabindex="-1" role="presentation"></a>Imagina una mar de bits—un océano de ellos. Una computadora moderna típica tiene más de 100 mil millones de bits en su almacenamiento de datos volátil (memoria de trabajo). El almacenamiento no volátil (el disco duro o equivalente) tiende a tener aún unos cuantos órdenes de magnitud más.</p>

<p><a class="p_ident" id="p-f1AoXKYSbn" href="#p-f1AoXKYSbn" tabindex="-1" role="presentation"></a>Para poder trabajar con tales cantidades de bits sin perderse, los separamos en trozos que representan piezas de información. En un entorno de JavaScript, esos trozos se llaman <em>valores</em>. Aunque todos los valores están hechos de bits, desempeñan roles diferentes. Cada valor tiene un tipo que determina su función. Algunos valores son números, otros son fragmentos de texto, otros son funciones, y así sucesivamente.</p>

<p><a class="p_ident" id="p-mJiLbj24GZ" href="#p-mJiLbj24GZ" tabindex="-1" role="presentation"></a>Para crear un valor, simplemente debes invocar su nombre. Esto es conveniente. No tienes que recolectar material de construcción para tus valores ni pagar por ellos. Solo solicitas uno, y ¡zas!, lo tienes. Por supuesto, los valores no se crean realmente de la nada. Cada uno tiene que almacenarse en algún lugar, y si deseas usar gigantescas cantidades de ellos al mismo tiempo, podrías quedarte sin memoria de computadora. Afortunadamente, este es un problema solo si los necesitas todos simultáneamente. Tan pronto como dejes de usar un valor, se disipará, dejando atrás sus bits para ser reciclados como material de construcción para la próxima generación de valores.El resto de este capítulo presenta los elementos atómicos de los programas de JavaScript, es decir, los tipos de valores simples y los operadores que pueden actuar sobre dichos valores.</p>

<h2><a class="h_ident" id="h-2eDSr4FTTr" href="#h-2eDSr4FTTr" tabindex="-1" role="presentation"></a>Números</h2>

<p><a class="p_ident" id="p-bOZDjE7yem" href="#p-bOZDjE7yem" tabindex="-1" role="presentation"></a>Los valores del tipo <em>number</em> son, como era de esperar, valores numéricos. En un programa de JavaScript, se escriben de la siguiente manera:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-/u5ErTZbax" href="#c-/u5ErTZbax" tabindex="-1" role="presentation"></a><span class="tok-number">13</span></pre>

<p><a class="p_ident" id="p-2b0WdUMWiY" href="#p-2b0WdUMWiY" tabindex="-1" role="presentation"></a>Usar esto en un programa hará que el patrón de bits para el número 13 exista en la memoria del ordenador.</p>

<p><a class="p_ident" id="p-iNSri5YZBd" href="#p-iNSri5YZBd" tabindex="-1" role="presentation"></a>JavaScript utiliza un número fijo de bits, 64 de ellos, para almacenar un único valor numérico. Solo hay tantos patrones que puedes hacer con 64 bits, lo que limita la cantidad de números diferentes que se pueden representar. Con <em>N</em> dígitos decimales, puedes representar 10<sup>N</sup> números. De manera similar, dada una cifra de 64 dígitos binarios, puedes representar 2<sup>64</sup> números diferentes, que son alrededor de 18 mil trillones (un 18 seguido de 18 ceros). Eso es mucho.</p>

<p><a class="p_ident" id="p-zoQfMGsjpS" href="#p-zoQfMGsjpS" tabindex="-1" role="presentation"></a>La memoria de la computadora solía ser mucho más pequeña, y la gente solía utilizar grupos de 8 o 16 bits para representar sus números. Era fácil tener un <em>desbordamiento</em> accidental con números tan pequeños, terminando con un número que no encajaba en la cantidad dada de bits. Hoy en día, incluso las computadoras que caben en tu bolsillo tienen mucha memoria, por lo que puedes utilizar trozos de 64 bits y solo necesitas preocuparte por el desbordamiento cuando lidias con números realmente astronómicos.</p>

<p><a class="p_ident" id="p-g9ZdolZbnN" href="#p-g9ZdolZbnN" tabindex="-1" role="presentation"></a>Sin embargo, no todos los números enteros menores que 18 mil trillones encajan en un número de JavaScript. Esos bits también almacenan números negativos, por lo que un bit indica el signo del número. Un problema más grande es representar números no enteros. Para hacer esto, algunos de los bits se utilizan para almacenar la posición del punto decimal. El número entero máximo real que se puede almacenar está más en el rango de 9 cuatrillones (15 ceros), que sigue siendo increíblemente grande.</p>

<p><a class="p_ident" id="p-QuaxCY0XYg" href="#p-QuaxCY0XYg" tabindex="-1" role="presentation"></a>Los números fraccionarios se escriben usando un punto:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-tM8nqv41Gp" href="#c-tM8nqv41Gp" tabindex="-1" role="presentation"></a><span class="tok-number">9.81</span></pre>

<p><a class="p_ident" id="p-swGkw2BgKN" href="#p-swGkw2BgKN" tabindex="-1" role="presentation"></a>Para números muy grandes o muy pequeños, también puedes usar notación científica agregando una <em>e</em> (de <em>exponente</em>), seguida del exponente del número:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-6ew5w+VhSM" href="#c-6ew5w+VhSM" tabindex="-1" role="presentation"></a><span class="tok-number">2.998e8</span></pre>

<p><a class="p_ident" id="p-vx7ox7vlBw" href="#p-vx7ox7vlBw" tabindex="-1" role="presentation"></a>Eso es 2.998 × 10<sup>8</sup> = 299,800,000.</p>

<p><a class="p_ident" id="p-At4IfW0/+5" href="#p-At4IfW0/+5" tabindex="-1" role="presentation"></a>Los cálculos con números enteros (también llamados <em>enteros</em>) que son más pequeños que los mencionados 9 cuatrillones siempre serán precisos. Desafortunadamente, los cálculos con números fraccionarios generalmente no lo son. Así como π (pi) no puede expresarse con precisión mediante un número finito de dígitos decimales, muchos números pierden algo de precisión cuando solo están disponibles 64 bits para almacenarlos. Es una lástima, pero solo causa problemas prácticos en situaciones específicas. Lo importante es ser consciente de esto y tratar los números digitales fraccionarios como aproximaciones, no como valores precisos.</p>

<h3><a class="i_ident" id="i-aIf95z3S0d" href="#i-aIf95z3S0d" tabindex="-1" role="presentation"></a>Aritmética</h3>

<p><a class="p_ident" id="p-tuQfTpUGDu" href="#p-tuQfTpUGDu" tabindex="-1" role="presentation"></a>{{index [sintaxis, operador], operador, “operador binario”, aritmética, suma, multiplicación}}</p>

<p><a class="p_ident" id="p-fEl5oInJjs" href="#p-fEl5oInJjs" tabindex="-1" role="presentation"></a>Lo principal que se puede hacer con los números es la aritmética. Operaciones aritméticas como la suma o la multiplicación toman dos valores numéricos y producen un nuevo número a partir de ellos. Así es como se ven en JavaScript:</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-meta="expr"><a class="c_ident" id="c-bSU4Vtv/mt" href="#c-bSU4Vtv/mt" tabindex="-1" role="presentation"></a><span class="tok-number">100</span> + <span class="tok-number">4</span> * <span class="tok-number">11</span></pre>

<p><a class="p_ident" id="p-PNPKgKWrHK" href="#p-PNPKgKWrHK" tabindex="-1" role="presentation"></a>Los símbolos <code>+</code> y <code>*</code> se llaman <em>operadores</em>. El primero representa la suma y el segundo representa la multiplicación. Colocar un operador entre dos valores aplicará ese operador a esos valores y producirá un nuevo valor.</p>

<p><a class="p_ident" id="p-rbQOL3GnYq" href="#p-rbQOL3GnYq" tabindex="-1" role="presentation"></a>¿Significa este ejemplo “Sumar 4 y 100, y luego multiplicar el resultado por 11”, o se realiza primero la multiplicación antes de la suma? Como habrás adivinado, la multiplicación se realiza primero. Como en matemáticas, puedes cambiar esto envolviendo la suma entre paréntesis:</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-meta="expr"><a class="c_ident" id="c-ij6V90ZZBQ" href="#c-ij6V90ZZBQ" tabindex="-1" role="presentation"></a>(<span class="tok-number">100</span> + <span class="tok-number">4</span>) * <span class="tok-number">11</span></pre>

<p><a class="p_ident" id="p-e9lhSXZbdW" href="#p-e9lhSXZbdW" tabindex="-1" role="presentation"></a>Para la resta, está el operador <code>-</code>. La división se puede hacer con el operador <code>/</code>.</p>

<p><a class="p_ident" id="p-OJONCWoI1T" href="#p-OJONCWoI1T" tabindex="-1" role="presentation"></a>Cuando los operadores aparecen juntos sin paréntesis, el orden en que se aplican se determina por la <em>precedencia</em> de los operadores. El ejemplo muestra que la multiplicación se realiza antes que la suma. El operador <code>/</code> tiene la misma precedencia que <code>*</code>. Igualmente, <code>+</code> y <code>-</code> tienen la misma precedencia. Cuando varios operadores con la misma precedencia aparecen uno al lado del otro, como en <code>1 - 2 + 1</code>, se aplican de izquierda a derecha: <code>(1 - 2) + 1</code>.</p>

<p><a class="p_ident" id="p-icq/wIw6Tp" href="#p-icq/wIw6Tp" tabindex="-1" role="presentation"></a>No te preocupes demasiado por estas reglas de precedencia. Cuando tengas dudas, simplemente agrega paréntesis.</p>

<p><a class="p_ident" id="p-6mDQ8afNaM" href="#p-6mDQ8afNaM" tabindex="-1" role="presentation"></a>Hay un operador aritmético más, que quizás no reconozcas de inmediato. El símbolo <code>%</code> se utiliza para representar la operación de <em>residuo</em>. <code>X % Y</code> es el residuo de dividir <code>X</code> por <code>Y</code>. Por ejemplo, <code>314 % 100</code> produce <code>14</code>, y <code>144 % 12</code> da <code>0</code>. La precedencia del operador de residuo es la misma que la de multiplicación y división. También verás a menudo a este operador referido como <em>módulo</em>.</p>

<h3><a class="i_ident" id="i-zFIgofBZed" href="#i-zFIgofBZed" tabindex="-1" role="presentation"></a>Números especiales</h3>

<p><a class="p_ident" id="p-Yzdmqjc9np" href="#p-Yzdmqjc9np" tabindex="-1" role="presentation"></a>Hay tres valores especiales en JavaScript que se consideran números pero no se comportan como números normales. Los dos primeros son <code>Infinity</code> y <code>-Infinity</code>, que representan el infinito positivo y negativo. <code>Infinity - 1</code> sigue siendo <code>Infinity</code>, y así sucesivamente. Sin embargo, no confíes demasiado en los cálculos basados en infinito. No es matemáticamente sólido y rápidamente te llevará al siguiente número especial: <code>NaN</code>.</p>

<p><a class="p_ident" id="p-FTEAETPV0R" href="#p-FTEAETPV0R" tabindex="-1" role="presentation"></a><code>NaN</code> significa “no es un número”, aunque <em>es</em> un valor del tipo numérico. Obtendrás este resultado cuando, por ejemplo, intentes calcular <code>0 / 0</code> (cero dividido por cero), <code>Infinity - Infinity</code>, u cualquier otra operación numérica que no produzca un resultado significativo.</p>

<h2><a class="h_ident" id="h-J4o1MED4vw" href="#h-J4o1MED4vw" tabindex="-1" role="presentation"></a>Cadenas</h2>

<p><a class="p_ident" id="p-LSngdQYH80" href="#p-LSngdQYH80" tabindex="-1" role="presentation"></a>El siguiente tipo de dato básico es la <em>cadena</em>. Las cadenas se utilizan para representar texto. Se escriben encerrando su contenido entre comillas.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-qjwe3Dgr5R" href="#c-qjwe3Dgr5R" tabindex="-1" role="presentation"></a><span class="tok-string2">`En el mar`</span>
<span class="tok-string">&quot;Acostado en el océano&quot;</span>
<span class="tok-string">'Flotando en el océano'</span></pre>

<p><a class="p_ident" id="p-IHr2y937ks" href="#p-IHr2y937ks" tabindex="-1" role="presentation"></a>Puedes usar comillas simples, comillas dobles o acentos graves para marcar las cadenas, siempre y cuando las comillas al principio y al final de la cadena coincidan.</p>

<p><a class="p_ident" id="p-FbJ7LdbtTG" href="#p-FbJ7LdbtTG" tabindex="-1" role="presentation"></a>Puedes poner casi cualquier cosa entre comillas para que JavaScript genere un valor de cadena a partir de ello. Pero algunos caracteres son más difíciles. Puedes imaginar lo complicado que sería poner comillas entre comillas, ya que parecerían el final de la cadena. <em>Saltos de línea</em> (los caracteres que obtienes al presionar <span class="keyname">enter</span>) solo se pueden incluir cuando la cadena está entre acentos graves (<code>`</code>).</p>

<p><a class="p_ident" id="p-EcZzTv5ywl" href="#p-EcZzTv5ywl" tabindex="-1" role="presentation"></a>Para poder incluir dichos caracteres en una cadena, se utiliza la siguiente notación: una barra invertida (<code>\</code>) dentro de un texto entre comillas indica que el carácter posterior tiene un significado especial. Esto se llama <em>escapar</em> el carácter. Una comilla que va precedida por una barra invertida no finalizará la cadena, sino que formará parte de ella. Cuando un carácter <code>n</code> aparece después de una barra invertida, se interpreta como un salto de línea. De manera similar, un <code>t</code> después de una barra invertida significa un carácter de tabulación. Toma la siguiente cadena:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-3CI2v7hMPn" href="#c-3CI2v7hMPn" tabindex="-1" role="presentation"></a><span class="tok-string">&quot;Esta es la primera línea</span><span class="tok-string2">\n</span><span class="tok-string">Y esta es la segunda&quot;</span></pre>

<p><a class="p_ident" id="p-WlFCbJE05Z" href="#p-WlFCbJE05Z" tabindex="-1" role="presentation"></a>Este es el texto real de esa cadena:</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-fV5QN7Aj+D" href="#c-fV5QN7Aj+D" tabindex="-1" role="presentation"></a>Esta es la primera línea
Y esta es la segunda</pre>

<p><a class="p_ident" id="p-RWoLLBFRNt" href="#p-RWoLLBFRNt" tabindex="-1" role="presentation"></a>Por supuesto, hay situaciones en las que deseas que una barra invertida en una cadena sea simplemente una barra invertida, no un código especial. Si dos barras invertidas van seguidas, se colapsarán juntas y solo quedará una en el valor de cadena resultante. Así es como se puede expresar la cadena “<em>Un carácter de nueva línea se escribe como <code>&quot;</code>\n<code>&quot;</code>.</em>”:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-vqlaw2tox2" href="#c-vqlaw2tox2" tabindex="-1" role="presentation"></a><span class="tok-string">&quot;Un carácter de nueva línea se escribe como </span><span class="tok-string2">\&quot;</span><span class="tok-string2">\\</span><span class="tok-string">n</span><span class="tok-string2">\&quot;</span><span class="tok-string">.&quot;</span></pre>

<p id="unicode"><a class="p_ident" id="p-mbzJaYAs/g" href="#p-mbzJaYAs/g" tabindex="-1" role="presentation"></a>Las cadenas también deben ser modeladas como una serie de bits para poder existir dentro de la computadora. La forma en que JavaScript lo hace se basa en el estándar <em>Unicode</em>. Este estándar asigna un número a prácticamente cada carácter que puedas necesitar, incluidos los caracteres griegos, árabes, japoneses, armenios, y así sucesivamente. Si tenemos un número para cada carácter, una cadena puede ser descrita por una secuencia de números. Y eso es lo que hace JavaScript.</p>

<p><a class="p_ident" id="p-KFiTtRshm2" href="#p-KFiTtRshm2" tabindex="-1" role="presentation"></a>Sin embargo, hay una complicación: la representación de JavaScript utiliza 16 bits por elemento de cadena, lo que puede describir hasta 2<sup>16</sup> caracteres diferentes. Sin embargo, Unicode define más caracteres que eso —aproximadamente el doble, en este momento. Por lo tanto, algunos caracteres, como muchos emoji, ocupan dos “posiciones de caracteres” en las cadenas de JavaScript. Volveremos a esto en [Capítulo ?] (higher_order#code_units).</p>

<p><a class="p_ident" id="p-yVQTjTfX8O" href="#p-yVQTjTfX8O" tabindex="-1" role="presentation"></a>Las cadenas no se pueden dividir, multiplicar o restar. El operador <code>+</code> se puede usar en ellas, no para sumar, sino para <em>concatenar</em> —unir dos cadenas. La siguiente línea producirá la cadena <code>&quot;concatenar&quot;</code>:</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-meta="expr"><a class="c_ident" id="c-eCO7oekmP9" href="#c-eCO7oekmP9" tabindex="-1" role="presentation"></a><span class="tok-string">&quot;con&quot;</span> + <span class="tok-string">&quot;cat&quot;</span> + <span class="tok-string">&quot;e&quot;</span> + <span class="tok-string">&quot;nate&quot;</span></pre>

<p><a class="p_ident" id="p-T3iEY8dvWU" href="#p-T3iEY8dvWU" tabindex="-1" role="presentation"></a>Los valores de cadena tienen una serie de funciones asociadas (<em>métodos</em>) que se pueden utilizar para realizar otras operaciones con ellos. Hablaré más sobre esto en <a href="04_data.html#methods">Capítulo 4</a>.</p>

<p><a class="p_ident" id="p-ihSs5peL7s" href="#p-ihSs5peL7s" tabindex="-1" role="presentation"></a>Las cadenas escritas con comillas simples o dobles se comportan de manera muy similar, la única diferencia radica en qué tipo de comilla necesitas escapar dentro de ellas. Las cadenas entre acentos graves, generalmente llamadas <em>template literals</em>, pueden hacer algunas cosas más. Aparte de poder abarcar varias líneas, también pueden incrustar otros valores.</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-meta="expr"><a class="c_ident" id="c-Q70paqTNYa" href="#c-Q70paqTNYa" tabindex="-1" role="presentation"></a><span class="tok-string2">`la mitad de 100 es </span>${<span class="tok-number">100</span> / <span class="tok-number">2</span>}<span class="tok-string2">`</span></pre>

<p><a class="p_ident" id="p-6tfJCNVaMB" href="#p-6tfJCNVaMB" tabindex="-1" role="presentation"></a>Cuando escribes algo dentro de <code>${}</code> en una plantilla literal, su resultado se calculará, se convertirá en una cadena y se incluirá en esa posición. Este ejemplo produce “<em>la mitad de 100 es 50</em>”.</p>

<h2><a class="h_ident" id="h-Ba/lVluC/D" href="#h-Ba/lVluC/D" tabindex="-1" role="presentation"></a>Operadores unarios</h2>

<p><a class="p_ident" id="p-301hsEim2E" href="#p-301hsEim2E" tabindex="-1" role="presentation"></a>No todos los operadores son símbolos. Algunos se escriben como palabras. Un ejemplo es el operador <code>typeof</code>, que produce un valor de cadena que indica el tipo del valor que le proporcionas.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-iWT//VyY7j" href="#c-iWT//VyY7j" tabindex="-1" role="presentation"></a>console.log(<span class="tok-keyword">typeof</span> <span class="tok-number">4.5</span>)
<span class="tok-comment">// → number</span>
console.log(<span class="tok-keyword">typeof</span> <span class="tok-string">&quot;x&quot;</span>)
<span class="tok-comment">// → string</span></pre>

<p id="console.log"><a class="p_ident" id="p-8bF6kfCQe4" href="#p-8bF6kfCQe4" tabindex="-1" role="presentation"></a>Utilizaremos <code>console.log</code> en ejemplos de código para indicar que queremos ver el resultado de evaluar algo. Más sobre eso en el <a href="02_program_structure.html">próximo capítulo</a>.</p>

<p><a class="p_ident" id="p-IOtfkjfLvQ" href="#p-IOtfkjfLvQ" tabindex="-1" role="presentation"></a>Los otros operadores mostrados hasta ahora en este capítulo operaron sobre dos valores, pero <code>typeof</code> toma solo uno. Los operadores que utilizan dos valores se llaman operadores <em>binarios</em>, mientras que aquellos que toman uno se llaman operadores <em>unarios</em>. El operador menos se puede usar tanto como un operador binario como un operador unario.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-VpL89RFAPj" href="#c-VpL89RFAPj" tabindex="-1" role="presentation"></a>console.log(- (<span class="tok-number">10</span> - <span class="tok-number">2</span>))
<span class="tok-comment">// → -8</span></pre>

<h2><a class="h_ident" id="h-hcL3SuiDyH" href="#h-hcL3SuiDyH" tabindex="-1" role="presentation"></a>Valores booleanos</h2>

<p><a class="p_ident" id="p-a0eGPQEgO5" href="#p-a0eGPQEgO5" tabindex="-1" role="presentation"></a>A menudo es útil tener un valor que distinga solo entre dos posibilidades, como “sí&quot; y “no” o “encendido” y “apagado”. Para este propósito, JavaScript tiene un tipo <em>Booleano</em>, que tiene solo dos valores, true y false, escritos como esas palabras.</p>

<h3><a class="i_ident" id="i-j8pkHXp4wK" href="#i-j8pkHXp4wK" tabindex="-1" role="presentation"></a>Comparación</h3>

<p><a class="p_ident" id="p-9jdGN2oSxe" href="#p-9jdGN2oSxe" tabindex="-1" role="presentation"></a>Aquí hay una forma de producir valores booleanos:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-GaxnXrIPwC" href="#c-GaxnXrIPwC" tabindex="-1" role="presentation"></a>console.log(<span class="tok-number">3</span> &gt; <span class="tok-number">2</span>)
<span class="tok-comment">// → true</span>
console.log(<span class="tok-number">3</span> &lt; <span class="tok-number">2</span>)
<span class="tok-comment">// → false</span></pre>

<p><a class="p_ident" id="p-RXzYYl/NBh" href="#p-RXzYYl/NBh" tabindex="-1" role="presentation"></a>Los signos <code>&gt;</code> y <code>&lt;</code> son símbolos tradicionales para “es mayor que” y “es menor que”, respectivamente. Son operadores binarios. Aplicarlos da como resultado un valor booleano que indica si son verdaderos en este caso.</p>

<p><a class="p_ident" id="p-Ch4A0mWDGs" href="#p-Ch4A0mWDGs" tabindex="-1" role="presentation"></a>Las cadenas se pueden comparar de la misma manera:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Qud5plnVuV" href="#c-Qud5plnVuV" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">&quot;Aardvark&quot;</span> &lt; <span class="tok-string">&quot;Zoroaster&quot;</span>)
<span class="tok-comment">// → true</span></pre>

<p><a class="p_ident" id="p-D+mD6K0/Wd" href="#p-D+mD6K0/Wd" tabindex="-1" role="presentation"></a>La forma en que se ordenan las cadenas es aproximadamente alfabética pero no es realmente lo que esperarías ver en un diccionario: las letras mayúsculas son siempre “menores” que las minúsculas, por lo que <code>&quot;Z&quot; &lt; &quot;a&quot;</code>, y los caracteres no alfabéticos (!, -, y así sucesivamente) también se incluyen en la ordenación. Al comparar cadenas, JavaScript recorre los caracteres de izquierda a derecha, comparando los códigos Unicode uno por uno.</p>

<p><a class="p_ident" id="p-LWMB/exwEI" href="#p-LWMB/exwEI" tabindex="-1" role="presentation"></a>Otros operadores similares son <code>&gt;=</code> (mayor o igual que), <code>&lt;=</code> (menor o igual que), <code>==</code> (igual a), y <code>!=</code> (no igual a).</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-iej8kEEcWL" href="#c-iej8kEEcWL" tabindex="-1" role="presentation"></a>console.log(<span class="tok-string">&quot;Granate&quot;</span> != <span class="tok-string">&quot;Rubí&quot;</span>)
<span class="tok-comment">// → true</span>
console.log(<span class="tok-string">&quot;Perla&quot;</span> == <span class="tok-string">&quot;Amatista&quot;</span>)
<span class="tok-comment">// → false</span></pre>

<p><a class="p_ident" id="p-qeF5rEgoVg" href="#p-qeF5rEgoVg" tabindex="-1" role="presentation"></a>Solo hay un valor en JavaScript que no es igual a sí mismo, y ese es <code>NaN</code> (“no es un número”).</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Vhz09Rgw3h" href="#c-Vhz09Rgw3h" tabindex="-1" role="presentation"></a>console.log(NaN == NaN)
<span class="tok-comment">// → false</span></pre>

<p><a class="p_ident" id="p-sYaVOKvJs0" href="#p-sYaVOKvJs0" tabindex="-1" role="presentation"></a><code>NaN</code> se supone que denota el resultado de un cálculo sin sentido y, como tal, no es igual al resultado de ningún otro cálculo sin sentido.</p>

<h3><a class="i_ident" id="i-gt6oADpxuG" href="#i-gt6oADpxuG" tabindex="-1" role="presentation"></a>Operadores lógicos</h3>

<p><a class="p_ident" id="p-bDUM8R6qD8" href="#p-bDUM8R6qD8" tabindex="-1" role="presentation"></a>También hay algunas operaciones que se pueden aplicar a los propios valores Booleanos. JavaScript soporta tres operadores lógicos: <em>and</em> (y), <em>or</em> (o), y <em>not</em> (no). Estos se pueden usar para “razonar” sobre valores Booleanos.</p>

<p><a class="p_ident" id="p-IlZiB/NoWt" href="#p-IlZiB/NoWt" tabindex="-1" role="presentation"></a>El operador <code>&amp;&amp;</code> representa el <em>and</em> lógico. Es un operador binario, y su resultado es verdadero solo si ambos valores dados son verdaderos.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-SHi38sNkwM" href="#c-SHi38sNkwM" tabindex="-1" role="presentation"></a>console.log(true &amp;&amp; false)
<span class="tok-comment">// → false</span>
console.log(true &amp;&amp; true)
<span class="tok-comment">// → true</span></pre>

<p><a class="p_ident" id="p-CUv4iRpVzs" href="#p-CUv4iRpVzs" tabindex="-1" role="presentation"></a>El operador <code>||</code> representa el <em>or</em> lógico. Produce verdadero si cualquiera de los valores dados es verdadero.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-diXyv7iPd1" href="#c-diXyv7iPd1" tabindex="-1" role="presentation"></a>console.log(false || true)
<span class="tok-comment">// → true</span>
console.log(false || false)
<span class="tok-comment">// → false</span></pre>

<p><a class="p_ident" id="p-yd+g1Em++r" href="#p-yd+g1Em++r" tabindex="-1" role="presentation"></a><em>Not</em> se escribe con un signo de exclamación (<code>!</code>). Es un operador unario que invierte el valor dado; <code>!true</code> produce <code>false</code> y <code>!false</code> produce <code>true</code>.</p>

<p><a class="p_ident" id="p-93dQyS+qYG" href="#p-93dQyS+qYG" tabindex="-1" role="presentation"></a>Al combinar estos operadores Booleanos con operadores aritméticos y otros operadores, no siempre es obvio cuándo se necesitan paréntesis. En la práctica, generalmente puedes avanzar sabiendo que de los operadores que hemos visto hasta ahora, <code>||</code> tiene la menor precedencia, luego viene <code>&amp;&amp;</code>, luego los operadores de comparación (<code>&gt;</code>, <code>==</code>, etc.), y luego el resto. Este orden ha sido elegido de tal manera que, en expresiones típicas como la siguiente, se necesiten la menor cantidad de paréntesis posible:</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-meta="expr"><a class="c_ident" id="c-6eZ07bDo11" href="#c-6eZ07bDo11" tabindex="-1" role="presentation"></a><span class="tok-number">1</span> + <span class="tok-number">1</span> == <span class="tok-number">2</span> &amp;&amp; <span class="tok-number">10</span> * <span class="tok-number">10</span> &gt; <span class="tok-number">50</span></pre>

<p><a class="p_ident" id="p-UiSwCiAKjN" href="#p-UiSwCiAKjN" tabindex="-1" role="presentation"></a>El último operador lógico que veremos no es unario ni binario, sino <em>ternario</em>, operando en tres valores. Se escribe con un signo de interrogación y dos puntos, así:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-G7eVm8ilWm" href="#c-G7eVm8ilWm" tabindex="-1" role="presentation"></a>console.log(true ? <span class="tok-number">1</span> : <span class="tok-number">2</span>);
<span class="tok-comment">// → 1</span>
console.log(false ? <span class="tok-number">1</span> : <span class="tok-number">2</span>);
<span class="tok-comment">// → 2</span></pre>

<p><a class="p_ident" id="p-iVFzSp2zoP" href="#p-iVFzSp2zoP" tabindex="-1" role="presentation"></a>Este se llama el operador <em>condicional</em> (o a veces simplemente <em>el operador ternario</em> ya que es el único operador de este tipo en el lenguaje). El operador usa el valor a la izquierda del signo de interrogación para decidir cuál de los otros dos valores “elegir”. Si escribes <code>a ? b : c</code>, el resultado será <code>b</code> cuando <code>a</code> es verdadero y <code>c</code> de lo contrario.</p>

<h2><a class="h_ident" id="h-u3yR/DNtwV" href="#h-u3yR/DNtwV" tabindex="-1" role="presentation"></a>Valores vacíos</h2>

<p><a class="p_ident" id="p-u9OVOcj2FK" href="#p-u9OVOcj2FK" tabindex="-1" role="presentation"></a>Hay dos valores especiales, escritos <code>null</code> y <code>undefined</code>, que se utilizan para denotar la ausencia de un valor <em>significativo</em>. Son valores en sí mismos, pero no llevan ninguna información.Muchas operaciones en el lenguaje que no producen un valor significativo devuelven <code>undefined</code> simplemente porque tienen que devolver <em>algún</em> valor.</p>

<p><a class="p_ident" id="p-m+cr0CKvEq" href="#p-m+cr0CKvEq" tabindex="-1" role="presentation"></a>La diferencia en el significado entre <code>undefined</code> y <code>null</code> es un accidente del diseño de JavaScript, y la mayoría de las veces no importa. En casos en los que realmente tienes que preocuparte por estos valores, recomiendo tratarlos como en su mayoría intercambiables.</p>

<h2><a class="h_ident" id="h-d0EfIV+05Q" href="#h-d0EfIV+05Q" tabindex="-1" role="presentation"></a>Conversión automática de tipos</h2>

<p><a class="p_ident" id="p-hiiKbgQYbK" href="#p-hiiKbgQYbK" tabindex="-1" role="presentation"></a>En la Introducción, mencioné que JavaScript se esfuerza por aceptar casi cualquier programa que le des, incluso programas que hacen cosas extrañas. Esto se demuestra claramente con las siguientes expresiones:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-QqYG9KqZ2/" href="#c-QqYG9KqZ2/" tabindex="-1" role="presentation"></a>console.log(<span class="tok-number">8</span> * <span class="tok-keyword">null</span>)
<span class="tok-comment">// → 0</span>
console.log(<span class="tok-string">&quot;5&quot;</span> - <span class="tok-number">1</span>)
<span class="tok-comment">// → 4</span>
console.log(<span class="tok-string">&quot;5&quot;</span> + <span class="tok-number">1</span>)
<span class="tok-comment">// → 51</span>
console.log(<span class="tok-string">&quot;five&quot;</span> * <span class="tok-number">2</span>)
<span class="tok-comment">// → NaN</span>
console.log(false == <span class="tok-number">0</span>)
<span class="tok-comment">// → true</span></pre>

<p><a class="p_ident" id="p-kB8tbSpJvt" href="#p-kB8tbSpJvt" tabindex="-1" role="presentation"></a>Cuando se aplica un operador al tipo de valor “incorrecto”, JavaScript convertirá silenciosamente ese valor al tipo que necesita, utilizando un conjunto de reglas que a menudo no son las que deseas o esperas. Esto se llama <em>coerción de tipos</em>. El <code>null</code> en la primera expresión se convierte en <code>0</code> y el <code>&quot;5&quot;</code> en la segunda expresión se convierte en <code>5</code> (de cadena a número). Sin embargo, en la tercera expresión, <code>+</code> intenta la concatenación de cadenas antes que la suma numérica, por lo que el <code>1</code> se convierte en <code>&quot;1&quot;</code> (de número a cadena).</p>

<p><a class="p_ident" id="p-jcnJfAvvp6" href="#p-jcnJfAvvp6" tabindex="-1" role="presentation"></a>Cuando algo que no se corresponde con un número de manera obvia (como <code>&quot;five&quot;</code> o <code>undefined</code>) se convierte en un número, obtienes el valor <code>NaN</code>. Más operaciones aritméticas en <code>NaN</code> siguen produciendo <code>NaN</code>, así que si te encuentras con uno de estos en un lugar inesperado, busca conversiones de tipo accidentales.</p>

<p><a class="p_ident" id="p-qunwSNidbj" href="#p-qunwSNidbj" tabindex="-1" role="presentation"></a>Cuando se comparan valores del mismo tipo usando el operador <code>==</code>, el resultado es fácil de predecir: deberías obtener verdadero cuando ambos valores son iguales, excepto en el caso de <code>NaN</code>. Pero cuando los tipos difieren, JavaScript utiliza un conjunto de reglas complicado y confuso para determinar qué hacer. En la mayoría de los casos, simplemente intenta convertir uno de los valores al tipo del otro valor. Sin embargo, cuando <code>null</code> o <code>undefined</code> aparece en cualquiera de los lados del operador, produce verdadero solo si ambos lados son uno de <code>null</code> o <code>undefined</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-qmGDPdETlf" href="#c-qmGDPdETlf" tabindex="-1" role="presentation"></a>console.log(<span class="tok-keyword">null</span> == undefined);
<span class="tok-comment">// → true</span>
console.log(<span class="tok-keyword">null</span> == <span class="tok-number">0</span>);
<span class="tok-comment">// → false</span></pre>

<p><a class="p_ident" id="p-Xtu7tKxIxD" href="#p-Xtu7tKxIxD" tabindex="-1" role="presentation"></a>Ese comportamiento a menudo es útil. Cuando quieres probar si un valor tiene un valor real en lugar de <code>null</code> o <code>undefined</code>, puedes compararlo con <code>null</code> usando el operador <code>==</code> o <code>!=</code>.</p>

<p><a class="p_ident" id="p-ov1vMdqygq" href="#p-ov1vMdqygq" tabindex="-1" role="presentation"></a>¿Qué sucede si quieres probar si algo se refiere al valor preciso <code>false</code>? Expresiones como <code>0 == false</code> y <code>&quot;&quot; == false</code> también son verdaderas debido a la conversión automática de tipos. Cuando <em>no</em> deseas que ocurran conversiones de tipo, hay dos operadores adicionales: <code>===</code> y <code>!==</code>. El primero prueba si un valor es <em>precisamente</em> igual al otro, y el segundo prueba si no es precisamente igual. Por lo tanto, <code>&quot;&quot; === false</code> es falso como se espera.Recomiendo usar los operadores de comparación de tres caracteres defensivamente para evitar conversiones de tipo inesperadas que puedan complicarte las cosas. Pero cuando estés seguro de que los tipos en ambos lados serán los mismos, no hay problema en usar los operadores más cortos.</p>

<h3><a class="i_ident" id="i-SOUbB0ZSTp" href="#i-SOUbB0ZSTp" tabindex="-1" role="presentation"></a>Cortocircuito de operadores lógicos</h3>

<p><a class="p_ident" id="p-uieZyUDZJD" href="#p-uieZyUDZJD" tabindex="-1" role="presentation"></a>Los operadores lógicos <code>&amp;&amp;</code> y <code>||</code> manejan valores de diferentes tipos de una manera peculiar. Convertirán el valor del lado izquierdo a tipo Booleano para decidir qué hacer, pero dependiendo del operador y el resultado de esa conversión, devolverán ya sea el valor original del lado izquierdo o el valor del lado derecho.</p>

<p><a class="p_ident" id="p-d+fK5uFMGA" href="#p-d+fK5uFMGA" tabindex="-1" role="presentation"></a>El operador <code>||</code>, por ejemplo, devolverá el valor de su izquierda cuando ese valor pueda convertirse en true y devolverá el valor de su derecha de lo contrario. Esto tiene el efecto esperado cuando los valores son Booleanos y hace algo análogo para valores de otros tipos.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-2QvcXTa0ga" href="#c-2QvcXTa0ga" tabindex="-1" role="presentation"></a>console.log(<span class="tok-keyword">null</span> || <span class="tok-string">&quot;usuario&quot;</span>)
<span class="tok-comment">// → usuario</span>
console.log(<span class="tok-string">&quot;Agnes&quot;</span> || <span class="tok-string">&quot;usuario&quot;</span>)
<span class="tok-comment">// → Agnes</span></pre>

<p><a class="p_ident" id="p-x9D4HrfdZX" href="#p-x9D4HrfdZX" tabindex="-1" role="presentation"></a>Podemos utilizar esta funcionalidad como una forma de utilizar un valor predeterminado. Si tienes un valor que podría estar vacío, puedes colocar <code>||</code> después de él con un valor de reemplazo. Si el valor inicial se puede convertir en false, obtendrás el valor de reemplazo en su lugar. Las reglas para convertir cadenas y números en valores Booleanos establecen que <code>0</code>, <code>NaN</code> y la cadena vacía (<code>&quot;&quot;</code>) cuentan como <code>false</code>, mientras que todos los demás valores cuentan como <code>true</code>. Esto significa que <code>0 || -1</code> produce <code>-1</code>, y <code>&quot;&quot; || &quot;!?&quot;</code> da como resultado <code>&quot;!?&quot;</code>.</p>

<p><a class="p_ident" id="p-E/l93sJCpQ" href="#p-E/l93sJCpQ" tabindex="-1" role="presentation"></a>El operador <code>??</code> se asemeja a <code>||</code>, pero devuelve el valor de la derecha solo si el de la izquierda es null o undefined, no si es algún otro valor que se pueda convertir en <code>false</code>. A menudo, este comportamiento es preferible al de <code>||</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-UVdLwFRz8U" href="#c-UVdLwFRz8U" tabindex="-1" role="presentation"></a>console.log(<span class="tok-number">0</span> || <span class="tok-number">100</span>);
<span class="tok-comment">// → 100</span>
console.log(<span class="tok-number">0</span> ?? <span class="tok-number">100</span>);
<span class="tok-comment">// → 0</span>
console.log(<span class="tok-keyword">null</span> ?? <span class="tok-number">100</span>);
<span class="tok-comment">// → 100</span></pre>

<p><a class="p_ident" id="p-NtTtZBsnPX" href="#p-NtTtZBsnPX" tabindex="-1" role="presentation"></a>El operador <code>&amp;&amp;</code> funciona de manera similar pero en sentido contrario. Cuando el valor a su izquierda es algo que se convierte en false, devuelve ese valor, y de lo contrario devuelve el valor de su derecha.</p>

<p><a class="p_ident" id="p-+rquv/zDNk" href="#p-+rquv/zDNk" tabindex="-1" role="presentation"></a>Otra propiedad importante de estos dos operadores es que la parte de su derecha se evalúa solo cuando es necesario. En el caso de <code>true || X</code>, no importa qué sea <code>X</code>, incluso si es una parte del programa que hace algo <em>terrible</em>, el resultado será true, y <code>X</code> nunca se evaluará. Lo mismo ocurre con <code>false &amp;&amp; X</code>, que es false e ignorará <code>X</code>. Esto se llama <em>evaluación de cortocircuito</em>.</p>

<p><a class="p_ident" id="p-tWKK3353PD" href="#p-tWKK3353PD" tabindex="-1" role="presentation"></a>El operador condicional funciona de manera similar. De los valores segundo y tercero, solo se evalúa el que sea seleccionado.</p>

<h2><a class="h_ident" id="h-NUFOUyK+lw" href="#h-NUFOUyK+lw" tabindex="-1" role="presentation"></a>Resumen</h2>

<p><a class="p_ident" id="p-8teOb/HsE+" href="#p-8teOb/HsE+" tabindex="-1" role="presentation"></a>En este capítulo examinamos cuatro tipos de valores en JavaScript: números, cadenas, Booleanos y valores indefinidos. Tales valores son creados escribiendo su nombre (<code>true</code>, <code>null</code>) o valor (<code>13</code>, <code>&quot;abc&quot;</code>).Puedes combinar y transformar valores con operadores. Vimos operadores binarios para aritmética (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> y <code>%</code>), concatenación de cadenas (<code>+</code>), comparación (<code>==</code>, <code>!=</code>, <code>===</code>, <code>!==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) y lógica (<code>&amp;&amp;</code>, <code>||</code>, <code>??</code>), así como varios operadores unarios (<code>-</code> para negar un número, <code>!</code> para negar lógicamente, y <code>typeof</code> para encontrar el tipo de un valor) y un operador ternario (<code>?:</code>) para elegir uno de dos valores basado en un tercer valor.</p>

<p><a class="p_ident" id="p-asWL1nI+Xu" href="#p-asWL1nI+Xu" tabindex="-1" role="presentation"></a>Esto te proporciona suficiente información para usar JavaScript como una calculadora de bolsillo, pero no mucho más. El <a href="02_program_structure.html">próximo capítulo</a> comenzará a unir estas expresiones en programas básicos.</p><nav><a href="00_intro.html" title="previous chapter" aria-label="previous chapter">◂</a> <a href="index.html" title="cover" aria-label="cover">●</a> <a href="02_program_structure.html" title="next chapter" aria-label="next chapter">▸</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>
</nav>
</article>

<script src="ejs.js"></script>
