<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Node.js :: Eloquent JavaScript</title>
  <link rel=stylesheet href="css/ejs.css"><script>
      var page = {"type":"chapter","number":20}</script></head>

<article>
<nav><a href="19_paint.html" title="previous chapter" aria-label="previous chapter">◂</a> <a href="index.html" title="cover" aria-label="cover">●</a> <a href="21_skillsharing.html" title="next chapter" aria-label="next chapter">▸</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>
</nav>

<h1>Node.js</h1>

<blockquote>

<p><a class="p_ident" id="p-i9iqRkQ4RC" href="#p-i9iqRkQ4RC" tabindex="-1" role="presentation"></a>Un estudiante preguntó: “Los programadores de antaño solo usaban máquinas simples y ningún lenguaje de programación, sin embargo, creaban programas hermosos. ¿Por qué nosotros usamos máquinas complicadas y lenguajes de programación?”. Fu-Tzu respondió: “Los constructores de antaño solo usaban palos y arcilla, sin embargo, creaban hermosas chozas.”</p>

<footer>Maestro Yuan-Ma, <cite>El Libro de la Programación</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_20.jpg" alt="Ilustración que muestra un poste telefónico con un enredo de cables en todas direcciones"></figure>

<p><a class="p_ident" id="p-ZVNZPnz/ZC" href="#p-ZVNZPnz/ZC" tabindex="-1" role="presentation"></a>Hasta ahora, hemos utilizado el lenguaje JavaScript en un solo entorno: el navegador. Este capítulo y el <a href="21_skillsharing.html">siguiente</a> introducirán brevemente Node.js, un programa que te permite aplicar tus habilidades con JavaScript fuera del navegador. Con él, puedes construir desde pequeñas herramientas de línea de comandos hasta servidores HTTP server que alimentan sitios web dinámicos.</p>

<p><a class="p_ident" id="p-tavS0sF06x" href="#p-tavS0sF06x" tabindex="-1" role="presentation"></a>Estos capítulos tienen como objetivo enseñarte los conceptos principales que Node.js utiliza y darte información suficiente para escribir programas útiles para él. No intentan ser un tratamiento completo, ni siquiera exhaustivo, de la plataforma.</p>

<p><a class="p_ident" id="p-1Lcjrmg2uD" href="#p-1Lcjrmg2uD" tabindex="-1" role="presentation"></a>Mientras que podrías ejecutar el código en los capítulos anteriores directamente en estas páginas, ya sea JavaScript puro o escrito para el navegador, los ejemplos de código en este capítulo están escritos para Node y a menudo no se ejecutarán en el navegador.</p>

<p><a class="p_ident" id="p-u232WdUbYW" href="#p-u232WdUbYW" tabindex="-1" role="presentation"></a>Si deseas seguir y ejecutar el código en este capítulo, necesitarás instalar Node.js versión 18 o superior. Para hacerlo, ve a <a href="https://nodejs.org"><em>https://nodejs.org</em></a> y sigue las instrucciones de instalación para tu sistema operativo. También puedes encontrar más documentación para Node.js allí.</p>

<h2><a class="h_ident" id="h-bv9WrnaS3g" href="#h-bv9WrnaS3g" tabindex="-1" role="presentation"></a>Antecedentes</h2>

<p><a class="p_ident" id="p-b5C83jVV2T" href="#p-b5C83jVV2T" tabindex="-1" role="presentation"></a>Cuando se construyen sistemas que se comunican a través de la red, la forma en que gestionas la entrada y el output—es decir, la lectura y escritura de datos desde y hacia la red y el disco duro—puede marcar una gran diferencia en cuán rápido responde un sistema al usuario o a las solicitudes de red.</p>

<p><a class="p_ident" id="p-EQnhnuy5FO" href="#p-EQnhnuy5FO" tabindex="-1" role="presentation"></a>En tales programas, la programación asincrónica a menudo es útil. Permite que el programa envíe y reciba datos desde y hacia múltiples dispositivos al mismo tiempo sin una complicada gestión de hilos y sincronización.</p>

<p><a class="p_ident" id="p-bf6O3xtNzR" href="#p-bf6O3xtNzR" tabindex="-1" role="presentation"></a>{{index “lenguaje de programación”, “Node.js”, estándar}}</p>

<p><a class="p_ident" id="p-AjtFUKKRB8" href="#p-AjtFUKKRB8" tabindex="-1" role="presentation"></a>Node fue concebido inicialmente con el propósito de hacer que la programación asincrónica sea fácil y conveniente. JavaScript se presta bien a un sistema como Node. Es uno de los pocos lenguajes de programación que no tiene una forma incorporada de manejar la entrada y salida. Por lo tanto, JavaScript podría adaptarse al enfoque algo excéntrico de Node para la programación de red y sistemas de archivos sin terminar con dos interfaces inconsistentes. En 2009, cuando se diseñaba Node, la gente ya estaba realizando programación basada en callbacks en el navegador, por lo que la comunidad alrededor del lenguaje estaba acostumbrada a un estilo de programación asincrónica.## El comando node</p>

<p><a class="p_ident" id="p-qa9aNXTUus" href="#p-qa9aNXTUus" tabindex="-1" role="presentation"></a>Cuando Node.js está instalado en un sistema, proporciona un programa llamado <code>node</code>, que se utiliza para ejecutar archivos de JavaScript. Supongamos que tienes un archivo <code>hello.js</code>, que contiene este código:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-mGmtX8ZFbB" href="#c-mGmtX8ZFbB" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">message</span> = <span class="tok-string">&quot;Hola mundo&quot;</span>;
console.log(message);</pre>

<p><a class="p_ident" id="p-/uXlGGpFk+" href="#p-/uXlGGpFk+" tabindex="-1" role="presentation"></a>Luego puedes ejecutar <code>node</code> desde la línea de comandos de la siguiente manera para ejecutar el programa:</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-KwqkOzuFaq" href="#c-KwqkOzuFaq" tabindex="-1" role="presentation"></a>$ node hello.js
Hola mundo</pre>

<p><a class="p_ident" id="p-9eFTrEoqAN" href="#p-9eFTrEoqAN" tabindex="-1" role="presentation"></a>El método <code>console.log</code> en Node hace algo similar a lo que hace en el navegador. Imprime un texto. Pero en Node, el texto irá al flujo de salida estándar del proceso, en lugar de ir a la consola de JavaScript de un navegador. Al ejecutar <code>node</code> desde la línea de comandos, significa que verás los valores registrados en tu terminal.</p>

<p><a class="p_ident" id="p-s+WcE2oW8u" href="#p-s+WcE2oW8u" tabindex="-1" role="presentation"></a>Si ejecutas <code>node</code> sin proporcionarle un archivo, te proporcionará un indicador en el que puedes escribir código JavaScript y ver inmediatamente el resultado.</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-d/9k6S5oD+" href="#c-d/9k6S5oD+" tabindex="-1" role="presentation"></a>$ node
&gt; 1 + 1
2
&gt; [-1, -2, -3].map(Math.abs)
[1, 2, 3]
&gt; process.exit(0)
$</pre>

<p><a class="p_ident" id="p-sUYZK1EnQP" href="#p-sUYZK1EnQP" tabindex="-1" role="presentation"></a>El enlace <code>process</code>, al igual que el enlace <code>console</code>, está disponible globalmente en Node. Proporciona varias formas de inspeccionar y manipular el programa actual. El método <code>exit</code> finaliza el proceso y puede recibir un código de estado de salida, que le indica al programa que inició <code>node</code> (en este caso, la shell de línea de comandos) si el programa se completó correctamente (código cero) o si se encontró un error (cualquier otro código).</p>

<p><a class="p_ident" id="p-W7/OzhvC4c" href="#p-W7/OzhvC4c" tabindex="-1" role="presentation"></a>Para encontrar los argumentos de línea de comandos dados a tu script, puedes leer <code>process.argv</code>, que es un array de cadenas. Ten en cuenta que también incluye el nombre del comando <code>node</code> y el nombre de tu script, por lo que los argumentos reales comienzan en el índice 2. Si <code>showargv.js</code> contiene la instrucción <code>console.<wbr>log(process.<wbr>argv)</code>, podrías ejecutarlo de la siguiente manera:</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-WCisDZr57g" href="#c-WCisDZr57g" tabindex="-1" role="presentation"></a>$ node showargv.js one --and two
[&quot;node&quot;, &quot;/tmp/showargv.js&quot;, &quot;one&quot;, &quot;--and&quot;, &quot;two&quot;]</pre>

<p><a class="p_ident" id="p-9BkJzZ0n1q" href="#p-9BkJzZ0n1q" tabindex="-1" role="presentation"></a>Todos los enlaces globales de JavaScript estándar, como <code>Array</code>, <code>Math</code> y <code>JSON</code>, también están presentes en el entorno de Node. La funcionalidad relacionada con el navegador, como <code>document</code> o <code>prompt</code>, no lo está.</p>

<h2><a class="h_ident" id="h-45kWH4U4Bd" href="#h-45kWH4U4Bd" tabindex="-1" role="presentation"></a>Módulos</h2>

<p><a class="p_ident" id="p-EJ7yQIM8FP" href="#p-EJ7yQIM8FP" tabindex="-1" role="presentation"></a>Además de los enlaces que mencioné, como <code>console</code> y <code>process</code>, Node agrega pocos enlaces adicionales en el ámbito global. Si deseas acceder a funcionalidades integradas, debes solicitarlas al sistema de módulos.</p>

<p><a class="p_ident" id="p-f49RycnPOb" href="#p-f49RycnPOb" tabindex="-1" role="presentation"></a>Node comenzó utilizando el sistema de módulos CommonJS, basado en la función <code>require</code>, que vimos en <a href="10_modules.html#commonjs">Capítulo 10</a>. Aún utilizará este sistema de forma predeterminada cuando cargues un archivo <code>.js</code>.</p>

<p><a class="p_ident" id="p-JXfnK+3SHG" href="#p-JXfnK+3SHG" tabindex="-1" role="presentation"></a>Pero también soporta el sistema de módulos ES más moderno. Cuando el nombre de un script termina en <code>.mjs</code>, se considera que es un módulo de este tipo, y puedes usar <code>import</code> y <code>export</code> en él (pero no <code>require</code>). Utilizaremos módulos ES en este capítulo.{{index [path, “sistema de archivos”], “ruta relativa”, resolución}}</p>

<p><a class="p_ident" id="p-cp71LSk3dO" href="#p-cp71LSk3dO" tabindex="-1" role="presentation"></a>Cuando se importa un módulo, ya sea con <code>require</code> o <code>import</code>, Node debe resolver la cadena proporcionada a un archivo real que pueda cargar. Los nombres que comienzan con <code>/</code>, <code>./</code> o <code>../</code> se resuelven como archivos, relativos a la ruta del módulo actual. Aquí, <code>.</code> representa el directorio actual, <code>../</code> para un directorio arriba, y <code>/</code> para la raíz del sistema de archivos. Por lo tanto, si solicitas <code>&quot;./<wbr>graph.<wbr>mjs&quot;</code> desde el archivo <code>/<wbr>tmp/<wbr>robot/<wbr>robot.<wbr>mjs</code>, Node intentará cargar el archivo <code>/<wbr>tmp/<wbr>robot/<wbr>graph.<wbr>mjs</code>.</p>

<p><a class="p_ident" id="p-+iwf8vlfx1" href="#p-+iwf8vlfx1" tabindex="-1" role="presentation"></a>Cuando se importa una cadena que no parece una ruta relativa o absoluta, se asume que se refiere a un módulo integrado o un módulo instalado en un directorio <code>node_modules</code>. Por ejemplo, importar desde <code>&quot;node:fs&quot;</code> te dará el módulo integrado del sistema de archivos de Node. E importar <code>&quot;robot&quot;</code> podría intentar cargar la biblioteca encontrada en <code>node_modules/<wbr>robot/<wbr></code>. Una forma común de instalar estas bibliotecas es usando NPM, a lo cual volveremos en un momento.</p>

<p><a class="p_ident" id="p-xlrDnOEgFK" href="#p-xlrDnOEgFK" tabindex="-1" role="presentation"></a>Configuremos un proyecto pequeño que consta de dos archivos. El primero, llamado <code>main.mjs</code>, define un script que puede ser llamado desde la línea de comandos para revertir una cadena.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-bbmWGTtySs" href="#c-bbmWGTtySs" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">reverse</span>} <span class="tok-keyword">from</span> <span class="tok-string">&quot;./reverse.mjs&quot;</span>;

<span class="tok-comment">// El índice 2 contiene el primer argumento real de la línea de comandos</span>
<span class="tok-keyword">let</span> <span class="tok-definition">argument</span> = process.argv[<span class="tok-number">2</span>];

console.log(reverse(argument));</pre>

<p><a class="p_ident" id="p-GxZL+OflbE" href="#p-GxZL+OflbE" tabindex="-1" role="presentation"></a>{{index reutilización, “función Array.from”, “método join”}}</p>

<p><a class="p_ident" id="p-XA7d0ksImw" href="#p-XA7d0ksImw" tabindex="-1" role="presentation"></a>El archivo <code>reverse.mjs</code> define una biblioteca para revertir cadenas, que puede ser utilizada tanto por esta herramienta de línea de comandos como por otros scripts que necesiten acceso directo a una función para revertir cadenas.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-p8FJa0H1D4" href="#c-p8FJa0H1D4" tabindex="-1" role="presentation"></a><span class="tok-keyword">export</span> <span class="tok-keyword">function</span> <span class="tok-definition">reverse</span>(<span class="tok-definition">string</span>) {
  <span class="tok-keyword">return</span> Array.from(string).reverse().join(<span class="tok-string">&quot;&quot;</span>);
}</pre>

<p><a class="p_ident" id="p-FRuD18IGa+" href="#p-FRuD18IGa+" tabindex="-1" role="presentation"></a>{{index “palabra clave export”, “módulos ES”, [interfaz, módulo]}}</p>

<p><a class="p_ident" id="p-HHZf0gHVDZ" href="#p-HHZf0gHVDZ" tabindex="-1" role="presentation"></a>Recuerda que <code>export</code> se utiliza para declarar que un enlace es parte de la interfaz del módulo. Eso permite que <code>main.mjs</code> importe y utilice la función.</p>

<p><a class="p_ident" id="p-kFzP7q7ejQ" href="#p-kFzP7q7ejQ" tabindex="-1" role="presentation"></a>Ahora podemos llamar a nuestra herramienta de esta manera:</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-LYQo5Arp8G" href="#c-LYQo5Arp8G" tabindex="-1" role="presentation"></a>$ node main.mjs JavaScript
tpircSavaJ</pre>

<h2><a class="h_ident" id="h-MoxrdWcLlT" href="#h-MoxrdWcLlT" tabindex="-1" role="presentation"></a>Instalando con NPM</h2>

<p><a class="p_ident" id="p-EdwkPKYJjz" href="#p-EdwkPKYJjz" tabindex="-1" role="presentation"></a>NPM, que fue introducido en <a href="10_modules.html#modules_npm">Capítulo 10</a>, es un repositorio en línea de módulos de JavaScript, muchos de los cuales están escritos específicamente para Node. Cuando instalas Node en tu computadora, también obtienes el comando <code>npm</code>, que puedes usar para interactuar con este repositorio.</p>

<p><a class="p_ident" id="p-eiIjy/CDcA" href="#p-eiIjy/CDcA" tabindex="-1" role="presentation"></a>El uso principal de NPM es descargar paquetes. Vimos el paquete <code>ini</code> en <a href="10_modules.html#modules_ini">Capítulo 10</a>. Podemos usar NPM para buscar e instalar ese paquete en nuestra computadora.</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-/RND8raC5h" href="#c-/RND8raC5h" tabindex="-1" role="presentation"></a>$ npm install ini
agregado 1 paquete en 723ms

$ node
&gt; const {parse} = require(&quot;ini&quot;);
&gt; parse(&quot;x = 1\ny = 2&quot;);
{ x: '1', y: '2' }</pre>

<p><a class="p_ident" id="p-IxsjoHG1Lb" href="#p-IxsjoHG1Lb" tabindex="-1" role="presentation"></a>Después de ejecutar <code>npm install</code>, NPM habrá creado un directorio llamado <code>node_modules</code>. Dentro de ese directorio estará un directorio <code>ini</code> que contiene la biblioteca. Puedes abrirlo y ver el código. Cuando importamos <code>&quot;ini&quot;</code>, esta biblioteca se carga, y podemos llamar a su propiedad <code>parse</code> para analizar un archivo de configuración.Por defecto, NPM instala paquetes en el directorio actual, en lugar de en un lugar centralizado. Si estás acostumbrado a otros gestores de paquetes, esto puede parecer inusual, pero tiene ventajas: pone a cada aplicación en control total de los paquetes que instala y facilita la gestión de versiones y limpieza al eliminar una aplicación.</p>

<h3><a class="i_ident" id="i-cQf3FV14Fd" href="#i-cQf3FV14Fd" tabindex="-1" role="presentation"></a>Archivos de paquete</h3>

<p><a class="p_ident" id="p-FfYB7hx8VS" href="#p-FfYB7hx8VS" tabindex="-1" role="presentation"></a>Después de ejecutar <code>npm install</code> para instalar algún paquete, encontrarás no solo un directorio <code>node_modules</code>, sino también un archivo llamado <code>package.json</code> en tu directorio actual. Se recomienda tener tal archivo para cada proyecto. Puedes crearlo manualmente o ejecutar <code>npm init</code>. Este archivo contiene información sobre el proyecto, como su nombre y versión, y enumera sus dependencias.</p>

<p><a class="p_ident" id="p-wjvaCZSoLl" href="#p-wjvaCZSoLl" tabindex="-1" role="presentation"></a>La simulación del robot de <a href="07_robot.html">Capítulo 7</a>, modularizada en el ejercicio en <a href="10_modules.html#modular_robot">Capítulo 10</a>, podría tener un archivo <code>package.json</code> como este:</p>

<pre class="snippet" data-language="json" ><a class="c_ident" id="c-w5ItHEwYvj" href="#c-w5ItHEwYvj" tabindex="-1" role="presentation"></a>{
  <span class="tok-string">&quot;author&quot;</span>: <span class="tok-string">&quot;Marijn Haverbeke&quot;</span>,
  <span class="tok-string">&quot;name&quot;</span>: <span class="tok-string">&quot;eloquent-javascript-robot&quot;</span>,
  <span class="tok-string">&quot;description&quot;</span>: <span class="tok-string">&quot;Simulación de un robot de entrega de paquetes&quot;</span>,
  <span class="tok-string">&quot;version&quot;</span>: <span class="tok-string">&quot;1.0.0&quot;</span>,
  <span class="tok-string">&quot;main&quot;</span>: <span class="tok-string">&quot;run.mjs&quot;</span>,
  <span class="tok-string">&quot;dependencies&quot;</span>: {
    <span class="tok-string">&quot;dijkstrajs&quot;</span>: <span class="tok-string">&quot;^1.0.1&quot;</span>,
    <span class="tok-string">&quot;random-item&quot;</span>: <span class="tok-string">&quot;^1.0.0&quot;</span>
  },
  <span class="tok-string">&quot;license&quot;</span>: <span class="tok-string">&quot;ISC&quot;</span>
}</pre>

<p><a class="p_ident" id="p-a5gRcLiGid" href="#p-a5gRcLiGid" tabindex="-1" role="presentation"></a>Cuando ejecutas <code>npm install</code> sin especificar un paquete para instalar, NPM instalará las dependencias enumeradas en <code>package.json</code>. Cuando instalas un paquete específico que no está listado como una dependencia, NPM lo añadirá a <code>package.json</code>.</p>

<h3><a class="i_ident" id="i-dPYCknJANY" href="#i-dPYCknJANY" tabindex="-1" role="presentation"></a>Versiones</h3>

<p><a class="p_ident" id="p-ppapKEIy7c" href="#p-ppapKEIy7c" tabindex="-1" role="presentation"></a>Un archivo <code>package.json</code> lista tanto la versión del propio programa como las versiones de sus dependencias. Las versiones son una forma de manejar el hecho de que los paquetes evolucionan por separado, y el código escrito para funcionar con un paquete tal como existía en un momento dado puede no funcionar con una versión posterior y modificada del paquete.</p>

<p><a class="p_ident" id="p-hXBNL5Yk0x" href="#p-hXBNL5Yk0x" tabindex="-1" role="presentation"></a>NPM exige que sus paquetes sigan un esquema llamado <em>semantic versioning</em>, que codifica información sobre qué versiones son <em>compatibles</em> (no rompen la antigua interfaz) en el número de versión. Una versión semántica consiste en tres números, separados por puntos, como <code>2.3.0</code>. Cada vez que se añade nueva funcionalidad, el número del medio debe incrementarse. Cada vez que se rompe la compatibilidad, de modo que el código existente que utiliza el paquete puede que no funcione con la nueva versión, el primer número debe incrementarse.</p>

<p><a class="p_ident" id="p-ne8+ivAT7p" href="#p-ne8+ivAT7p" tabindex="-1" role="presentation"></a>Un carácter de intercalación (<code>^</code>) delante del número de versión para una dependencia en <code>package.json</code> indica que se puede instalar cualquier versión compatible con el número dado. Por ejemplo, <code>&quot;^2.<wbr>3.<wbr>0&quot;</code> significaría que se permite cualquier versión mayor o igual a 2.3.0 y menor que 3.0.0.</p>

<p><a class="p_ident" id="p-glFarO71NK" href="#p-glFarO71NK" tabindex="-1" role="presentation"></a>El comando <code>npm</code> también se utiliza para publicar nuevos paquetes o nuevas versiones de paquetes. Si ejecutas <code>npm publish</code> en un directorio que tiene un archivo <code>package.json</code>, se publicará un paquete con el nombre y versión listados en el archivo JSON en el registro. Cualquiera puede publicar paquetes en NPM, aunque solo bajo un nombre de paquete que aún no esté en uso, ya que no sería bueno que personas aleatorias pudieran actualizar paquetes existentes.Este libro no profundizará más en los detalles del uso de NPM. Consulta <a href="https://npmjs.org"><em>https://npmjs.org</em></a> para obtener más documentación y una forma de buscar paquetes.</p>

<h2><a class="h_ident" id="h-4FFpIoHRzB" href="#h-4FFpIoHRzB" tabindex="-1" role="presentation"></a>El módulo del sistema de archivos</h2>

<p><a class="p_ident" id="p-C+k/JVrGOf" href="#p-C+k/JVrGOf" tabindex="-1" role="presentation"></a>Uno de los módulos integrados más utilizados en Node es el módulo <code>node:fs</code>, que significa <em>sistema de archivos</em>. Exporta funciones para trabajar con archivos y directorios.</p>

<p><a class="p_ident" id="p-dt+lHWnPRf" href="#p-dt+lHWnPRf" tabindex="-1" role="presentation"></a>{{index función “readFile”, “función de devolución de llamada”}}</p>

<p><a class="p_ident" id="p-0fez9kQsMK" href="#p-0fez9kQsMK" tabindex="-1" role="presentation"></a>Por ejemplo, la función llamada <code>readFile</code> lee un archivo y luego llama a una función de devolución de llamada con el contenido del archivo.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-VsqkE3ANgm" href="#c-VsqkE3ANgm" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">readFile</span>} <span class="tok-keyword">from</span> <span class="tok-string">&quot;node:fs&quot;</span>;
readFile(<span class="tok-string">&quot;archivo.txt&quot;</span>, <span class="tok-string">&quot;utf8&quot;</span>, (<span class="tok-definition">error</span>, <span class="tok-definition">texto</span>) =&gt; {
  <span class="tok-keyword">if</span> (error) <span class="tok-keyword">throw</span> error;
  console.log(<span class="tok-string">&quot;El archivo contiene:&quot;</span>, texto);
});</pre>

<p><a class="p_ident" id="p-Tr9Tr55xIA" href="#p-Tr9Tr55xIA" tabindex="-1" role="presentation"></a>El segundo argumento de <code>readFile</code> indica la <em>codificación de caracteres</em> utilizada para decodificar el archivo en una cadena. Existen varias formas en las que el texto puede ser codificado en datos binarios, pero la mayoría de los sistemas modernos utilizan UTF-8. Entonces, a menos que tengas razones para creer que se utiliza otra codificación, pasa <code>&quot;utf8&quot;</code> al leer un archivo de texto. Si no pasas una codificación, Node asumirá que estás interesado en los datos binarios y te dará un objeto <code>Buffer</code> en lugar de una cadena. Este es un objeto similar a un array que contiene números que representan los bytes (trozos de datos de 8 bits) en los archivos.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-nnbBYaleDu" href="#c-nnbBYaleDu" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">readFile</span>} <span class="tok-keyword">from</span> <span class="tok-string">&quot;node:fs&quot;</span>;
readFile(<span class="tok-string">&quot;archivo.txt&quot;</span>, (<span class="tok-definition">error</span>, <span class="tok-definition">buffer</span>) =&gt; {
  <span class="tok-keyword">if</span> (error) <span class="tok-keyword">throw</span> error;
  console.log(<span class="tok-string">&quot;El archivo contenía&quot;</span>, buffer.length, <span class="tok-string">&quot;bytes.&quot;</span>,
              <span class="tok-string">&quot;El primer byte es:&quot;</span>, buffer[<span class="tok-number">0</span>]);
});</pre>

<p><a class="p_ident" id="p-MMM0Baqfxv" href="#p-MMM0Baqfxv" tabindex="-1" role="presentation"></a>{{index función “writeFile”, “sistema de archivos”, [archivo, acceso]}}</p>

<p><a class="p_ident" id="p-om2+u0JXVt" href="#p-om2+u0JXVt" tabindex="-1" role="presentation"></a>Una función similar, <code>writeFile</code>, se utiliza para escribir un archivo en el disco.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-eMus/6Pliv" href="#c-eMus/6Pliv" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">writeFile</span>} <span class="tok-keyword">from</span> <span class="tok-string">&quot;node:fs&quot;</span>;
writeFile(<span class="tok-string">&quot;graffiti.txt&quot;</span>, <span class="tok-string">&quot;Node estuvo aquí&quot;</span>, <span class="tok-definition">err</span> =&gt; {
  <span class="tok-keyword">if</span> (err) console.log(<span class="tok-string2">`Error al escribir el archivo: </span>${err}<span class="tok-string2">`</span>);
  <span class="tok-keyword">else</span> console.log(<span class="tok-string">&quot;Archivo escrito.&quot;</span>);
});</pre>

<p><a class="p_ident" id="p-gUnVPgRs1A" href="#p-gUnVPgRs1A" tabindex="-1" role="presentation"></a>Aquí no fue necesario especificar la codificación: <code>writeFile</code> asumirá que cuando se le da una cadena para escribir, en lugar de un objeto <code>Buffer</code>, debe escribirla como texto utilizando su codificación de caracteres predeterminada, que es UTF-8.</p>

<p><a class="p_ident" id="p-6hCq6AXauT" href="#p-6hCq6AXauT" tabindex="-1" role="presentation"></a>{{index “node:fs”, función “readdir”, función “stat”, función “rename”, función “unlink”}}</p>

<p><a class="p_ident" id="p-2Dle5H5be+" href="#p-2Dle5H5be+" tabindex="-1" role="presentation"></a>El módulo <code>node:fs</code> contiene muchas otras funciones útiles: <code>readdir</code> te dará los archivos en un directorio como un array de cadenas, <code>stat</code> recuperará información sobre un archivo, <code>rename</code> cambiará el nombre de un archivo, <code>unlink</code> lo eliminará, entre otros. Consulta la documentación en <a href="https://nodejs.org"><em>https://nodejs.org</em></a> para obtener detalles específicos.</p>

<p><a class="p_ident" id="p-wjBSv7euy1" href="#p-wjBSv7euy1" tabindex="-1" role="presentation"></a>La mayoría de estas funciones toman una función de devolución de llamada como último parámetro, a la que llaman ya sea con un error (el primer argumento) o con un resultado exitoso (el segundo). Como vimos en <a href="11_async.html">Capítulo 11</a>, hay desventajas en este estilo de programación, siendo la mayor que el manejo de errores se vuelve verboso y propenso a errores.{{index “Clase Promise”, “paquete node:fs/promises”}}</p>

<p><a class="p_ident" id="p-5PK4VupJIX" href="#p-5PK4VupJIX" tabindex="-1" role="presentation"></a>El módulo <code>node:fs/promises</code> exporta la mayoría de las mismas funciones que el antiguo módulo <code>node:fs</code>, pero utiliza promesas en lugar de funciones de devolución de llamada.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Zh54f68FoC" href="#c-Zh54f68FoC" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">readFile</span>} <span class="tok-keyword">from</span> <span class="tok-string">&quot;node:fs/promises&quot;</span>;
readFile(<span class="tok-string">&quot;file.txt&quot;</span>, <span class="tok-string">&quot;utf8&quot;</span>)
  .then(<span class="tok-definition">text</span> =&gt; console.log(<span class="tok-string">&quot;El archivo contiene:&quot;</span>, text));</pre>

<p><a class="p_ident" id="p-eHp/9t5Scg" href="#p-eHp/9t5Scg" tabindex="-1" role="presentation"></a>A veces no necesitas asincronía y simplemente te estorba. Muchas de las funciones en <code>node:fs</code> también tienen una variante síncrona, que tiene el mismo nombre con <code>Sync</code> agregado al final. Por ejemplo, la versión síncrona de <code>readFile</code> se llama <code>readFileSync</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-F1N+amKpIz" href="#c-F1N+amKpIz" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">readFileSync</span>} <span class="tok-keyword">from</span> <span class="tok-string">&quot;node:fs&quot;</span>;
console.log(<span class="tok-string">&quot;El archivo contiene:&quot;</span>,
            readFileSync(<span class="tok-string">&quot;file.txt&quot;</span>, <span class="tok-string">&quot;utf8&quot;</span>));</pre>

<p><a class="p_ident" id="p-MnGIQPUgUW" href="#p-MnGIQPUgUW" tabindex="-1" role="presentation"></a>{{index optimización, rendimiento, bloqueo}}</p>

<p><a class="p_ident" id="p-UBT8FAnlTu" href="#p-UBT8FAnlTu" tabindex="-1" role="presentation"></a>Cabe destacar que mientras se realiza una operación síncrona de este tipo, tu programa se detiene por completo. Si debería estar respondiendo al usuario o a otras máquinas en la red, quedarse atrapado en una acción síncrona podría producir retrasos molestos.</p>

<h2><a class="h_ident" id="h-dabppseVCT" href="#h-dabppseVCT" tabindex="-1" role="presentation"></a>El módulo HTTP</h2>

<p><a class="p_ident" id="p-af0Pfzl8K0" href="#p-af0Pfzl8K0" tabindex="-1" role="presentation"></a>Otro módulo central se llama <code>node:http</code>. Proporciona funcionalidad para ejecutar un servidor HTTP.</p>

<p><a class="p_ident" id="p-k3MuCWd5Dq" href="#p-k3MuCWd5Dq" tabindex="-1" role="presentation"></a>Esto es todo lo que se necesita para iniciar un servidor HTTP:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-RHcbBDR1N/" href="#c-RHcbBDR1N/" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">createServer</span>} <span class="tok-keyword">from</span> <span class="tok-string">&quot;node:http&quot;</span>;
<span class="tok-keyword">let</span> <span class="tok-definition">server</span> = createServer((<span class="tok-definition">solicitud</span>, <span class="tok-definition">respuesta</span>) =&gt; {
  respuesta.writeHead(<span class="tok-number">200</span>, {<span class="tok-string">&quot;Content-Type&quot;</span>: <span class="tok-string">&quot;text/html&quot;</span>});
  respuesta.write(<span class="tok-string2">`</span>
<span class="tok-string2">    &lt;h1&gt;¡Hola!&lt;/h1&gt;</span>
<span class="tok-string2">    &lt;p&gt;Pediste &lt;code&gt;</span>${solicitud.url}<span class="tok-string2">&lt;/code&gt;&lt;/p&gt;`</span>);
  respuesta.end();
});
server.listen(<span class="tok-number">8000</span>);
console.log(<span class="tok-string">&quot;¡Escuchando! (puerto 8000)&quot;</span>);</pre>

<p><a class="p_ident" id="p-nrNhyBCrAg" href="#p-nrNhyBCrAg" tabindex="-1" role="presentation"></a>Si ejecutas este script en tu propia máquina, puedes apuntar tu navegador web a <a href="http://localhost:8000/hola"><em>http://localhost:8000/hola</em></a> para hacer una solicitud a tu servidor. Responderá con una pequeña página HTML.</p>

<p><a class="p_ident" id="p-INGY/PNK5X" href="#p-INGY/PNK5X" tabindex="-1" role="presentation"></a>La función pasada como argumento a <code>createServer</code> se llama cada vez que un cliente se conecta al servidor. Los enlaces <code>solicitud</code> y <code>respuesta</code> son objetos que representan los datos de entrada y salida. El primero contiene información sobre la solicitud, como su propiedad <code>url</code>, que nos dice a qué URL se hizo la solicitud.</p>

<p><a class="p_ident" id="p-9kr8owkFll" href="#p-9kr8owkFll" tabindex="-1" role="presentation"></a>Así que, cuando abres esa página en tu navegador, envía una solicitud a tu propia computadora. Esto hace que la función del servidor se ejecute y envíe una respuesta, que luego puedes ver en el navegador.</p>

<p><a class="p_ident" id="p-SfOGZCdQCH" href="#p-SfOGZCdQCH" tabindex="-1" role="presentation"></a>Para enviar algo al cliente, llamas a métodos en el objeto <code>respuesta</code>. El primero, <code>writeHead</code>, escribirá los encabezados de respuesta (ver <a href="18_http.html#encabezados">Capítulo 18</a>). Le das el código de estado (200 para “OK” en este caso) y un objeto que contiene valores de encabezado. El ejemplo establece el encabezado <code>Content-Type</code> para informar al cliente que estaremos enviando de vuelta un documento HTML.{{index “flujo de escritura”, “cuerpo (HTTP)”, stream, “método write”, “método end”}}</p>

<p><a class="p_ident" id="p-8ynV8UjqtW" href="#p-8ynV8UjqtW" tabindex="-1" role="presentation"></a>A continuación, el cuerpo real de la respuesta (el documento en sí) se envía con <code>response.write</code>. Se permite llamar a este método varias veces si deseas enviar la respuesta pieza por pieza, por ejemplo para transmitir datos al cliente a medida que estén disponibles. Por último, <code>response.end</code> señala el fin de la respuesta.</p>

<p><a class="p_ident" id="p-QpKSlbY/vo" href="#p-QpKSlbY/vo" tabindex="-1" role="presentation"></a>La llamada a <code>server.listen</code> hace que el servidor comience a esperar conexiones en el puerto 8000. Por eso debes conectarte a <em>localhost:8000</em> para comunicarte con este servidor, en lugar de simplemente a <em>localhost</em>, que usaría el puerto predeterminado 80.</p>

<p><a class="p_ident" id="p-939YnPvrTt" href="#p-939YnPvrTt" tabindex="-1" role="presentation"></a>Cuando ejecutas este script, el proceso se queda esperando. Cuando un script está escuchando eventos —en este caso, conexiones de red—, <code>node</code> no se cerrará automáticamente al llegar al final del script. Para cerrarlo, presiona <span class="keyname">control</span>-C.</p>

<p><a class="p_ident" id="p-+ntoNArGr3" href="#p-+ntoNArGr3" tabindex="-1" role="presentation"></a>{{index [método, HTTP]}}</p>

<p><a class="p_ident" id="p-WmCudMYcSj" href="#p-WmCudMYcSj" tabindex="-1" role="presentation"></a>Un verdadero servidor web server usualmente hace más cosas que el ejemplo; examina el método de la solicitud (la propiedad <code>method</code>) para ver qué acción está intentando realizar el cliente y mira el URL de la solicitud para descubrir sobre qué recurso se está realizando esta acción. Veremos un servidor más avanzado <a href="20_node.html#file_server">más adelante en este capítulo</a>.</p>

<p><a class="p_ident" id="p-btbFVE7L41" href="#p-btbFVE7L41" tabindex="-1" role="presentation"></a>El módulo <code>node:http</code> también provee una función <code>request</code>, que se puede usar para hacer solicitudes HTTP. Sin embargo, es mucho más engorroso de usar que <code>fetch</code>, que vimos en <a href="18_http.html">Capítulo 18</a>. Afortunadamente, <code>fetch</code> también está disponible en Node, como un enlace global. A menos que desees hacer algo muy específico, como procesar el documento de respuesta pieza por pieza a medida que llegan los datos a través de la red, recomiendo usar <code>fetch</code>.</p>

<h2><a class="h_ident" id="h-/tdw6BShQX" href="#h-/tdw6BShQX" tabindex="-1" role="presentation"></a>Flujos</h2>

<p><a class="p_ident" id="p-8QZY0sXowQ" href="#p-8QZY0sXowQ" tabindex="-1" role="presentation"></a>El objeto de respuesta al que el servidor HTTP podría escribir es un ejemplo de un objeto de <em>flujo de escritura</em>, que es un concepto ampliamente usado en Node. Estos objetos tienen un método <code>write</code> al que se puede pasar una cadena o un objeto <code>Buffer</code> para escribir algo en el flujo. Su método <code>end</code> cierra el flujo y opcionalmente toma un valor para escribir en el flujo antes de cerrarlo. Ambos métodos también pueden recibir una devolución de llamada como argumento adicional, que se llamará cuando la escritura o el cierre hayan finalizado.</p>

<p><a class="p_ident" id="p-3tXq6zb5kH" href="#p-3tXq6zb5kH" tabindex="-1" role="presentation"></a>Es posible crear un flujo de escritura que apunte a un archivo con la función <code>createWriteStream</code> del módulo <code>node:fs</code>. Luego puedes usar el método <code>write</code> en el objeto resultante para escribir el archivo pieza por pieza, en lugar de hacerlo de una sola vez como con <code>writeFile</code>.</p>

<p><a class="p_ident" id="p-oY4Bc5Lpge" href="#p-oY4Bc5Lpge" tabindex="-1" role="presentation"></a>Los <em>flujos legibles</em> son un poco más complejos. El argumento <code>request</code> para la devolución de llamada del servidor HTTP es un flujo legible. Leer de un flujo se hace utilizando manejadores de eventos, en lugar de métodos.{{index “método on”, “método addEventListener”}}</p>

<p><a class="p_ident" id="p-o2U33sZhdp" href="#p-o2U33sZhdp" tabindex="-1" role="presentation"></a>Los objetos que emiten eventos en Node tienen un método llamado <code>on</code> que es similar al método <code>addEventListener</code> en el navegador. Le das un nombre de evento y luego una función, y registrará esa función para que se llame cada vez que ocurra el evento dado.</p>

<p><a class="p_ident" id="p-bu65djE2o6" href="#p-bu65djE2o6" tabindex="-1" role="presentation"></a>Los streams legibles tienen eventos <code>&quot;data&quot;</code> y <code>&quot;end&quot;</code>. El primero se dispara cada vez que llegan datos, y el segundo se llama cuando el flujo llega a su fin. Este modelo es más adecuado para datos de <em>streaming</em> que pueden procesarse de inmediato, incluso cuando todo el documento aún no está disponible. Un archivo se puede leer como un flujo legible utilizando la función <code>createReadStream</code> de <code>node:fs</code>.</p>

<p><a class="p_ident" id="p-o7qy/ZwQY9" href="#p-o7qy/ZwQY9" tabindex="-1" role="presentation"></a>{{index “ejemplo de servidor de mayúsculas”, capitalización, “método toUpperCase”}}</p>

<p><a class="p_ident" id="p-KSoYRgbMl2" href="#p-KSoYRgbMl2" tabindex="-1" role="presentation"></a>Este código crea un servidor que lee los cuerpos de las solicitudes y los reenvía al cliente como texto en mayúsculas:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-dncpo30aqE" href="#c-dncpo30aqE" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">createServer</span>} <span class="tok-keyword">from</span> <span class="tok-string">&quot;node:http&quot;</span>;
createServer((<span class="tok-definition">solicitud</span>, <span class="tok-definition">respuesta</span>) =&gt; {
  respuesta.writeHead(<span class="tok-number">200</span>, {<span class="tok-string">&quot;Content-Type&quot;</span>: <span class="tok-string">&quot;text/plain&quot;</span>});
  solicitud.on(<span class="tok-string">&quot;data&quot;</span>, <span class="tok-definition">fragmento</span> =&gt;
    respuesta.write(fragmento.toString().toUpperCase()));
  solicitud.on(<span class="tok-string">&quot;end&quot;</span>, () =&gt; respuesta.end());
}).listen(<span class="tok-number">8000</span>);</pre>

<p><a class="p_ident" id="p-uGKPxOs3On" href="#p-uGKPxOs3On" tabindex="-1" role="presentation"></a>El valor <code>chunk</code> pasado al controlador de datos será un <code>Buffer</code> binario. Podemos convertir esto a una cadena decodificándolo como caracteres codificados en UTF-8 con su método <code>toString</code>.</p>

<p><a class="p_ident" id="p-raOCi6Y4Ip" href="#p-raOCi6Y4Ip" tabindex="-1" role="presentation"></a>El siguiente fragmento de código, cuando se ejecuta con el servidor de mayúsculas activo, enviará una solicitud a ese servidor y escribirá la respuesta que recibe:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-oHkRAhUdbQ" href="#c-oHkRAhUdbQ" tabindex="-1" role="presentation"></a>fetch(<span class="tok-string">&quot;http://localhost:8000/&quot;</span>, {
  <span class="tok-definition">method</span>: <span class="tok-string">&quot;POST&quot;</span>,
  <span class="tok-definition">body</span>: <span class="tok-string">&quot;Hola servidor&quot;</span>
}).then(<span class="tok-definition">resp</span> =&gt; resp.text()).then(console.log);
<span class="tok-comment">// → HOLA SERVIDOR</span></pre>

<h2 id="file_server"><a class="h_ident" id="h-uA++Rty3OD" href="#h-uA++Rty3OD" tabindex="-1" role="presentation"></a>Un servidor de archivos</h2>

<p><a class="p_ident" id="p-jU7doWE9wG" href="#p-jU7doWE9wG" tabindex="-1" role="presentation"></a>Combina nuestro nuevo conocimiento sobre los servidores HTTP y el trabajo con el sistema de archivos para crear un puente entre ambos: un servidor HTTP que permite el acceso remoto a un sistema de archivos. Este tipo de servidor tiene todo tipo de usos, como permitir que las aplicaciones web almacenen y compartan datos, o dar acceso compartido a un grupo de personas a un montón de archivos.</p>

<p><a class="p_ident" id="p-Zhrg6JSTjX" href="#p-Zhrg6JSTjX" tabindex="-1" role="presentation"></a>Cuando tratamos los archivos como recursos de HTTP, los métodos HTTP <code>GET</code>, <code>PUT</code> y <code>DELETE</code> se pueden usar para leer, escribir y eliminar los archivos, respectivamente. Interpretaremos la ruta en la solicitud como la ruta del archivo al que se refiere la solicitud.</p>

<p><a class="p_ident" id="p-x6JgKfdaZz" href="#p-x6JgKfdaZz" tabindex="-1" role="presentation"></a>Probablemente no queramos compartir todo nuestro sistema de archivos, por lo que interpretaremos estas rutas como comenzando en el directorio de trabajo del servidor, que es el directorio en el que se inició. Si ejecuté el servidor desde <code>/tmp/public/</code> (o <code>C:\tmp\public\</code> en Windows), entonces una solicitud para <code>/file.txt</code> debería referirse a <code>/<wbr>tmp/<wbr>public/<wbr>file.<wbr>txt</code> (o <code>C:\tmp\public\file.<wbr>txt</code>).</p>

<p><a class="p_ident" id="p-LJrlDVekKf" href="#p-LJrlDVekKf" tabindex="-1" role="presentation"></a>{{index “ejemplo de servidor de archivos”, “Node.js”, “objeto methods”, “clase Promise”}}Construiremos el programa paso a paso, utilizando un objeto llamado <code>methods</code> para almacenar las funciones que manejan los diferentes métodos HTTP. Los controladores de métodos son funciones <code>async</code> que reciben el objeto de solicitud como argumento y devuelven una promesa que se resuelve a un objeto que describe la respuesta.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-t1jsLbJd7n" href="#c-t1jsLbJd7n" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">createServer</span>} <span class="tok-keyword">from</span> <span class="tok-string">&quot;node:http&quot;</span>;

<span class="tok-keyword">const</span> <span class="tok-definition">methods</span> = Object.create(<span class="tok-keyword">null</span>);

createServer((<span class="tok-definition">request</span>, <span class="tok-definition">response</span>) =&gt; {
  <span class="tok-keyword">let</span> <span class="tok-definition">handler</span> = methods[request.method] || notAllowed;
  handler(request).catch(<span class="tok-definition">error</span> =&gt; {
    <span class="tok-keyword">if</span> (error.status != <span class="tok-keyword">null</span>) <span class="tok-keyword">return</span> error;
    <span class="tok-keyword">return</span> {<span class="tok-definition">body</span>: String(error), <span class="tok-definition">status</span>: <span class="tok-number">500</span>};
  }).then(({body, status = <span class="tok-number">200</span>, type = <span class="tok-string">&quot;text/plain&quot;</span>}) =&gt; {
    response.writeHead(status, {<span class="tok-string">&quot;Content-Type&quot;</span>: type});
    <span class="tok-keyword">if</span> (body &amp;&amp; body.pipe) body.pipe(response);
    <span class="tok-keyword">else</span> response.end(body);
  });
}).listen(<span class="tok-number">8000</span>);

<span class="tok-keyword">async</span> <span class="tok-keyword">function</span> <span class="tok-definition">notAllowed</span>(<span class="tok-definition">request</span>) {
  <span class="tok-keyword">return</span> {
    <span class="tok-definition">status</span>: <span class="tok-number">405</span>,
    <span class="tok-definition">body</span>: <span class="tok-string2">`Método </span>${request.method}<span class="tok-string2"> no permitido.`</span>
  };
}</pre>

<p><a class="p_ident" id="p-+zXJyjiv+x" href="#p-+zXJyjiv+x" tabindex="-1" role="presentation"></a>Esto inicia un servidor que simplemente devuelve respuestas de error 405, que es el código utilizado para indicar que el servidor se niega a manejar un método determinado.</p>

<p><a class="p_ident" id="p-LQFPuDuYA9" href="#p-LQFPuDuYA9" tabindex="-1" role="presentation"></a>Cuando la promesa de un controlador de solicitud es rechazada, la llamada a <code>catch</code> traduce el error en un objeto de respuesta, si aún no lo es, para que el servidor pueda enviar una respuesta de error para informar al cliente que no pudo manejar la solicitud.</p>

<p><a class="p_ident" id="p-1mh3Zz7i88" href="#p-1mh3Zz7i88" tabindex="-1" role="presentation"></a>El campo <code>status</code> de la descripción de la respuesta puede omitirse, en cuyo caso se establece en 200 (OK) por defecto. El tipo de contenido, en la propiedad <code>type</code>, también puede omitirse, en cuyo caso se asume que la respuesta es texto plano.</p>

<p><a class="p_ident" id="p-Lrm7n6XIp1" href="#p-Lrm7n6XIp1" tabindex="-1" role="presentation"></a>Cuando el valor de <code>body</code> es un readable stream, este tendrá un método <code>pipe</code> que se utiliza para reenviar todo el contenido de un flujo de lectura a un writable stream. Si no es así, se asume que es <code>null</code> (sin cuerpo), una cadena o un búfer, y se pasa directamente al método <code>end</code> del response.</p>

<p><a class="p_ident" id="p-VUJ0iLt8OX" href="#p-VUJ0iLt8OX" tabindex="-1" role="presentation"></a>{{index [ruta, URL], “función urlPath”, “clase URL”, análisis, [escape, “en las URL”], “función decodeURIComponent”, “método startsWith”}}</p>

<p><a class="p_ident" id="p-dslBfnWhvL" href="#p-dslBfnWhvL" tabindex="-1" role="presentation"></a>Para determinar qué ruta de archivo corresponde a una URL de solicitud, la función <code>urlPath</code> utiliza la clase integrada <code>URL</code> (que también existe en el navegador) para analizar la URL. Este constructor espera una URL completa, no solo la parte que comienza con la barra diagonal que obtenemos de <code>request.url</code>, por lo que le proporcionamos un nombre de dominio falso para completar. Extrae su ruta, que será algo como <code>&quot;/<wbr>archivo.<wbr>txt&quot;</code>, la decodifica para eliminar los códigos de escape estilo <code>%20</code>, y la resuelve en relación con el directorio de trabajo del programa.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-NEuFYZ8kXA" href="#c-NEuFYZ8kXA" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">parse</span>} <span class="tok-keyword">from</span> <span class="tok-string">&quot;node:url&quot;</span>;
<span class="tok-keyword">import</span> {<span class="tok-definition">resolve</span>, <span class="tok-definition">sep</span>} <span class="tok-keyword">from</span> <span class="tok-string">&quot;node:path&quot;</span>;

<span class="tok-keyword">const</span> <span class="tok-definition">baseDirectory</span> = process.cwd();

<span class="tok-keyword">function</span> <span class="tok-definition">urlPath</span>(<span class="tok-definition">url</span>) {
  <span class="tok-keyword">let</span> {pathname} = <span class="tok-keyword">new</span> URL(url, <span class="tok-string">&quot;http://d&quot;</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">path</span> = resolve(decodeURIComponent(pathname).slice(<span class="tok-number">1</span>));
  <span class="tok-keyword">if</span> (path != baseDirectory &amp;&amp;
      !path.startsWith(baseDirectory + sep)) {
    <span class="tok-keyword">throw</span> {<span class="tok-definition">status</span>: <span class="tok-number">403</span>, <span class="tok-definition">body</span>: <span class="tok-string">&quot;Prohibido&quot;</span>};
  }
  <span class="tok-keyword">return</span> path;
}
<span class="tok-string2">``</span><span class="tok-string2">`Tan pronto como configuras un programa para aceptar solicitudes de red, debes empezar a preocuparte por la ((seguridad)). En este caso, si no tenemos cuidado, es probable que terminemos exponiendo accidentalmente todo nuestro ((sistema de archivos)) a la red.</span>

<span class="tok-string2">Las rutas de archivos son cadenas en Node. Para mapear dicha cadena a un archivo real, hay una cantidad no trivial de interpretación en juego. Las rutas pueden, por ejemplo, incluir `</span>../<span class="tok-string2">` para hacer referencia a un directorio padre. Así que una fuente obvia de problemas serían las solicitudes de rutas como `</span>/../archivo_secreto<span class="tok-string2">`.</span>

<span class="tok-string2">{{index &quot;paquete node:path&quot;, &quot;función resolve&quot;, &quot;función cwd&quot;, &quot;objeto process&quot;, &quot;403 (código de estado HTTP)&quot;, &quot;vínculo sep&quot;, [&quot;carácter barra invertida&quot;, &quot;como separador de ruta&quot;], &quot;carácter barra&quot;}}</span>

<span class="tok-string2">Para evitar tales problemas, `</span>urlPath<span class="tok-string2">` utiliza la función `</span>resolve<span class="tok-string2">` del módulo `</span>node:path<span class="tok-string2">`, que resuelve rutas relativas. Luego verifica que el resultado esté _debajo_ del directorio de trabajo. La función `</span>process.cwd<span class="tok-string2">` (donde `</span>cwd<span class="tok-string2">` significa &quot;directorio de trabajo actual&quot;) se puede usar para encontrar este directorio de trabajo. El vínculo `</span>sep<span class="tok-string2">` del paquete `</span>node:path<span class="tok-string2">` es el separador de ruta del sistema: una barra invertida en Windows y una barra diagonal en la mayoría de otros sistemas. Cuando la ruta no comienza con el directorio base, la función arroja un objeto de respuesta de error, usando el código de estado HTTP que indica que el acceso al recurso está prohibido.</span>

<span class="tok-string2">{{index &quot;ejemplo de servidor de archivos&quot;, &quot;Node.js&quot;, &quot;método GET&quot;, [archivo, recurso]}}</span>

<span class="tok-string2">Configuraremos el método `</span>GET<span class="tok-string2">` para devolver una lista de archivos al leer un ((directorio)) y para devolver el contenido del archivo al leer un archivo regular.</span>

<span class="tok-string2">{{index &quot;tipo de medio&quot;, &quot;encabezado Content-Type&quot;, &quot;paquete mime-types&quot;}}</span>

<span class="tok-string2">Una pregunta complicada es qué tipo de encabezado `</span>Content-Type<span class="tok-string2">` debemos establecer al devolver el contenido de un archivo. Dado que estos archivos podrían ser cualquier cosa, nuestro servidor no puede simplemente devolver el mismo tipo de contenido para todos ellos. ((npm)) puede ayudarnos nuevamente aquí. El paquete `</span>mime-types<span class="tok-string2">` (los indicadores de tipo de contenido como `</span>text/plain<span class="tok-string2">` también se llaman _((tipos MIME))_) conoce el tipo correcto para una gran cantidad de ((extensiones de archivo)).</span>

<span class="tok-string2">{{index &quot;programa npm&quot;}}</span>

<span class="tok-string2">El siguiente comando de `</span>npm<span class="tok-string2">`, en el directorio donde reside el script del servidor, instala una versión específica de `</span>mime<span class="tok-string2">`:</span>

<span class="tok-string2">`</span><span class="tok-string2">``</span>{lang: <span class="tok-keyword">null</span>}
$ npm install mime-types<span class="tok-meta">@</span>2<span class="tok-number">.1</span>.<span class="tok-number">0</span></pre>

<p><a class="p_ident" id="p-oX7svPGvOz" href="#p-oX7svPGvOz" tabindex="-1" role="presentation"></a>Cuando un archivo solicitado no existe, el código de estado HTTP correcto a devolver es 404. Utilizaremos la función <code>stat</code>, que busca información sobre un archivo, para averiguar tanto si el archivo existe como si es un directorio.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-HNsvbqDhZq" href="#c-HNsvbqDhZq" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">createReadStream</span>} <span class="tok-keyword">from</span> <span class="tok-string">&quot;node:fs&quot;</span>;
<span class="tok-keyword">import</span> {<span class="tok-definition">stat</span>, <span class="tok-definition">readdir</span>} <span class="tok-keyword">from</span> <span class="tok-string">&quot;node:fs/promises&quot;</span>;
<span class="tok-keyword">import</span> {<span class="tok-definition">lookup</span>} <span class="tok-keyword">from</span> <span class="tok-string">&quot;mime-types&quot;</span>;

methods.GET = <span class="tok-keyword">async</span> <span class="tok-keyword">function</span>(<span class="tok-definition">request</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">path</span> = urlPath(request.url);
  <span class="tok-keyword">let</span> <span class="tok-definition">stats</span>;
  <span class="tok-keyword">try</span> {
    stats = <span class="tok-keyword">await</span> stat(path);
  } <span class="tok-keyword">catch</span> (<span class="tok-definition">error</span>) {
    <span class="tok-keyword">if</span> (error.code != <span class="tok-string">&quot;ENOENT&quot;</span>) <span class="tok-keyword">throw</span> error;
    <span class="tok-keyword">else</span> <span class="tok-keyword">return</span> {<span class="tok-definition">status</span>: <span class="tok-number">404</span>, <span class="tok-definition">body</span>: <span class="tok-string">&quot;Archivo no encontrado&quot;</span>};
  }
  <span class="tok-keyword">if</span> (stats.isDirectory()) {
    <span class="tok-keyword">return</span> {<span class="tok-definition">body</span>: (<span class="tok-keyword">await</span> readdir(path)).join(<span class="tok-string">&quot;</span><span class="tok-string2">\n</span><span class="tok-string">&quot;</span>)};
  } <span class="tok-keyword">else</span> {
    <span class="tok-keyword">return</span> {<span class="tok-definition">body</span>: createReadStream(path),
            <span class="tok-definition">type</span>: lookup(path)};
  }
};</pre>

<p><a class="p_ident" id="p-b0jz/pRFJE" href="#p-b0jz/pRFJE" tabindex="-1" role="presentation"></a>Debido a que debe acceder al disco y por lo tanto podría llevar algún tiempo, <code>stat</code> es asíncrono. Dado que estamos utilizando promesas en lugar del estilo de devolución de llamada, debe ser importado desde <code>node:fs/promises</code> en lugar de directamente desde <code>node:fs</code>.</p>

<p><a class="p_ident" id="p-JZjlGZPnMe" href="#p-JZjlGZPnMe" tabindex="-1" role="presentation"></a>Cuando el archivo no existe, <code>stat</code> lanzará un objeto de error con una propiedad <code>code</code> de <code>&quot;ENOENT&quot;</code>. Estos códigos algo oscuros, inspirados en Unix, son la forma en que se reconocen los tipos de error en Node.</p>

<p><a class="p_ident" id="p-3QdcZTE5z7" href="#p-3QdcZTE5z7" tabindex="-1" role="presentation"></a>El objeto <code>stats</code> devuelto por <code>stat</code> nos indica varias cosas sobre un archivo, como su tamaño (propiedad <code>size</code>) y su fecha de modificación (<code>mtime</code>). Aquí nos interesa saber si es un directorio o un archivo regular, lo cual nos dice el método <code>isDirectory</code>.</p>

<p><a class="p_ident" id="p-h0xB1EOSYW" href="#p-h0xB1EOSYW" tabindex="-1" role="presentation"></a>Usamos <code>readdir</code> para leer la matriz de archivos en un directorio y devolverla al cliente. Para archivos normales, creamos un flujo de lectura con <code>createReadStream</code> y lo devolvemos como cuerpo, junto con el tipo de contenido que nos proporciona el paquete <code>mime</code> para el nombre del archivo.</p>

<p><a class="p_ident" id="p-y4nquA3rgd" href="#p-y4nquA3rgd" tabindex="-1" role="presentation"></a>El código para manejar las solicitudes <code>DELETE</code> es ligeramente más sencillo.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-JlCZDm9eg3" href="#c-JlCZDm9eg3" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">rmdir</span>, <span class="tok-definition">unlink</span>} <span class="tok-keyword">from</span> <span class="tok-string">&quot;node:fs/promises&quot;</span>;

methods.DELETE = <span class="tok-keyword">async</span> <span class="tok-keyword">function</span>(<span class="tok-definition">request</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">path</span> = urlPath(request.url);
  <span class="tok-keyword">let</span> <span class="tok-definition">stats</span>;
  <span class="tok-keyword">try</span> {
    stats = <span class="tok-keyword">await</span> stat(path);
  } <span class="tok-keyword">catch</span> (<span class="tok-definition">error</span>) {
    <span class="tok-keyword">if</span> (error.code != <span class="tok-string">&quot;ENOENT&quot;</span>) <span class="tok-keyword">throw</span> error;
    <span class="tok-keyword">else</span> <span class="tok-keyword">return</span> {<span class="tok-definition">status</span>: <span class="tok-number">204</span>};
  }
  <span class="tok-keyword">if</span> (stats.isDirectory()) <span class="tok-keyword">await</span> rmdir(path);
  <span class="tok-keyword">else</span> <span class="tok-keyword">await</span> unlink(path);
  <span class="tok-keyword">return</span> {<span class="tok-definition">status</span>: <span class="tok-number">204</span>};
};</pre>

<p><a class="p_ident" id="p-H+7ybQUwOt" href="#p-H+7ybQUwOt" tabindex="-1" role="presentation"></a>Cuando una respuesta HTTP no contiene datos, se puede usar el código de estado 204 (“sin contenido”) para indicarlo. Dado que la respuesta a la eliminación no necesita transmitir ninguna información más allá de si la operación tuvo éxito, es sensato devolver eso aquí.</p>

<p><a class="p_ident" id="p-SU+s9xoEsL" href="#p-SU+s9xoEsL" tabindex="-1" role="presentation"></a>Es posible que te preguntes por qué intentar eliminar un archivo inexistente devuelve un código de estado de éxito en lugar de un error. Cuando el archivo que se está eliminando no está presente, se podría decir que el objetivo de la solicitud ya se ha cumplido. El estándar HTTP nos anima a hacer solicitudes <em>idempotentes</em>, lo que significa que hacer la misma solicitud varias veces produce el mismo resultado que hacerla una vez. De cierta manera, si intentas eliminar algo que ya no está, el efecto que intentabas lograr se ha alcanzado: la cosa ya no está allí.</p>

<p><a class="p_ident" id="p-ARSP8HNYDA" href="#p-ARSP8HNYDA" tabindex="-1" role="presentation"></a>Este es el manejador para las solicitudes <code>PUT</code>:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-V+n6chgMKs" href="#c-V+n6chgMKs" tabindex="-1" role="presentation"></a><span class="tok-keyword">import</span> {<span class="tok-definition">createWriteStream</span>} <span class="tok-keyword">from</span> <span class="tok-string">&quot;node:fs&quot;</span>;

<span class="tok-keyword">function</span> <span class="tok-definition">pipeStream</span>(<span class="tok-definition">from</span>, <span class="tok-definition">to</span>) {
  <span class="tok-keyword">return</span> <span class="tok-keyword">new</span> Promise((<span class="tok-definition">resolve</span>, <span class="tok-definition">reject</span>) =&gt; {
    from.on(<span class="tok-string">&quot;error&quot;</span>, reject);
    to.on(<span class="tok-string">&quot;error&quot;</span>, reject);
    to.on(<span class="tok-string">&quot;finish&quot;</span>, resolve);
    from.pipe(to);
  });
}<span class="tok-string2">``</span><span class="tok-string2">`methods.PUT = async function(request) {</span>
<span class="tok-string2">  let path = urlPath(request.url);</span>
<span class="tok-string2">  await pipeStream(request, createWriteStream(path));</span>
<span class="tok-string2">  return {status: 204};</span>
<span class="tok-string2">};</span></pre>

<p><a class="p_ident" id="p-rQWta+cFGd" href="#p-rQWta+cFGd" tabindex="-1" role="presentation"></a>Esta vez no necesitamos verificar si el archivo existe; si lo hace, simplemente lo sobrescribiremos. Nuevamente usamos <code>pipe</code> para mover datos de un flujo legible a uno escribible, en este caso del request al archivo. Pero como <code>pipe</code> no está diseñado para devolver una promesa, debemos escribir un contenedor, <code>pipeStream</code>, que cree una promesa alrededor del resultado de llamar a <code>pipe</code>.</p>

<p><a class="p_ident" id="p-JjAdEY1T6W" href="#p-JjAdEY1T6W" tabindex="-1" role="presentation"></a>Cuando algo sale mal al abrir el archivo, <code>createWriteStream</code> seguirá devolviendo un flujo, pero ese flujo lanzará un evento de <code>&quot;error&quot;</code>. El flujo del request también puede fallar, por ejemplo si la red falla. Por lo tanto, conectamos los eventos de <code>&quot;error&quot;</code> de ambos flujos para rechazar la promesa. Cuando <code>pipe</code> haya terminado, cerrará el flujo de salida, lo que hará que lance un evento de <code>&quot;finalización&quot;</code>. En ese momento podemos resolver la promesa con éxito (devolviendo nada).</p>

<p><a class="p_ident" id="p-8kKGPbzzF1" href="#p-8kKGPbzzF1" tabindex="-1" role="presentation"></a>El script completo del servidor está disponible en <a href="https://eloquentjavascript.net/code/file_server.mjs"><em>https://eloquentjavascript.net/code/file_server.mjs</em></a>. Puedes descargarlo y, después de instalar sus dependencias, ejecutarlo con Node para iniciar tu propio servidor de archivos. Y, por supuesto, puedes modificarlo y ampliarlo para resolver los ejercicios de este capítulo o para experimentar.</p>

<p><a class="p_ident" id="p-Efk/69Mmdw" href="#p-Efk/69Mmdw" tabindex="-1" role="presentation"></a>{{index “cuerpo (HTTP)”, “programa curl”, [HTTP, cliente], [método, HTTP]}}</p>

<p><a class="p_ident" id="p-hd8NXvgo0U" href="#p-hd8NXvgo0U" tabindex="-1" role="presentation"></a>La herramienta de línea de comandos <code>curl</code>, ampliamente disponible en sistemas Unix (como macOS y Linux), se puede utilizar para hacer solicitudes HTTP. La siguiente sesión prueba brevemente nuestro servidor. La opción <code>-X</code> se usa para establecer el método de la solicitud, y <code>-d</code> se utiliza para incluir un cuerpo de solicitud.</p>

<pre class="snippet" data-language="null" ><a class="c_ident" id="c-9YZyNAzvD4" href="#c-9YZyNAzvD4" tabindex="-1" role="presentation"></a>$ curl http://localhost:8000/file.txt
Archivo no encontrado
$ curl -X PUT -d CONTENIDO http://localhost:8000/file.txt
$ curl http://localhost:8000/file.txt
CONTENIDO
$ curl -X DELETE http://localhost:8000/file.txt
$ curl http://localhost:8000/file.txt
Archivo no encontrado</pre>

<p><a class="p_ident" id="p-SdSZhaJ21+" href="#p-SdSZhaJ21+" tabindex="-1" role="presentation"></a>La primera solicitud para <code>file.txt</code> falla ya que el archivo aún no existe. La solicitud <code>PUT</code> crea el archivo y, voilà, la siguiente solicitud lo recupera con éxito. Después de eliminarlo con una solicitud <code>DELETE</code>, el archivo vuelve a estar ausente.</p>

<h2><a class="h_ident" id="h-NUFOUyK+lw" href="#h-NUFOUyK+lw" tabindex="-1" role="presentation"></a>Resumen</h2>

<p><a class="p_ident" id="p-ZkCAhCPqn3" href="#p-ZkCAhCPqn3" tabindex="-1" role="presentation"></a>Node es un sistema pequeño interesante que nos permite ejecutar JavaScript en un contexto no de navegador. Originalmente fue diseñado para tareas de red para desempeñar el papel de un <em>nodo</em> en una red. Sin embargo, se presta para todo tipo de tareas de script, y si disfrutas escribir JavaScript, automatizar tareas con Node funciona bien.</p>

<p><a class="p_ident" id="p-mvU/5eNAQi" href="#p-mvU/5eNAQi" tabindex="-1" role="presentation"></a>NPM proporciona paquetes para todo lo que puedas imaginar (y varias cosas que probablemente nunca se te ocurrirían), y te permite descargar e instalar esos paquetes con el programa <code>npm</code>. Node viene con varios módulos integrados, incluido el módulo <code>node:fs</code> para trabajar con el sistema de archivos y el módulo <code>node:http</code> para ejecutar servidores HTTP.Todo el input y output en Node se hace de forma asíncrona, a menos que uses explícitamente una variante síncrona de una función, como <code>readFileSync</code>. Originalmente, Node usaba devoluciones de llamada para funcionalidades asíncronas, pero el paquete <code>node:fs/promises</code> proporciona una interfaz basada en promesas para el sistema de archivos.</p>

<h2><a class="h_ident" id="h-tkm7ntLto1" href="#h-tkm7ntLto1" tabindex="-1" role="presentation"></a>Ejercicios</h2>

<h3><a class="i_ident" id="i-F/Hf/Ag4yl" href="#i-F/Hf/Ag4yl" tabindex="-1" role="presentation"></a>Herramienta de búsqueda</h3>

<p><a class="p_ident" id="p-IXlWk51Q1o" href="#p-IXlWk51Q1o" tabindex="-1" role="presentation"></a>En los sistemas Unix, existe una herramienta de línea de comandos llamada <code>grep</code> que se puede utilizar para buscar rápidamente archivos según una expresión regular.</p>

<p><a class="p_ident" id="p-nw3FaVfQZY" href="#p-nw3FaVfQZY" tabindex="-1" role="presentation"></a>Escribe un script de Node que se pueda ejecutar desde la línea de comandos y funcione de manera similar a <code>grep</code>. Trata el primer argumento de la línea de comandos como una expresión regular y trata cualquier argumento adicional como archivos a buscar. Debería mostrar los nombres de los archivos cuyo contenido coincide con la expresión regular.</p>

<p><a class="p_ident" id="p-pdXy9ZIXbz" href="#p-pdXy9ZIXbz" tabindex="-1" role="presentation"></a>Una vez que eso funcione, extiéndelo para que cuando uno de los argumentos sea un directorio, busque en todos los archivos de ese directorio y sus subdirectorios.</p>

<p><a class="p_ident" id="p-qnRKogZMPC" href="#p-qnRKogZMPC" tabindex="-1" role="presentation"></a>Utiliza funciones asíncronas o síncronas del sistema de archivos según consideres adecuado. Configurar las cosas para que se soliciten múltiples acciones asíncronas al mismo tiempo podría acelerar un poco las cosas, pero no demasiado, ya que la mayoría de los sistemas de archivos solo pueden leer una cosa a la vez.</p>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-HJCQsGtLBH" href="#p-HJCQsGtLBH" tabindex="-1" role="presentation"></a>Tu primer argumento de línea de comandos, la expresión regular, se puede encontrar en <code>process.argv[2]</code>. Los archivos de entrada vienen después de eso. Puedes usar el constructor <code>RegExp</code> para convertir una cadena en un objeto de expresión regular.</p>

<p><a class="p_ident" id="p-xE/qoskUBZ" href="#p-xE/qoskUBZ" tabindex="-1" role="presentation"></a>Hacer esto de forma síncrona, con <code>readFileSync</code>, es más sencillo, pero si usas <code>node:fs/promises</code> para obtener funciones que devuelven promesas y escribes una función <code>async</code>, el código se ve similar.</p>

<p><a class="p_ident" id="p-xmMSoqqpPB" href="#p-xmMSoqqpPB" tabindex="-1" role="presentation"></a>Para averiguar si algo es un directorio, nuevamente puedes usar <code>stat</code> (o <code>statSync</code>) y el método <code>isDirectory</code> del objeto de estadísticas.</p>

<p><a class="p_ident" id="p-m2hsDndjdY" href="#p-m2hsDndjdY" tabindex="-1" role="presentation"></a>Explorar un directorio es un proceso ramificado. Puedes hacerlo usando una función recursiva o manteniendo un array de tareas pendientes (archivos que aún deben ser explorados). Para encontrar los archivos en un directorio, puedes llamar a <code>readdir</code> o <code>readdirSync</code>. Observa la extraña capitalización: el nombrado de funciones del sistema de archivos de Node se basa vagamente en las funciones estándar de Unix, como <code>readdir</code>, que son todas en minúsculas, pero luego agrega <code>Sync</code> con una letra mayúscula.</p>

<p><a class="p_ident" id="p-nak1lIuwWy" href="#p-nak1lIuwWy" tabindex="-1" role="presentation"></a>Para obtener el nombre completo de un archivo leído con <code>readdir</code>, debes combinarlo con el nombre del directorio, ya sea añadiendo <code>sep</code> de <code>node:path</code> entre ellos, o utilizando la función <code>join</code> de ese mismo paquete.</p>

</div></details>

<h3><a class="i_ident" id="i-o/SovGzlc3" href="#i-o/SovGzlc3" tabindex="-1" role="presentation"></a>Creación de directorios</h3>

<p><a class="p_ident" id="p-vRyiKlvYKl" href="#p-vRyiKlvYKl" tabindex="-1" role="presentation"></a>Aunque el método <code>DELETE</code> en nuestro servidor de archivos es capaz de eliminar directorios (usando <code>rmdir</code>), actualmente el servidor no proporciona ninguna forma de <em>crear</em> un directorio.{{index “MKCOL method”, “mkdir function”}}</p>

<p><a class="p_ident" id="p-t0vs3VLgD4" href="#p-t0vs3VLgD4" tabindex="-1" role="presentation"></a>Añade soporte para el método <code>MKCOL</code> (“make collection”), que debería crear un directorio llamando a <code>mkdir</code> desde el módulo <code>node:fs</code>. <code>MKCOL</code> no es un método HTTP ampliamente utilizado, pero sí existe con este mismo propósito en el estándar <em>WebDAV</em>, el cual especifica un conjunto de convenciones sobre HTTP que lo hacen adecuado para crear documentos.</p>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-AVf93pz/4b" href="#p-AVf93pz/4b" tabindex="-1" role="presentation"></a>Puedes usar la función que implementa el método <code>DELETE</code> como base para el método <code>MKCOL</code>. Cuando no se encuentra ningún archivo, intenta crear un directorio con <code>mkdir</code>. Cuando existe un directorio en esa ruta, puedes devolver una respuesta 204 para que las solicitudes de creación de directorios sean idempotentes. Si existe un archivo que no es un directorio en esta ruta, devuelve un código de error. El código 400 (“solicitud incorrecta”) sería apropiado.</p>

</div></details>

<h3><a class="i_ident" id="i-Txw3NflFh8" href="#i-Txw3NflFh8" tabindex="-1" role="presentation"></a>Un espacio público en la web</h3>

<p><a class="p_ident" id="p-cVdLVfzQ+z" href="#p-cVdLVfzQ+z" tabindex="-1" role="presentation"></a>Dado que el servidor de archivos sirve cualquier tipo de archivo e incluso incluye la cabecera <code>Content-Type</code> correcta, puedes usarlo para servir un sitio web. Dado que permite a todos eliminar y reemplazar archivos, sería un tipo interesante de sitio web: uno que puede ser modificado, mejorado y vandalizado por todos aquellos que se tomen el tiempo de hacer la solicitud HTTP adecuada.</p>

<p><a class="p_ident" id="p-w5d/xudUZ/" href="#p-w5d/xudUZ/" tabindex="-1" role="presentation"></a>Escribe una página HTML básica que incluya un archivo JavaScript sencillo. Coloca los archivos en un directorio servido por el servidor de archivos y ábrelos en tu navegador.</p>

<p><a class="p_ident" id="p-dGMy9Ug18P" href="#p-dGMy9Ug18P" tabindex="-1" role="presentation"></a>Luego, como ejercicio avanzado o incluso como un proyecto de fin de semana, combina todo el conocimiento que has adquirido de este libro para construir una interfaz más amigable para modificar el sitio web—desde <em>dentro</em> del sitio web.</p>

<p><a class="p_ident" id="p-/KhLuPZmip" href="#p-/KhLuPZmip" tabindex="-1" role="presentation"></a>Utiliza un formulario HTML para editar el contenido de los archivos que conforman el sitio web, permitiendo al usuario actualizarlos en el servidor mediante solicitudes HTTP, como se describe en <a href="18_http.html">Capítulo 18</a>.</p>

<p><a class="p_ident" id="p-Ogr7GZ3+wK" href="#p-Ogr7GZ3+wK" tabindex="-1" role="presentation"></a>Comienza permitiendo que solo un archivo sea editable. Luego haz que el usuario pueda seleccionar qué archivo editar. Aprovecha el hecho de que nuestro servidor de archivos devuelve listas de archivos al leer un directorio.</p>

<p><a class="p_ident" id="p-PII294GUqX" href="#p-PII294GUqX" tabindex="-1" role="presentation"></a>No trabajes directamente en el código expuesto por el servidor de archivos ya que si cometes un error, es probable que dañes los archivos allí. En su lugar, mantén tu trabajo fuera del directorio accesible al público y cópialo allí al hacer pruebas.</p>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-cMkx7R4x8e" href="#p-cMkx7R4x8e" tabindex="-1" role="presentation"></a>Puedes crear un elemento <code>&lt;textarea&gt;</code> para contener el contenido del archivo que se está editando. Una solicitud <code>GET</code>, utilizando <code>fetch</code>, puede recuperar el contenido actual del archivo. Puedes usar URLs relativas como <em>index.html</em>, en lugar de <a href="http://localhost:8000/index.html"><em>http://localhost:8000/index.html</em></a>, para hacer referencia a archivos en el mismo servidor que el script en ejecución.</p>

<p><a class="p_ident" id="p-ORpeth54Uz" href="#p-ORpeth54Uz" tabindex="-1" role="presentation"></a>Luego, cuando el usuario haga clic en un botón (puedes usar un elemento <code>&lt;form&gt;</code> y el evento <code>&quot;submit&quot;</code>), realiza una solicitud <code>PUT</code> a la misma URL, con el contenido del <code>&lt;textarea&gt;</code> como cuerpo de la solicitud, para guardar el archivo.</p>

<p><a class="p_ident" id="p-3BlItWwtjj" href="#p-3BlItWwtjj" tabindex="-1" role="presentation"></a>Puedes luego agregar un elemento <code>&lt;select&gt;</code> que contenga todos los archivos en el directorio principal del servidor mediante la adición de elementos <code>&lt;option&gt;</code> que contengan las líneas devueltas por una solicitud <code>GET</code> a la URL <code>/</code>. Cuando el usuario seleccione otro archivo (un evento <code>&quot;change&quot;</code> en el campo), el script debe recuperar y mostrar ese archivo. Al guardar un archivo, utiliza el nombre de archivo actualmente seleccionado.</p>

</div></details><nav><a href="19_paint.html" title="previous chapter" aria-label="previous chapter">◂</a> <a href="index.html" title="cover" aria-label="cover">●</a> <a href="21_skillsharing.html" title="next chapter" aria-label="next chapter">▸</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>
</nav>
</article>

<script src="ejs.js"></script>
