<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Dibujando en Canvas :: Eloquent JavaScript</title>
  <link rel=stylesheet href="css/ejs.css"><script>
      var page = {"type":"chapter","number":17,"load_files":["code/chapter/16_game.js","code/levels.js","code/stop_keys.js","code/chapter/17_canvas.js"]}</script></head>

<article>
<nav><a href="16_game.html" title="previous chapter" aria-label="previous chapter">◂</a> <a href="index.html" title="cover" aria-label="cover">●</a> <a href="18_http.html" title="next chapter" aria-label="next chapter">▸</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>
</nav>

<h1>Dibujando en Canvas</h1>

<blockquote>

<p><a class="p_ident" id="p-WK6Londj2s" href="#p-WK6Londj2s" tabindex="-1" role="presentation"></a>Dibujar es engañar.</p>

<footer>M.C. Escher, <cite>citado por Bruno Ernst en El Espejo Mágico de M.C. Escher</cite></footer>

</blockquote><figure class="chapter framed"><img src="img/chapter_picture_17.jpg" alt="Ilustración que muestra un brazo robótico con aspecto industrial dibujando una ciudad en un trozo de papel"></figure>

<p><a class="p_ident" id="p-WsH95+AeJX" href="#p-WsH95+AeJX" tabindex="-1" role="presentation"></a>Los navegadores nos ofrecen varias formas de mostrar gráficos. La forma más simple es usar estilos para posicionar y colorear elementos normales del DOM. Esto puede llevarnos bastante lejos, como mostró el juego del <a href="16_game.html">capítulo anterior</a>. Al agregar imágenes de fondo parcialmente transparentes a los nodos, podemos hacer que se vean exactamente como queremos. Incluso es posible rotar o sesgar nodos con el estilo <code>transform</code>.</p>

<p><a class="p_ident" id="p-0ElNKbsPjW" href="#p-0ElNKbsPjW" tabindex="-1" role="presentation"></a>Pero estaríamos utilizando el DOM para algo para lo que no fue diseñado originalmente. Algunas tareas, como dibujar una línea entre puntos arbitrarios, son extremadamente incómodas de hacer con elementos usuales de HTML.</p>

<p><a class="p_ident" id="p-8EN87JsadZ" href="#p-8EN87JsadZ" tabindex="-1" role="presentation"></a>Hay dos alternativas. La primera es basada en el DOM pero utiliza <em>Gráficos Vectoriales Escalables</em> (SVG, por sus siglas en inglés), en lugar de HTML. Piensa en SVG como un dialecto de marcado de documento que se centra en las formas en lugar de en el texto. Puedes incrustar un documento SVG directamente en un documento HTML o incluirlo con una etiqueta <code>&lt;img&gt;</code>.</p>

<p><a class="p_ident" id="p-5ipuOzKaXl" href="#p-5ipuOzKaXl" tabindex="-1" role="presentation"></a>La segunda alternativa se llama <em>lienzo</em> (o <em>canvas</em>). Un lienzo es un elemento del DOM que encapsula una imagen. Proporciona una interfaz de programación para dibujar formas en el espacio ocupado por el nodo. La principal diferencia entre un lienzo y una imagen SVG es que en SVG se conserva la descripción original de las formas para que puedan moverse o redimensionarse en cualquier momento. Un lienzo, por otro lado, convierte las formas en píxels (puntos de color en una cuadrícula) en cuanto se dibujan y no recuerda qué representan estos píxeles. La única forma de mover una forma en un lienzo es borrar el lienzo (o la parte del lienzo alrededor de la forma) y volver a dibujarlo con la forma en una nueva posición.</p>

<h2><a class="h_ident" id="h-UPzm0CiZhQ" href="#h-UPzm0CiZhQ" tabindex="-1" role="presentation"></a>SVG</h2>

<p><a class="p_ident" id="p-qX100BfTD/" href="#p-qX100BfTD/" tabindex="-1" role="presentation"></a>Este libro no ahondará en detalles sobre SVG, pero explicaré brevemente cómo funciona. Al <a href="17_canvas.html#tradeoffs_graficos">final del capítulo</a>, volveré a los compromisos que debes considerar al decidir qué mecanismo de dibujo es adecuado para una aplicación determinada.</p>

<p><a class="p_ident" id="p-GYntGFJZWA" href="#p-GYntGFJZWA" tabindex="-1" role="presentation"></a>Este es un documento HTML con una sencilla imagen SVG en él:</p>

<pre tabindex="0" class="snippet" data-language="html"  data-sandbox="svg"><a class="c_ident" id="c-8Fs/4abQ/e" href="#c-8Fs/4abQ/e" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">p</span>&gt;Aquí va HTML normal.&lt;/<span class="tok-typeName">p</span>&gt;
&lt;<span class="tok-typeName">svg</span> xmlns=<span class="tok-string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;
  &lt;<span class="tok-typeName">circle</span> r=<span class="tok-string">&quot;50&quot;</span> cx=<span class="tok-string">&quot;50&quot;</span> cy=<span class="tok-string">&quot;50&quot;</span> fill=<span class="tok-string">&quot;red&quot;</span>/&gt;
  &lt;<span class="tok-typeName">rect</span> x=<span class="tok-string">&quot;120&quot;</span> y=<span class="tok-string">&quot;5&quot;</span> width=<span class="tok-string">&quot;90&quot;</span> height=<span class="tok-string">&quot;90&quot;</span>
        stroke=<span class="tok-string">&quot;blue&quot;</span> fill=<span class="tok-string">&quot;none&quot;</span>/&gt;
&lt;/<span class="tok-typeName">svg</span>&gt;</pre>

<p><a class="p_ident" id="p-nP9GmCkWpk" href="#p-nP9GmCkWpk" tabindex="-1" role="presentation"></a>Estas etiquetas crean elementos del DOM, al igual que las etiquetas HTML, con las que los scripts pueden interactuar. Por ejemplo, esto cambia el elemento <code>&lt;circle&gt;</code> para que se coloree de cian:</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-sandbox="svg"><a class="c_ident" id="c-q+UenGnYa6" href="#c-q+UenGnYa6" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">círculo</span> = document.querySelector(<span class="tok-string">&quot;circle&quot;</span>);
círculo.setAttribute(<span class="tok-string">&quot;fill&quot;</span>, <span class="tok-string">&quot;cyan&quot;</span>);</pre>

<h2><a class="h_ident" id="h-IHgXAPlRoi" href="#h-IHgXAPlRoi" tabindex="-1" role="presentation"></a>El elemento canvas</h2>

<p><a class="p_ident" id="p-foVNVjLewD" href="#p-foVNVjLewD" tabindex="-1" role="presentation"></a>Los gráficos en lienzo pueden ser dibujados en un elemento <code>&lt;canvas&gt;</code>. Puedes darle a dicho elemento atributos <code>width</code> y <code>height</code> para determinar su tamaño en píxels.</p>

<p><a class="p_ident" id="p-aUuyVtTlLJ" href="#p-aUuyVtTlLJ" tabindex="-1" role="presentation"></a>Un lienzo nuevo está vacío, lo que significa que es completamente transparente y por lo tanto se muestra como espacio vacío en el documento.</p>

<p><a class="p_ident" id="p-zuEJbhu4U0" href="#p-zuEJbhu4U0" tabindex="-1" role="presentation"></a>La etiqueta <code>&lt;canvas&gt;</code> está destinada a permitir diferentes estilos de dibujo. Para acceder a una interfaz de dibujo real, primero necesitamos crear un <em>contexto</em>, un objeto cuyos métodos proporcionan la interfaz de dibujo. Actualmente existen tres estilos de dibujo ampliamente compatibles: <code>&quot;2d&quot;</code> para gráficos bidimensionales, <code>&quot;webgl&quot;</code> para gráficos tridimensionales a través de la interfaz OpenGL, y <code>&quot;webgpu&quot;</code>, una alternativa más moderna y flexible a WebGL.</p>

<p><a class="p_ident" id="p-s3Qi60Vb/g" href="#p-s3Qi60Vb/g" tabindex="-1" role="presentation"></a>Este libro no discutirá WebGL ni WebGPU —nos mantendremos en dos dimensiones. Pero si estás interesado en gráficos tridimensionales, te animo a investigar sobre WebGPU. Proporciona una interfaz directa al hardware gráfico y te permite incluso renderizar escenas complicadas de manera eficiente, utilizando JavaScript.</p>

<p><a class="p_ident" id="p-MEgOg5Mvt7" href="#p-MEgOg5Mvt7" tabindex="-1" role="presentation"></a>Creas un contexto con el método <code>getContext</code> en el elemento DOM <code>&lt;canvas&gt;</code>.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-hV/wD/kYGY" href="#c-hV/wD/kYGY" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">p</span>&gt;Antes del lienzo.&lt;/<span class="tok-typeName">p</span>&gt;
&lt;<span class="tok-typeName">canvas</span> width=<span class="tok-string">&quot;120&quot;</span> height=<span class="tok-string">&quot;60&quot;</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">p</span>&gt;Después del lienzo.&lt;/<span class="tok-typeName">p</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">lienzo</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">contexto</span> = lienzo.getContext(<span class="tok-string">&quot;2d&quot;</span>);
  contexto.fillStyle = <span class="tok-string">&quot;red&quot;</span>;
  contexto.fillRect(<span class="tok-number">10</span>, <span class="tok-number">10</span>, <span class="tok-number">100</span>, <span class="tok-number">50</span>);
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-Z8FbmAPx0e" href="#p-Z8FbmAPx0e" tabindex="-1" role="presentation"></a>Después de crear el objeto de contexto, el ejemplo dibuja un rectángulo rojo de 100 píxeles de ancho y 50 píxeles de alto, con su esquina superior izquierda en las coordenadas (10,10).</p>

<p><a class="p_ident" id="p-lvxXAWASbe" href="#p-lvxXAWASbe" tabindex="-1" role="presentation"></a>Al igual que en HTML (y SVG), el sistema de coordenadas que utiliza el lienzo sitúa el (0,0) en la esquina superior izquierda, y el eje y-positivo va hacia abajo desde allí. Por lo tanto, (10,10) está 10 píxeles abajo y a la derecha de la esquina superior izquierda.</p>

<h2 id="fill_stroke"><a class="h_ident" id="h-pjhQhwBlI5" href="#h-pjhQhwBlI5" tabindex="-1" role="presentation"></a>Líneas y superficies</h2>

<p><a class="p_ident" id="p-7qnMn5EIVa" href="#p-7qnMn5EIVa" tabindex="-1" role="presentation"></a>En la interfaz de lienzo, una forma puede ser <em>rellenada</em>, lo que significa que su área recibe un color o patrón determinado, o puede ser <em>trazada</em>, lo que significa que se dibuja una línea a lo largo de su borde. En SVG se utiliza la misma terminología.</p>

<p><a class="p_ident" id="p-0VT8ruNYTo" href="#p-0VT8ruNYTo" tabindex="-1" role="presentation"></a>El método <code>fillRect</code> rellena un rectángulo. Primero toma las coordenadas x e y de la esquina superior izquierda del rectángulo, luego su ancho y finalmente su altura. Un método similar, llamado <code>strokeRect</code> dibuja el contorno de un rectángulo.</p>

<p><a class="p_ident" id="p-RfsD8lcuyO" href="#p-RfsD8lcuyO" tabindex="-1" role="presentation"></a>Ninguno de los métodos toma más parámetros. El color del relleno, el grosor del trazo, y demás, no son determinados por un argumento del método, como podrías esperar razonablemente, sino por propiedades del objeto contexto.</p>

<p><a class="p_ident" id="p-3Koe6zpld5" href="#p-3Koe6zpld5" tabindex="-1" role="presentation"></a>La propiedad <code>fillStyle</code> controla la forma en que se rellenan las formas. Puede establecerse como una cadena que especifica un color, utilizando la notación de color utilizada por CSS.</p>

<p><a class="p_ident" id="p-SGPqnpLFJH" href="#p-SGPqnpLFJH" tabindex="-1" role="presentation"></a>La propiedad <code>strokeStyle</code> funciona de manera similar, pero determina el color utilizado para una línea de contorno. El ancho de esa línea se determina mediante la propiedad <code>lineWidth</code>, que puede contener cualquier número positivo.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-RXlmHDTr07" href="#c-RXlmHDTr07" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  cx.strokeStyle = <span class="tok-string">&quot;blue&quot;</span>;
  cx.strokeRect(<span class="tok-number">5</span>, <span class="tok-number">5</span>, <span class="tok-number">50</span>, <span class="tok-number">50</span>);
  cx.lineWidth = <span class="tok-number">5</span>;
  cx.strokeRect(<span class="tok-number">135</span>, <span class="tok-number">5</span>, <span class="tok-number">50</span>, <span class="tok-number">50</span>);
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-eP8J7bTZtY" href="#p-eP8J7bTZtY" tabindex="-1" role="presentation"></a>Cuando no se especifica ningún atributo <code>width</code> o <code>height</code>, como en el ejemplo, un elemento canvas obtiene un ancho predeterminado de 300 píxeles y una altura de 150 píxeles.</p>

<h2><a class="h_ident" id="h-Z7qInlh67F" href="#h-Z7qInlh67F" tabindex="-1" role="presentation"></a>Caminos</h2>

<p><a class="p_ident" id="p-5k991wc6m3" href="#p-5k991wc6m3" tabindex="-1" role="presentation"></a>Un camino es una secuencia de líneas. La interfaz del canvas 2D toma un enfoque peculiar para describir un camino. Se realiza completamente a través de efectos secundarios. Los caminos no son valores que se puedan almacenar y pasar. En vez de eso, si deseas hacer algo con un camino, haces una secuencia de llamadas a métodos para describir su forma.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-q5tyCN7mU3" href="#c-q5tyCN7mU3" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  cx.beginPath();
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">y</span> = <span class="tok-number">10</span>; y &lt; <span class="tok-number">100</span>; y += <span class="tok-number">10</span>) {
    cx.moveTo(<span class="tok-number">10</span>, y);
    cx.lineTo(<span class="tok-number">90</span>, y);
  }
  cx.stroke();
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-FIflUFp6Ac" href="#p-FIflUFp6Ac" tabindex="-1" role="presentation"></a>Este ejemplo crea un camino con varios segmentos horizontales de línea y luego lo traza usando el método <code>stroke</code>. Cada segmento creado con <code>lineTo</code> comienza en la posición <em>actual</em> del camino. Esa posición suele ser el final del último segmento, a menos que se haya llamado a <code>moveTo</code>. En ese caso, el siguiente segmento comenzaría en la posición pasada a <code>moveTo</code>.</p>

<p><a class="p_ident" id="p-iJK0Cor0G1" href="#p-iJK0Cor0G1" tabindex="-1" role="presentation"></a>Cuando se rellena un camino (usando el método <code>fill</code>), cada forma se llena por separado. Un camino puede contener múltiples formas —cada movimiento de <code>moveTo</code> inicia una nueva forma. Pero el camino necesita estar <em>cerrado</em> (significando que su inicio y final están en la misma posición) antes de poder ser rellenado. Si el camino aún no está cerrado, se agrega una línea desde su final hasta su inicio, y se rellena la forma encerrada por el camino completado.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-dKfK5v1gw2" href="#c-dKfK5v1gw2" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  cx.beginPath();
  cx.moveTo(<span class="tok-number">50</span>, <span class="tok-number">10</span>);
  cx.lineTo(<span class="tok-number">10</span>, <span class="tok-number">70</span>);
  cx.lineTo(<span class="tok-number">90</span>, <span class="tok-number">70</span>);
  cx.fill();
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-6RsBqrwic6" href="#p-6RsBqrwic6" tabindex="-1" role="presentation"></a>Este ejemplo dibuja un triángulo relleno. Ten en cuenta que solo se dibujan explícitamente dos de los lados del triángulo. El tercero, desde la esquina inferior derecha de regreso a la parte superior, se da por implícito y no estaría allí si trazaras el camino.</p>

<p><a class="p_ident" id="p-Tk2aVSsGnM" href="#p-Tk2aVSsGnM" tabindex="-1" role="presentation"></a>También puedes usar el método <code>closePath</code> para cerrar explícitamente un recorrido agregando un segmento real (<em>line</em>) de vuelta al inicio del recorrido. Este segmento <em>se dibuja</em> cuando se traza el recorrido.</p>

<h2><a class="h_ident" id="h-9hC2009SxC" href="#h-9hC2009SxC" tabindex="-1" role="presentation"></a>Curvas</h2>

<p><a class="p_ident" id="p-WSTFQiXLdY" href="#p-WSTFQiXLdY" tabindex="-1" role="presentation"></a>Un recorrido también puede contener líneas curvadas. Lamentablemente, estas son un poco más complicadas de dibujar.</p>

<p><a class="p_ident" id="p-3OHms/qYjY" href="#p-3OHms/qYjY" tabindex="-1" role="presentation"></a>El método <code>quadraticCurveTo</code> dibuja una curva hacia un punto dado. Para determinar la curvatura de la línea, el método recibe un punto de control así como un punto de destino. Imagina este punto de control como <em>atrayendo</em> la línea, dándole su curvatura. La línea no pasará por el punto de control, pero su dirección en los puntos de inicio y fin será tal que una línea recta en esa dirección apuntaría hacia el punto de control. El siguiente ejemplo ilustra esto:</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-SD49jQshd2" href="#c-SD49jQshd2" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  cx.beginPath();
  cx.moveTo(<span class="tok-number">10</span>, <span class="tok-number">90</span>);
  <span class="tok-comment">// control=(60,10) meta=(90,90)</span>
  cx.quadraticCurveTo(<span class="tok-number">60</span>, <span class="tok-number">10</span>, <span class="tok-number">90</span>, <span class="tok-number">90</span>);
  cx.lineTo(<span class="tok-number">60</span>, <span class="tok-number">10</span>);
  cx.closePath();
  cx.stroke();
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-0Do2D1mx/8" href="#p-0Do2D1mx/8" tabindex="-1" role="presentation"></a>Dibujamos una curva cuadrática de izquierda a derecha, con (60,10) como punto de control, y luego dibujamos dos segmentos line que pasan por ese punto de control y vuelven al inicio de la línea. El resultado se parece a un emblema de <em>Star Trek</em>. Puedes ver el efecto del punto de control: las líneas que salen de las esquinas inferiores comienzan en la dirección del punto de control y luego se curvan hacia su objetivo.</p>

<p><a class="p_ident" id="p-dtLc0HxcsU" href="#p-dtLc0HxcsU" tabindex="-1" role="presentation"></a>El método <code>bezierCurveTo</code> dibuja un tipo de curva parecida. En lugar de un único punto de control, este tiene dos —uno para cada uno de los extremos de la línea. Aquí hay un boceto similar para ilustrar el comportamiento de dicha curva:</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-0UOWPJLGDV" href="#c-0UOWPJLGDV" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  cx.beginPath();
  cx.moveTo(<span class="tok-number">10</span>, <span class="tok-number">90</span>);
  <span class="tok-comment">// control1=(10,10) control2=(90,10) meta=(50,90)</span>
  cx.bezierCurveTo(<span class="tok-number">10</span>, <span class="tok-number">10</span>, <span class="tok-number">90</span>, <span class="tok-number">10</span>, <span class="tok-number">50</span>, <span class="tok-number">90</span>);
  cx.lineTo(<span class="tok-number">90</span>, <span class="tok-number">10</span>);
  cx.lineTo(<span class="tok-number">10</span>, <span class="tok-number">10</span>);
  cx.closePath();
  cx.stroke();
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-nzyix6jR0u" href="#p-nzyix6jR0u" tabindex="-1" role="presentation"></a>Los dos puntos de control especifican la dirección en ambos extremos de la curva. Cuanto más separados estén de su punto correspondiente, más se “abultará&quot; la curva en esa dirección.</p>

<p><a class="p_ident" id="p-TJZ04KrhxG" href="#p-TJZ04KrhxG" tabindex="-1" role="presentation"></a>Curvas como estas pueden ser difíciles de trabajar, no siempre es claro cómo encontrar los puntos de control que proporcionan la forma que estás buscando. A veces puedes calcularlos y a veces simplemente tendrás que encontrar un valor adecuado mediante prueba y error.</p>

<p><a class="p_ident" id="p-1rScitaxyO" href="#p-1rScitaxyO" tabindex="-1" role="presentation"></a>El método <code>arc</code> es una forma de dibujar una línea que se curva a lo largo del borde de un círculo. Toma un par de coordenadas para el centro del arco, un radio, y luego un ángulo de inicio y un ángulo final.</p>

<p><a class="p_ident" id="p-NTElsgJi2Y" href="#p-NTElsgJi2Y" tabindex="-1" role="presentation"></a>Estos últimos dos parámetros permiten dibujar solo parte del círculo. Los ángulos se miden en radianes, no en grados. Esto significa que un círculo completo tiene un ángulo de 2π, o <code>2 * Math.PI</code>, que es aproximadamente 6.28. El ángulo comienza a contar en el punto a la derecha del centro del círculo y va en sentido horario desde allí. Puedes usar un inicio de 0 y un final mayor que 2π (por ejemplo, 7) para dibujar un círculo completo.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-D61ZW3HiS3" href="#c-D61ZW3HiS3" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  cx.beginPath();
  <span class="tok-comment">// centro=(50,50) radio=40 ángulo=0 a 7</span>
  cx.arc(<span class="tok-number">50</span>, <span class="tok-number">50</span>, <span class="tok-number">40</span>, <span class="tok-number">0</span>, <span class="tok-number">7</span>);
  <span class="tok-comment">// centro=(150,50) radio=40 ángulo=0 a ½π</span>
  cx.arc(<span class="tok-number">150</span>, <span class="tok-number">50</span>, <span class="tok-number">40</span>, <span class="tok-number">0</span>, <span class="tok-number">0.5</span> * Math.PI);
  cx.stroke();
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-jkO8t0wU0c" href="#p-jkO8t0wU0c" tabindex="-1" role="presentation"></a>La imagen resultante contiene una línea desde la derecha del círculo completo (primera llamada a <code>arc</code>) hasta la derecha del cuarto del círculo (segunda llamada). Al igual que otros métodos de dibujo de trayectos, una línea dibujada con <code>arc</code> está conectada al segmento de trayecto anterior. Puedes llamar a <code>moveTo</code> o comenzar un nuevo trayecto para evitar esto.</p>

<h2 id="diagrama_sectores"><a class="h_ident" id="h-wGotxOQ6Zk" href="#h-wGotxOQ6Zk" tabindex="-1" role="presentation"></a>Dibujo de un diagrama de sectores</h2>

<p><a class="p_ident" id="p-xlrQHhcAT1" href="#p-xlrQHhcAT1" tabindex="-1" role="presentation"></a>Imagina que acabas de aceptar un trabajo en EconomiCorp, Inc., y tu primera tarea es dibujar un diagrama de sectores de los resultados de la encuesta de satisfacción de los clientes.</p>

<p><a class="p_ident" id="p-dUxzE17XwV" href="#p-dUxzE17XwV" tabindex="-1" role="presentation"></a>El enlace <code>results</code> contiene una matriz de objetos que representan las respuestas de la encuesta.</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-sandbox="pie"><a class="c_ident" id="c-XBt5Q5QA9R" href="#c-XBt5Q5QA9R" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">resultados</span> = [
  {<span class="tok-definition">name</span>: <span class="tok-string">&quot;Satisfecho&quot;</span>, <span class="tok-definition">count</span>: <span class="tok-number">1043</span>, <span class="tok-definition">color</span>: <span class="tok-string">&quot;lightblue&quot;</span>},
  {<span class="tok-definition">name</span>: <span class="tok-string">&quot;Neutral&quot;</span>, <span class="tok-definition">count</span>: <span class="tok-number">563</span>, <span class="tok-definition">color</span>: <span class="tok-string">&quot;lightgreen&quot;</span>},
  {<span class="tok-definition">name</span>: <span class="tok-string">&quot;Insatisfecho&quot;</span>, <span class="tok-definition">count</span>: <span class="tok-number">510</span>, <span class="tok-definition">color</span>: <span class="tok-string">&quot;pink&quot;</span>},
  {<span class="tok-definition">name</span>: <span class="tok-string">&quot;Sin comentario&quot;</span>, <span class="tok-definition">count</span>: <span class="tok-number">175</span>, <span class="tok-definition">color</span>: <span class="tok-string">&quot;silver&quot;</span>}
];</pre>

<p><a class="p_ident" id="p-+20FYXG99L" href="#p-+20FYXG99L" tabindex="-1" role="presentation"></a>Para dibujar un diagrama de sectores, dibujamos una serie de sectores circulares, cada uno compuesto por un arco y un par de líneas hacia el centro de ese arco. Podemos calcular el ángulo ocupado por cada arco dividiendo un círculo completo (2π) por el número total de respuestas y luego multiplicando ese número (el ángulo por respuesta) por el número de personas que eligieron una opción determinada.</p>

<pre tabindex="0" class="snippet" data-language="html"  data-sandbox="pie"><a class="c_ident" id="c-Qzt0tiBO/6" href="#c-Qzt0tiBO/6" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span> width=<span class="tok-string">&quot;200&quot;</span> height=<span class="tok-string">&quot;200&quot;</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">total</span> = resultados
    .reduce((<span class="tok-definition">sum</span>, {count}) =&gt; sum + count, <span class="tok-number">0</span>);
  <span class="tok-comment">// Comenzar en la parte superior</span>
  <span class="tok-keyword">let</span> <span class="tok-definition">currentAngle</span> = -<span class="tok-number">0.5</span> * Math.PI;
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">resultado</span> <span class="tok-keyword">of</span> resultados) {
    <span class="tok-keyword">let</span> <span class="tok-definition">sliceAngle</span> = (resultado.count / total) * <span class="tok-number">2</span> * Math.PI;
    cx.beginPath();
    <span class="tok-comment">// centro=100,100, radio=100</span>
    <span class="tok-comment">// desde el ángulo actual, en sentido horario por el ángulo del sector</span>
    cx.arc(<span class="tok-number">100</span>, <span class="tok-number">100</span>, <span class="tok-number">100</span>,
           currentAngle, currentAngle + sliceAngle);
    currentAngle += sliceAngle;
    cx.lineTo(<span class="tok-number">100</span>, <span class="tok-number">100</span>);
    cx.fillStyle = resultado.color;
    cx.fill();
  }
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-YwIFCgKnJL" href="#p-YwIFCgKnJL" tabindex="-1" role="presentation"></a>Pero un gráfico que no nos dice qué significan las porciones no es muy útil. Necesitamos una forma de dibujar texto en el canvas.</p>

<h2><a class="h_ident" id="h-buumVsDzyv" href="#h-buumVsDzyv" tabindex="-1" role="presentation"></a>Texto</h2>

<p><a class="p_ident" id="p-jqhT5gaaJR" href="#p-jqhT5gaaJR" tabindex="-1" role="presentation"></a>Un contexto de dibujo en lienzo 2D proporciona los métodos <code>fillText</code> y <code>strokeText</code>. Este último puede ser útil para contornear letras, pero generalmente <code>fillText</code> es lo que necesitas. Este llenará el contorno del texto dado con el <code>fillStyle</code> actual.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-KDOHFsdpiF" href="#c-KDOHFsdpiF" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span> width=<span class="tok-string">&quot;420&quot;</span> height=<span class="tok-string">&quot;60&quot;</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  cx.font = <span class="tok-string">&quot;28px Georgia&quot;</span>;
  cx.fillStyle = <span class="tok-string">&quot;fuchsia&quot;</span>;
  cx.fillText(<span class="tok-string">&quot;¡También puedo dibujar texto!&quot;</span>, <span class="tok-number">10</span>, <span class="tok-number">50</span>);
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-Y8lIKRMGXQ" href="#p-Y8lIKRMGXQ" tabindex="-1" role="presentation"></a>Puedes especificar el tamaño, estilo y fuente del texto con la propiedad <code>font</code>. En este ejemplo solo se da un tamaño de fuente y un nombre de familia. También es posible agregar <code>italic</code> o <code>bold</code> al comienzo de la cadena para seleccionar un estilo.</p>

<p><a class="p_ident" id="p-rhCNRQsUbN" href="#p-rhCNRQsUbN" tabindex="-1" role="presentation"></a>Los dos últimos argumentos de <code>fillText</code> y <code>strokeText</code> proporcionan la posición en la que se dibuja la fuente. Por defecto, indican la posición del inicio de la línea base alfabética del texto, que es la línea sobre la que las letras se “apoyan”, sin contar las partes colgantes en letras como la <em>j</em> o la <em>p</em>. Puedes cambiar la posición horizontal configurando la propiedad <code>textAlign</code> en <code>&quot;end&quot;</code> o <code>&quot;center&quot;</code> y la posición vertical configurando <code>textBaseline</code> en <code>&quot;top&quot;</code>, <code>&quot;middle&quot;</code> o <code>&quot;bottom&quot;</code>.</p>

<p><a class="p_ident" id="p-2Nlk49Yj28" href="#p-2Nlk49Yj28" tabindex="-1" role="presentation"></a>Volveremos a nuestro gráfico circular y al problema de etiquetar las porciones, en los <a href="17_canvas.html#exercise_pie_chart">ejercicios</a> al final del capítulo.</p>

<h2><a class="h_ident" id="h-By2JQsVi0D" href="#h-By2JQsVi0D" tabindex="-1" role="presentation"></a>Imágenes</h2>

<p><a class="p_ident" id="p-fUHn+F0MIN" href="#p-fUHn+F0MIN" tabindex="-1" role="presentation"></a>En gráficos por computadora, a menudo se hace una distinción entre gráficos <em>vectoriales</em> y gráficos <em>de mapa de bits</em>. El primero es lo que hemos estado haciendo hasta ahora en este capítulo: especificar una imagen dando una descripción lógica de las formas. Los gráficos de mapa de bits, por otro lado, no especifican formas reales, sino que trabajan con datos de píxel (matrices de puntos de colores).</p>

<p><a class="p_ident" id="p-8mi7vOkN1m" href="#p-8mi7vOkN1m" tabindex="-1" role="presentation"></a>El método <code>drawImage</code> nos permite dibujar datos de píxel en un canvas. Estos datos de píxel pueden originarse desde un elemento <code>&lt;img&gt;</code> o desde otro lienzo. El siguiente ejemplo crea un elemento <code>&lt;img&gt;</code> independiente y carga un archivo de imagen en él. Pero no podemos comenzar a dibujar inmediatamente desde esta imagen porque es posible que el navegador aún no la haya cargado. Para manejar esto, registramos un controlador de eventos <code>&quot;load&quot;</code> y hacemos el dibujo después de que la imagen se haya cargado.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-Uzn6msw1dJ" href="#c-Uzn6msw1dJ" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">img</span> = document.createElement(<span class="tok-string">&quot;img&quot;</span>);
  img.src = <span class="tok-string">&quot;img/hat.png&quot;</span>;
  img.addEventListener(<span class="tok-string">&quot;load&quot;</span>, () =&gt; {
    <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">x</span> = <span class="tok-number">10</span>; x &lt; <span class="tok-number">200</span>; x += <span class="tok-number">30</span>) {
      cx.drawImage(img, x, <span class="tok-number">10</span>);
    }
  });
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-l9RhGaCiSU" href="#p-l9RhGaCiSU" tabindex="-1" role="presentation"></a>Por defecto, <code>drawImage</code> dibujará la imagen a su tamaño original. También se le pueden proporcionar dos argumentos adicionales para establecer un ancho y alto diferentes.</p>

<p><a class="p_ident" id="p-PhR2+0pqld" href="#p-PhR2+0pqld" tabindex="-1" role="presentation"></a>Cuando se utilizan <em>nueve</em> argumentos en <code>drawImage</code>, se puede usar para dibujar solo un fragmento de una imagen. Los argumentos segundo a quinto indican el rectángulo (x, y, ancho y alto) en la imagen de origen que se debería copiar, y los argumentos sexto a noveno indican el rectángulo (en el lienzo) en el cual se debería copiar.</p>

<p><a class="p_ident" id="p-OGnn92PfqV" href="#p-OGnn92PfqV" tabindex="-1" role="presentation"></a>Esto se puede utilizar para empaquetar varios <em>sprites</em> (elementos de imagen) en un único archivo de imagen y luego dibujar solo la parte que se necesita. Por ejemplo, tenemos esta imagen que contiene un personaje de juego en múltiples poses:</p><figure><img src="img/player_big.png" alt="Píxel art mostrando un personaje de videojuego en 10 poses diferentes. Las primeras 8 forman su ciclo de animación de carrera, la novena tiene al personaje parado, y la décima lo muestra saltando."></figure>

<p><a class="p_ident" id="p-irGio/b5/R" href="#p-irGio/b5/R" tabindex="-1" role="presentation"></a>Alternando qué pose dibujamos, podemos mostrar una animación que parece un personaje caminando.</p>

<p><a class="p_ident" id="p-v9SUKElKNf" href="#p-v9SUKElKNf" tabindex="-1" role="presentation"></a>Para animar una imagen en un lienzo, el método <code>clearRect</code> es útil. Se asemeja a <code>fillRect</code>, pero en lugar de colorear el rectángulo, lo vuelve transparente, eliminando los píxeles dibujados anteriormente.</p>

<p><a class="p_ident" id="p-GE3ONxp2hC" href="#p-GE3ONxp2hC" tabindex="-1" role="presentation"></a>Sabemos que cada <em>sprite</em>, cada subimagen, tiene un ancho de 24 píxeles y una altura de 30 píxeles. El siguiente código carga la imagen y luego establece un intervalo (temporizador repetido) para dibujar el siguiente frame:</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-RGrGdcKCNi" href="#c-RGrGdcKCNi" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">img</span> = document.createElement(<span class="tok-string">&quot;img&quot;</span>);
  img.src = <span class="tok-string">&quot;img/player.png&quot;</span>;
  <span class="tok-keyword">let</span> <span class="tok-definition">spriteW</span> = <span class="tok-number">24</span>, <span class="tok-definition">spriteH</span> = <span class="tok-number">30</span>;
  img.addEventListener(<span class="tok-string">&quot;load&quot;</span>, () =&gt; {
    <span class="tok-keyword">let</span> <span class="tok-definition">ciclo</span> = <span class="tok-number">0</span>;
    setInterval(() =&gt; {
      cx.clearRect(<span class="tok-number">0</span>, <span class="tok-number">0</span>, spriteW, spriteH);
      cx.drawImage(img,
                   <span class="tok-comment">// rectángulo de origen</span>
                   ciclo * spriteW, <span class="tok-number">0</span>, spriteW, spriteH,
                   <span class="tok-comment">// rectángulo de destino</span>
                   <span class="tok-number">0</span>,               <span class="tok-number">0</span>, spriteW, spriteH);
      ciclo = (ciclo + <span class="tok-number">1</span>) % <span class="tok-number">8</span>;
    }, <span class="tok-number">120</span>);
  });
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-JnRunDuR7n" href="#p-JnRunDuR7n" tabindex="-1" role="presentation"></a>La variable <code>ciclo</code> sigue nuestra posición en la animación. En cada frame, se incrementa y luego se recorta de nuevo al rango de 0 a 7 usando el operador de resto. Esta variable se utiliza luego para calcular la coordenada x que tiene el sprite para la pose actual en la imagen.</p>

<h2><a class="h_ident" id="h-rW64MvxCiy" href="#h-rW64MvxCiy" tabindex="-1" role="presentation"></a>Transformación</h2>

<p><a class="p_ident" id="p-IDnpmjkIIi" href="#p-IDnpmjkIIi" tabindex="-1" role="presentation"></a>Pero, ¿qué pasa si queremos que nuestro personaje camine hacia la izquierda en lugar de hacia la derecha? Podríamos dibujar otro conjunto de sprites, por supuesto. Pero también podemos decirle al lienzo que dibuje la imagen en sentido contrario.</p>

<p><a class="p_ident" id="p-k/kT+1q0Jm" href="#p-k/kT+1q0Jm" tabindex="-1" role="presentation"></a>Llamar al método <code>scale</code> hará que todo lo que se dibuje después de él se escale. Este método toma dos parámetros, uno para establecer una escala horizontal y otro para establecer una escala vertical.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-Ih3Ewav/dQ" href="#c-Ih3Ewav/dQ" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  cx.scale(<span class="tok-number">3</span>, <span class="tok-number">.5</span>);
  cx.beginPath();
  cx.arc(<span class="tok-number">50</span>, <span class="tok-number">50</span>, <span class="tok-number">40</span>, <span class="tok-number">0</span>, <span class="tok-number">7</span>);
  cx.lineWidth = <span class="tok-number">3</span>;
  cx.stroke();
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-giUMO7YZVM" href="#p-giUMO7YZVM" tabindex="-1" role="presentation"></a>Escalar hará que todo en la imagen dibujada, incluyendo el grosor de línea, se estire o se comprima como se especifique. Escalar por una cantidad negativa volteará la imagen. Esta transformación ocurre alrededor del punto (0,0), lo que significa que también volteará la dirección del sistema de coordenadas. Cuando se aplica una escala horizontal de -1, una forma dibujada en la posición x 100 terminará en lo que solía ser la posición -100.</p>

<p><a class="p_ident" id="p-aFXzkU34ds" href="#p-aFXzkU34ds" tabindex="-1" role="presentation"></a>Así que para voltear una imagen, no podemos simplemente agregar <code>cx.scale(-1, 1)</code> antes de la llamada a <code>drawImage</code> porque eso movería nuestra imagen fuera del lienzo, donde no sería visible. Podrías ajustar las coordenadas dadas a <code>drawImage</code> para compensar esto dibujando la imagen en la posición x -50 en lugar de 0. Otra solución, que no requiere que el código que hace el dibujo sepa sobre el cambio de escala, es ajustar el eje alrededor del cual ocurre el escalado.</p>

<p><a class="p_ident" id="p-NsPf5RT0UM" href="#p-NsPf5RT0UM" tabindex="-1" role="presentation"></a>Hay varios otros métodos además de <code>scale</code> que influyen en el sistema de coordenadas de un lienzo. Puedes rotar formas dibujadas posteriormente con el método <code>rotate</code> y moverlas con el método <code>translate</code>. Lo interesante —y confuso— es que estas transformaciones <em>se apilan</em>, lo que significa que cada una ocurre relativa a las transformaciones anteriores.</p>

<p><a class="p_ident" id="p-6E8AncvQtV" href="#p-6E8AncvQtV" tabindex="-1" role="presentation"></a>Entonces, si trasladamos por 10 píxeles horizontales dos veces, todo se dibujará 20 píxeles a la derecha. Si primero movemos el centro del sistema de coordenadas a (50,50) y luego rotamos por 20 grados (aproximadamente 0.1π radianes), esa rotación ocurrirá <em>alrededor</em> del punto (50,50).</p><figure><img src="img/transform.svg" alt="Diagrama que muestra el resultado de apilar transformaciones. El primer diagrama traslada y luego rota, causando que la traslación ocurra normalmente y la rotación alrededor del objetivo de la traslación. El segundo diagrama primero rota y luego traslada, causando que la rotación ocurra alrededor del origen y la dirección de traslación se incline por esa rotación."></figure>

<p><a class="p_ident" id="p-mKDS7oclkz" href="#p-mKDS7oclkz" tabindex="-1" role="presentation"></a>Pero si <em>primero</em> rotamos 20 grados y <em>luego</em> trasladamos por (50,50), la traslación ocurrirá en el sistema de coordenadas rotado y producirá una orientación diferente. El orden en el que se aplican las transformaciones es importante.</p>

<p><a class="p_ident" id="p-MKg3FxKQhR" href="#p-MKg3FxKQhR" tabindex="-1" role="presentation"></a>Para voltear una imagen alrededor de la línea vertical en una posición x dada, podemos hacer lo siguiente:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-LCPTAUKa8v" href="#c-LCPTAUKa8v" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">flipHorizontally</span>(<span class="tok-definition">contexto</span>, <span class="tok-definition">alrededorDe</span>) {
  contexto.translate(alrededorDe, <span class="tok-number">0</span>);
  contexto.scale(-<span class="tok-number">1</span>, <span class="tok-number">1</span>);
  contexto.translate(-alrededorDe, <span class="tok-number">0</span>);
}</pre>

<p><a class="p_ident" id="p-vp1fsWT2Uu" href="#p-vp1fsWT2Uu" tabindex="-1" role="presentation"></a>Movemos el eje y a donde queremos que esté nuestro espejo, aplicamos el efecto de espejo y finalmente devolvemos el eje y a su lugar adecuado en el universo espejado. La siguiente imagen explica por qué esto funciona:</p><figure><img src="img/mirror.svg" alt="Diagrama que muestra el efecto de trasladar y espejar un triángulo"></figure>

<p><a class="p_ident" id="p-iQ7XKEQztk" href="#p-iQ7XKEQztk" tabindex="-1" role="presentation"></a>Esto muestra los sistemas de coordenadas antes y después del espejo a través de la línea central. Los triángulos están numerados para ilustrar cada paso. Si dibujamos un triángulo en una posición x positiva, por defecto estaría en el lugar donde se encuentra el triángulo 1. Una llamada a <code>flipHorizontally</code> primero realiza una traslación a la derecha, lo que nos lleva al triángulo 2. Luego escala, volteando el triángulo a la posición 3. Aquí no es donde debería estar, si estuviera reflejado en la línea dada. La segunda llamada a <code>translate</code> corrige esto, “cancela” la traslación inicial y hace que el triángulo 4 aparezca exactamente donde debería.</p>

<p><a class="p_ident" id="p-IewluZ2i85" href="#p-IewluZ2i85" tabindex="-1" role="presentation"></a>Ahora podemos dibujar un personaje reflejado en la posición (100,0) volteando el mundo alrededor del centro vertical del personaje.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-dmV/R5ifO7" href="#c-dmV/R5ifO7" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">img</span> = document.createElement(<span class="tok-string">&quot;img&quot;</span>);
  img.src = <span class="tok-string">&quot;img/player.png&quot;</span>;
  <span class="tok-keyword">let</span> <span class="tok-definition">spriteW</span> = <span class="tok-number">24</span>, <span class="tok-definition">spriteH</span> = <span class="tok-number">30</span>;
  img.addEventListener(<span class="tok-string">&quot;load&quot;</span>, () =&gt; {
    flipHorizontally(cx, <span class="tok-number">100</span> + spriteW / <span class="tok-number">2</span>);
    cx.drawImage(img, <span class="tok-number">0</span>, <span class="tok-number">0</span>, spriteW, spriteH,
                 <span class="tok-number">100</span>, <span class="tok-number">0</span>, spriteW, spriteH);
  });
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<h2><a class="h_ident" id="h-IJTm33ZSO1" href="#h-IJTm33ZSO1" tabindex="-1" role="presentation"></a>Almacenando y eliminando transformaciones</h2>

<p><a class="p_ident" id="p-rJlfTniPkL" href="#p-rJlfTniPkL" tabindex="-1" role="presentation"></a>Las transformaciones permanecen. Todo lo que dibujemos después de ese personaje espejado también estará reflejado. Eso podría ser inconveniente.</p>

<p><a class="p_ident" id="p-SalCElR8sc" href="#p-SalCElR8sc" tabindex="-1" role="presentation"></a>Es posible guardar la transformación actual, hacer algunos dibujos y transformaciones, y luego restaurar la antigua transformación. Esto suele ser lo apropiado para una función que necesita transformar temporalmente el sistema de coordenadas. Primero, guardamos cualquier transformación que estuviera utilizando el código que llamó a la función. Luego, la función realiza su tarea, agregando más transformaciones sobre la transformación actual. Finalmente, volvemos a la transformación con la que comenzamos.</p>

<p><a class="p_ident" id="p-weTFB7xTVK" href="#p-weTFB7xTVK" tabindex="-1" role="presentation"></a>Los métodos <code>save</code> y <code>restore</code> en el contexto 2D del lienzo hacen este manejo de transformaciones. Conceptualmente mantienen una pila de estados de transformación. Cuando llamas a <code>save</code>, el estado actual se apila, y cuando llamas a <code>restore</code>, se elimina el estado de la cima de la pila y se usa como la transformación actual del contexto. También puedes llamar a <code>resetTransform</code> para restablecer completamente la transformación.</p>

<p><a class="p_ident" id="p-EVb85HFdgx" href="#p-EVb85HFdgx" tabindex="-1" role="presentation"></a>La función <code>branch</code> en el siguiente ejemplo ilustra lo que puedes hacer con una función que cambia la transformación y luego llama a una función (en este caso a sí misma), que continúa dibujando con la transformación dada.</p>

<p><a class="p_ident" id="p-vI78HzPMTt" href="#p-vI78HzPMTt" tabindex="-1" role="presentation"></a>Esta función dibuja una forma parecida a un árbol dibujando una línea, moviendo el centro del sistema de coordenadas al final de la línea, y llamándose a sí misma dos veces, primero rotada a la izquierda y luego rotada a la derecha. Cada llamada reduce la longitud de la rama dibujada, y la recursividad se detiene cuando la longitud desciende por debajo de 8.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-TvoVOvq541" href="#c-TvoVOvq541" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span> width=<span class="tok-string">&quot;600&quot;</span> height=<span class="tok-string">&quot;300&quot;</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  <span class="tok-keyword">function</span> <span class="tok-definition">branch</span>(<span class="tok-definition">length</span>, <span class="tok-definition">angle</span>, <span class="tok-definition">scale</span>) {
    cx.fillRect(<span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span>, length);
    <span class="tok-keyword">if</span> (length &lt; <span class="tok-number">8</span>) <span class="tok-keyword">return</span>;
    cx.save();
    cx.translate(<span class="tok-number">0</span>, length);
    cx.rotate(-angle);
    branch(length * scale, angle, scale);
    cx.rotate(<span class="tok-number">2</span> * angle);
    branch(length * scale, angle, scale);
    cx.restore();
  }
  cx.translate(<span class="tok-number">300</span>, <span class="tok-number">0</span>);
  branch(<span class="tok-number">60</span>, <span class="tok-number">0.5</span>, <span class="tok-number">0.8</span>);
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-brpP2b1pSn" href="#p-brpP2b1pSn" tabindex="-1" role="presentation"></a>Si las llamadas a <code>save</code> y <code>restore</code> no estuvieran allí, la segunda llamada recursiva a <code>branch</code> terminaría con la posición y rotación creadas por la primera llamada. No estaría conectada a la rama actual sino más bien a la rama más interna y a la derecha dibujada por la primera llamada. La forma resultante podría ser interesante, pero, desde luego, no sería un árbol.</p>

<h2 id="canvasdisplay"><a class="h_ident" id="h-5rj4QZAZI1" href="#h-5rj4QZAZI1" tabindex="-1" role="presentation"></a>De vuelta al juego</h2>

<p><a class="p_ident" id="p-Uhavxryl5K" href="#p-Uhavxryl5K" tabindex="-1" role="presentation"></a>Ahora sabemos lo suficiente sobre el dibujo en el canvas para empezar a trabajar en un sistema de display basado en canvas para el juego del <a href="16_game.html">capítulo anterior</a>. El nuevo display ya no mostrará solo cajas de colores. En su lugar, usaremos <code>drawImage</code> para dibujar imágenes que representen los elementos del juego.</p>

<p><a class="p_ident" id="p-c0RKUCIK0E" href="#p-c0RKUCIK0E" tabindex="-1" role="presentation"></a>Definimos otro tipo de objeto de display llamado <code>CanvasDisplay</code>, que soporta la misma interfaz que <code>DOMDisplay</code> del <a href="16_game.html#domdisplay">Capítulo 16</a>, es decir, los métodos <code>syncState</code> y <code>clear</code>.</p>

<p><a class="p_ident" id="p-QpuEer5cNQ" href="#p-QpuEer5cNQ" tabindex="-1" role="presentation"></a>Este objeto mantiene un poco más de información que <code>DOMDisplay</code>. En lugar de utilizar la posición de desplazamiento de su elemento del DOM, realiza un seguimiento de su propio viewport, que nos indica qué parte del nivel estamos viendo actualmente. Por último, mantiene una propiedad <code>flipPlayer</code> para que incluso cuando el jugador esté quieto, siga mirando en la dirección en la que se movió por última vez.</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-sandbox="game"><a class="c_ident" id="c-0YCIeiiRNE" href="#c-0YCIeiiRNE" tabindex="-1" role="presentation"></a><span class="tok-keyword">class</span> CanvasDisplay {
  <span class="tok-definition">constructor</span>(<span class="tok-definition">parent</span>, <span class="tok-definition">level</span>) {
    <span class="tok-keyword">this</span>.canvas = document.createElement(<span class="tok-string">&quot;canvas&quot;</span>);
    <span class="tok-keyword">this</span>.canvas.width = Math.min(<span class="tok-number">600</span>, level.width * scale);
    <span class="tok-keyword">this</span>.canvas.height = Math.min(<span class="tok-number">450</span>, level.height * scale);
    parent.appendChild(<span class="tok-keyword">this</span>.canvas);
    <span class="tok-keyword">this</span>.cx = <span class="tok-keyword">this</span>.canvas.getContext(<span class="tok-string">&quot;2d&quot;</span>);

    <span class="tok-keyword">this</span>.flipPlayer = false;

    <span class="tok-keyword">this</span>.viewport = {
      <span class="tok-definition">left</span>: <span class="tok-number">0</span>,
      <span class="tok-definition">top</span>: <span class="tok-number">0</span>,
      <span class="tok-definition">width</span>: <span class="tok-keyword">this</span>.canvas.width / scale,
      <span class="tok-definition">height</span>: <span class="tok-keyword">this</span>.canvas.height / scale
    };
  }

  <span class="tok-definition">clear</span>() {
    <span class="tok-keyword">this</span>.canvas.remove();
  }
}</pre>

<p><a class="p_ident" id="p-JVl9qvzgu9" href="#p-JVl9qvzgu9" tabindex="-1" role="presentation"></a>El método <code>syncState</code> primero calcula un nuevo viewport y luego dibuja la escena del juego en la posición adecuada.</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-sandbox="game"><a class="c_ident" id="c-cERhn3J5yx" href="#c-cERhn3J5yx" tabindex="-1" role="presentation"></a>CanvasDisplay.prototype.syncState = <span class="tok-keyword">function</span>(<span class="tok-definition">state</span>) {
  <span class="tok-keyword">this</span>.updateViewport(state);
  <span class="tok-keyword">this</span>.clearDisplay(state.status);
  <span class="tok-keyword">this</span>.drawBackground(state.level);
  <span class="tok-keyword">this</span>.drawActors(state.actors);
};</pre>

<p><a class="p_ident" id="p-j+OyZJxzOM" href="#p-j+OyZJxzOM" tabindex="-1" role="presentation"></a>A diferencia de <code>DOMDisplay</code>, este estilo de visualización <strong>sí</strong> tiene que redibujar el fondo en cada actualización. Debido a que las formas en un lienzo son solo píxeles, una vez que las dibujamos no hay una buena manera de moverlas (o eliminarlas). La única forma de actualizar la visualización en lienzo es borrarla y volver a dibujar la escena. También puede ser que hayamos hecho scroll, lo que requeriría que el fondo esté en una posición diferente.</p>

<p><a class="p_ident" id="p-LmcyJEPAXY" href="#p-LmcyJEPAXY" tabindex="-1" role="presentation"></a>El método <code>updateViewport</code> es similar al método <code>scrollPlayerIntoView</code> de <code>DOMDisplay</code>. Verifica si el jugador está demasiado cerca del borde de la pantalla y mueve el <strong>viewport</strong> en ese caso.</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-sandbox="game"><a class="c_ident" id="c-OjMIL2K7Ii" href="#c-OjMIL2K7Ii" tabindex="-1" role="presentation"></a>CanvasDisplay.prototype.updateViewport = <span class="tok-keyword">function</span>(<span class="tok-definition">state</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">view</span> = <span class="tok-keyword">this</span>.viewport, <span class="tok-definition">margin</span> = view.width / <span class="tok-number">3</span>;
  <span class="tok-keyword">let</span> <span class="tok-definition">player</span> = state.player;
  <span class="tok-keyword">let</span> <span class="tok-definition">center</span> = player.pos.plus(player.size.times(<span class="tok-number">0.5</span>));

  <span class="tok-keyword">if</span> (center.x &lt; view.left + margin) {
    view.left = Math.max(center.x - margin, <span class="tok-number">0</span>);
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (center.x &gt; view.left + view.width - margin) {
    view.left = Math.min(center.x + margin - view.width,
                         state.level.width - view.width);
  }
  <span class="tok-keyword">if</span> (center.y &lt; view.top + margin) {
    view.top = Math.max(center.y - margin, <span class="tok-number">0</span>);
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (center.y &gt; view.top + view.height - margin) {
    view.top = Math.min(center.y + margin - view.height,
                        state.level.height - view.height);
  }
};</pre>

<p><a class="p_ident" id="p-LTvt7zghYT" href="#p-LTvt7zghYT" tabindex="-1" role="presentation"></a>Las llamadas a <code>Math.max</code> y <code>Math.min</code> aseguran que el <strong>viewport</strong> no termine mostrando espacio fuera del nivel. <code>Math.max(x, 0)</code> se asegura de que el número resultante no sea menor que cero. <code>Math.min</code> garantiza de manera similar que un valor se mantenga por debajo de un límite dado.</p>

<p><a class="p_ident" id="p-ciYesmCNwa" href="#p-ciYesmCNwa" tabindex="-1" role="presentation"></a>Al <strong>limpiar</strong> la visualización, usaremos un color ligeramente diferente según si el juego termina con éxito (más brillante) o no (más oscuro).</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-sandbox="game"><a class="c_ident" id="c-P43rIXnt0B" href="#c-P43rIXnt0B" tabindex="-1" role="presentation"></a>CanvasDisplay.prototype.clearDisplay = <span class="tok-keyword">function</span>(<span class="tok-definition">status</span>) {
  <span class="tok-keyword">if</span> (status == <span class="tok-string">&quot;won&quot;</span>) {
    <span class="tok-keyword">this</span>.cx.fillStyle = <span class="tok-string">&quot;rgb(68, 191, 255)&quot;</span>;
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (status == <span class="tok-string">&quot;lost&quot;</span>) {
    <span class="tok-keyword">this</span>.cx.fillStyle = <span class="tok-string">&quot;rgb(44, 136, 214)&quot;</span>;
  } <span class="tok-keyword">else</span> {
    <span class="tok-keyword">this</span>.cx.fillStyle = <span class="tok-string">&quot;rgb(52, 166, 251)&quot;</span>;
  }
  <span class="tok-keyword">this</span>.cx.fillRect(<span class="tok-number">0</span>, <span class="tok-number">0</span>,
                   <span class="tok-keyword">this</span>.canvas.width, <span class="tok-keyword">this</span>.canvas.height);
};</pre>

<p><a class="p_ident" id="p-yjX+YUKb2N" href="#p-yjX+YUKb2N" tabindex="-1" role="presentation"></a>Para dibujar el fondo, recorremos los mosaicos que son visibles en el <strong>viewport</strong> actual, utilizando el mismo truco usado en el método <code>touches</code> del <a href="16_game.html#touches">capítulo anterior</a>.</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-sandbox="game"><a class="c_ident" id="c-UYqDAMiEp6" href="#c-UYqDAMiEp6" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">otherSprites</span> = document.createElement(<span class="tok-string">&quot;img&quot;</span>);
otherSprites.src = <span class="tok-string">&quot;img/sprites.png&quot;</span>;

CanvasDisplay.prototype.drawBackground = <span class="tok-keyword">function</span>(<span class="tok-definition">level</span>) {
  <span class="tok-keyword">let</span> {left, top, width, height} = <span class="tok-keyword">this</span>.viewport;
  <span class="tok-keyword">let</span> <span class="tok-definition">xStart</span> = Math.floor(left);
  <span class="tok-keyword">let</span> <span class="tok-definition">xEnd</span> = Math.ceil(left + width);
  <span class="tok-keyword">let</span> <span class="tok-definition">yStart</span> = Math.floor(top);
  <span class="tok-keyword">let</span> <span class="tok-definition">yEnd</span> = Math.ceil(top + height);

  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">y</span> = yStart; y &lt; yEnd; y++) {
    <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">x</span> = xStart; x &lt; xEnd; x++) {
      <span class="tok-keyword">let</span> <span class="tok-definition">tile</span> = level.rows[y][x];
      <span class="tok-keyword">if</span> (tile == <span class="tok-string">&quot;empty&quot;</span>) <span class="tok-keyword">continue</span>;
      <span class="tok-keyword">let</span> <span class="tok-definition">screenX</span> = (x - left) * scale;
      <span class="tok-keyword">let</span> <span class="tok-definition">screenY</span> = (y - top) * scale;
      <span class="tok-keyword">let</span> <span class="tok-definition">tileX</span> = tile == <span class="tok-string">&quot;lava&quot;</span> ? scale : <span class="tok-number">0</span>;
      <span class="tok-keyword">this</span>.cx.drawImage(otherSprites,
                        tileX,         <span class="tok-number">0</span>, scale, scale,
                        screenX, screenY, scale, scale);
    }
  }
};</pre>

<p><a class="p_ident" id="p-EitgnSjUGR" href="#p-EitgnSjUGR" tabindex="-1" role="presentation"></a>Las casillas que no están vacías se dibujan con <code>drawImage</code>. La imagen <code>otherSprites</code> contiene las imágenes utilizadas para elementos que no son el jugador. Contiene, de izquierda a derecha, la casilla de pared, la casilla de lava y el sprite de una moneda.</p><figure><img src="img/sprites_big.png" alt="Píxel art que muestra tres sprites: una pieza de pared, hecha de pequeñas piedras blancas, un cuadrado de lava naranja y una moneda redonda."></figure>

<p><a class="p_ident" id="p-pZ+9buT79l" href="#p-pZ+9buT79l" tabindex="-1" role="presentation"></a>Las casillas de fondo son de 20 por 20 píxeles ya que usaremos la misma escala que en <code>DOMDisplay</code>. Por lo tanto, el desplazamiento para las casillas de lava es 20 (el valor de la variable <code>scale</code>), y el desplazamiento para las paredes es 0.</p>

<p><a class="p_ident" id="p-x/lOxujgJO" href="#p-x/lOxujgJO" tabindex="-1" role="presentation"></a>No nos importa esperar a que se cargue la imagen del sprite. Llamar a <code>drawImage</code> con una imagen que aún no se ha cargado simplemente no hará nada. Por lo tanto, podríamos no dibujar correctamente el juego durante los primeros frames, mientras la imagen aún se está cargando, pero eso no es un problema grave. Como seguimos actualizando la pantalla, la escena correcta aparecerá tan pronto como termine la carga.</p>

<p><a class="p_ident" id="p-7j4A77OX2O" href="#p-7j4A77OX2O" tabindex="-1" role="presentation"></a>El personaje caminando que se mostró anteriormente se utilizará para representar al jugador. El código que lo dibuja necesita seleccionar el sprite adecuado y la dirección basándose en el movimiento actual del jugador. Los primeros ocho sprites contienen una animación de caminar. Cuando el jugador se está moviendo a lo largo de una superficie, los recorremos según el tiempo actual. Queremos cambiar de fotogramas cada 60 milisegundos, por lo que primero dividimos el tiempo por 60. Cuando el jugador está quieto, dibujamos el noveno sprite. Durante los saltos, que se reconocen por el hecho de que la velocidad vertical no es cero, usamos el décimo sprite de la derecha.</p>

<p><a class="p_ident" id="p-0A/X02lHnK" href="#p-0A/X02lHnK" tabindex="-1" role="presentation"></a>Dado que los sprites son ligeramente más anchos que el objeto del jugador—24 en lugar de 16 píxeles para permitir algo de espacio para los pies y los brazos—el método debe ajustar la coordenada x y el ancho por una cantidad dada (<code>playerXOverlap</code>).</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-sandbox="game"><a class="c_ident" id="c-T61uCWX04T" href="#c-T61uCWX04T" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">playerSprites</span> = document.createElement(<span class="tok-string">&quot;img&quot;</span>);
playerSprites.src = <span class="tok-string">&quot;img/player.png&quot;</span>;
<span class="tok-keyword">const</span> <span class="tok-definition">playerXOverlap</span> = <span class="tok-number">4</span>;

CanvasDisplay.prototype.drawPlayer = <span class="tok-keyword">function</span>(<span class="tok-definition">player</span>, <span class="tok-definition">x</span>, <span class="tok-definition">y</span>,
                                              <span class="tok-definition">width</span>, <span class="tok-definition">height</span>){
  width += playerXOverlap * <span class="tok-number">2</span>;
  x -= playerXOverlap;
  <span class="tok-keyword">if</span> (player.speed.x != <span class="tok-number">0</span>) {
    <span class="tok-keyword">this</span>.flipPlayer = player.speed.x &lt; <span class="tok-number">0</span>;
  }

  <span class="tok-keyword">let</span> <span class="tok-definition">tile</span> = <span class="tok-number">8</span>;
  <span class="tok-keyword">if</span> (player.speed.y != <span class="tok-number">0</span>) {
    tile = <span class="tok-number">9</span>;
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (player.speed.x != <span class="tok-number">0</span>) {
    tile = Math.floor(Date.now() / <span class="tok-number">60</span>) % <span class="tok-number">8</span>;
  }

  <span class="tok-keyword">this</span>.cx.save();
  <span class="tok-keyword">if</span> (<span class="tok-keyword">this</span>.flipPlayer) {
    flipHorizontally(<span class="tok-keyword">this</span>.cx, x + width / <span class="tok-number">2</span>);
  }
  <span class="tok-keyword">let</span> <span class="tok-definition">tileX</span> = tile * width;
  <span class="tok-keyword">this</span>.cx.drawImage(playerSprites, tileX, <span class="tok-number">0</span>, width, height,
                                   x,     y, width, height);
  <span class="tok-keyword">this</span>.cx.restore();
};</pre>

<p><a class="p_ident" id="p-OseNNDx2yk" href="#p-OseNNDx2yk" tabindex="-1" role="presentation"></a>El método <code>drawPlayer</code> es llamado por <code>drawActors</code>, el cual es responsable de dibujar todos los actores en el juego.</p>

<pre tabindex="0" class="snippet" data-language="javascript"  data-sandbox="game"><a class="c_ident" id="c-XwZEfLqKhO" href="#c-XwZEfLqKhO" tabindex="-1" role="presentation"></a>CanvasDisplay.prototype.drawActors = <span class="tok-keyword">function</span>(<span class="tok-definition">actors</span>) {
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">actor</span> <span class="tok-keyword">of</span> actors) {
    <span class="tok-keyword">let</span> <span class="tok-definition">width</span> = actor.size.x * scale;
    <span class="tok-keyword">let</span> <span class="tok-definition">height</span> = actor.size.y * scale;
    <span class="tok-keyword">let</span> <span class="tok-definition">x</span> = (actor.pos.x - <span class="tok-keyword">this</span>.viewport.left) * scale;
    <span class="tok-keyword">let</span> <span class="tok-definition">y</span> = (actor.pos.y - <span class="tok-keyword">this</span>.viewport.top) * scale;
    <span class="tok-keyword">if</span> (actor.type == <span class="tok-string">&quot;player&quot;</span>) {
      <span class="tok-keyword">this</span>.drawPlayer(actor, x, y, width, height);
    } <span class="tok-keyword">else</span> {
      <span class="tok-keyword">let</span> <span class="tok-definition">tileX</span> = (actor.type == <span class="tok-string">&quot;coin&quot;</span> ? <span class="tok-number">2</span> : <span class="tok-number">1</span>) * scale;
      <span class="tok-keyword">this</span>.cx.drawImage(otherSprites,
                        tileX, <span class="tok-number">0</span>, width, height,
                        x,     y, width, height);
    }
  }
};</pre>

<p><a class="p_ident" id="p-mYmRBqJrsx" href="#p-mYmRBqJrsx" tabindex="-1" role="presentation"></a>Cuando se está dibujando algo que no es el jugador, miramos su tipo para encontrar el desplazamiento del sprite correcto. El dibujo de la lava se encuentra en el desplazamiento 20, y el sprite de la moneda se encuentra en 40 (dos veces <code>scale</code>).</p>

<p><a class="p_ident" id="p-l9WGkcrpyc" href="#p-l9WGkcrpyc" tabindex="-1" role="presentation"></a>Tenemos que restar la posición del viewport al calcular la posición del actor, ya que (0,0) en nuestro canvas corresponde a la esquina superior izquierda del viewport, no a la esquina superior izquierda del nivel. También podríamos haber usado <code>translate</code> para esto. De ambas maneras funciona.</p>

<p><a class="p_ident" id="p-BKnEpLNETg" href="#p-BKnEpLNETg" tabindex="-1" role="presentation"></a>Este documento conecta el nuevo display a <code>runGame</code>:</p>

<pre tabindex="0" class="snippet" data-language="html"  data-focus="true" data-sandbox="game"><a class="c_ident" id="c-TSR2vcnWZv" href="#c-TSR2vcnWZv" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">body</span>&gt;
  &lt;<span class="tok-typeName">script</span>&gt;
    runGame(GAME_LEVELS, CanvasDisplay);
  &lt;/<span class="tok-typeName">script</span>&gt;
&lt;/<span class="tok-typeName">body</span>&gt;</pre>

<h2 id="graphics_tradeoffs"><a class="h_ident" id="h-7mCVVOn6Wy" href="#h-7mCVVOn6Wy" tabindex="-1" role="presentation"></a>Elección de una interfaz gráfica</h2>

<p><a class="p_ident" id="p-utyJuLTIwI" href="#p-utyJuLTIwI" tabindex="-1" role="presentation"></a>Así que, cuando necesitas generar gráficos en el navegador, puedes elegir entre HTML simple, SVG y canvas. No hay un único <em>mejor</em> enfoque que funcione en todas las situaciones. Cada opción tiene sus fortalezas y debilidades.</p>

<p><a class="p_ident" id="p-a0Iu5/ZW5u" href="#p-a0Iu5/ZW5u" tabindex="-1" role="presentation"></a>HTML simple tiene la ventaja de ser simple. También se integra bien con texto. Tanto SVG como canvas te permiten dibujar texto, pero no te ayudarán a posicionar ese texto o envolverlo cuando ocupa más de una línea. En una imagen basada en HTML, es mucho más fácil incluir bloques de texto.</p>

<p><a class="p_ident" id="p-3iAwjt81PX" href="#p-3iAwjt81PX" tabindex="-1" role="presentation"></a>SVG se puede utilizar para producir gráficos nítidos que se ven bien en cualquier nivel de zoom. A diferencia de HTML, está diseñado para dibujar y, por lo tanto, es más adecuado para ese propósito.</p>

<p><a class="p_ident" id="p-KKqtQMD1GU" href="#p-KKqtQMD1GU" tabindex="-1" role="presentation"></a>Tanto SVG como HTML construyen una estructura de datos (el DOM) que representa tu imagen. Esto hace posible modificar elementos después de ser dibujados. Si necesitas cambiar repetidamente una pequeña parte de una imagen grande en respuesta a lo que está haciendo el usuario o como parte de una animación, hacerlo en un canvas puede ser innecesariamente costoso. El DOM también nos permite registrar manipuladores de eventos de ratón en cada elemento de la imagen (incluso en formas dibujadas con SVG). No puedes hacer eso con canvas.</p>

<p><a class="p_ident" id="p-RRzI6Zv0v1" href="#p-RRzI6Zv0v1" tabindex="-1" role="presentation"></a>Pero el enfoque orientado a píxeles de canvas puede ser una ventaja al dibujar una gran cantidad de elementos pequeños. El hecho de que no construye una estructura de datos, sino que solo dibuja repetidamente sobre la misma superficie de píxeles, hace que canvas tenga un menor costo por forma.</p>

<p><a class="p_ident" id="p-JcCiSu5oeu" href="#p-JcCiSu5oeu" tabindex="-1" role="presentation"></a>También hay efectos, como renderizar una escena píxel por píxel (por ejemplo, usando un <em>ray tracer</em>) o procesar una imagen con JavaScript (desenfocarla o distorsionarla), que solo son prácticos con un elemento canvas.</p>

<p><a class="p_ident" id="p-N6EbEIQTYy" href="#p-N6EbEIQTYy" tabindex="-1" role="presentation"></a>En algunos casos, puede que desees combinar varias de estas técnicas. Por ejemplo, podrías dibujar un gráfico con SVG o canvas pero mostrar información textual posicionando un elemento HTML encima de la imagen.</p>

<p><a class="p_ident" id="p-ur+3ZHHg7V" href="#p-ur+3ZHHg7V" tabindex="-1" role="presentation"></a>Para aplicaciones poco exigentes, realmente no importa mucho qué interfaz elijas. La visualización que construimos para nuestro juego en este capítulo podría haber sido implementada utilizando cualquiera de estas tres tecnologías gráficas ya que no necesita dibujar texto, manejar interacción del mouse o trabajar con una cantidad extraordinariamente grande de elementos.</p>

<h2><a class="h_ident" id="h-NUFOUyK+lw" href="#h-NUFOUyK+lw" tabindex="-1" role="presentation"></a>Resumen</h2>

<p><a class="p_ident" id="p-SxVIOG6sY6" href="#p-SxVIOG6sY6" tabindex="-1" role="presentation"></a>En este capítulo discutimos técnicas para dibujar gráficos en el navegador, centrándonos en el elemento <code>&lt;canvas&gt;</code>.</p>

<p><a class="p_ident" id="p-wSJk3oWZQ4" href="#p-wSJk3oWZQ4" tabindex="-1" role="presentation"></a>Un nodo canvas representa un área en un documento en la que nuestro programa puede dibujar. Este dibujo se realiza a través de un objeto de contexto de dibujo, creado con el método <code>getContext</code>.</p>

<p><a class="p_ident" id="p-xBzY0lpQ5o" href="#p-xBzY0lpQ5o" tabindex="-1" role="presentation"></a>La interfaz de dibujo 2D nos permite rellenar y trazar varias formas. La propiedad <code>fillStyle</code> del contexto determina cómo se rellenan las formas. Las propiedades <code>strokeStyle</code> y <code>lineWidth</code> controlan la forma en que se dibujan las líneas.</p>

<p><a class="p_ident" id="p-pzTbA34IPz" href="#p-pzTbA34IPz" tabindex="-1" role="presentation"></a>Los rectángulos y trozos de texto se pueden dibujar con una sola llamada a un método. Los métodos <code>fillRect</code> y <code>strokeRect</code> dibujan rectángulos, y los métodos <code>fillText</code> y <code>strokeText</code> dibujan texto. Para crear formas personalizadas, primero debemos construir un camino.</p>

<p><a class="p_ident" id="p-gNJPCbDPHb" href="#p-gNJPCbDPHb" tabindex="-1" role="presentation"></a>Llamar a <code>beginPath</code> inicia un nuevo camino. Varios otros métodos agregan líneas y curvas al camino actual. Por ejemplo, <code>lineTo</code> puede agregar una línea recta. Cuando un camino está terminado, se puede rellenar con el método <code>fill</code> o trazarse con el método <code>stroke</code>.</p>

<p><a class="p_ident" id="p-WlLN55doNo" href="#p-WlLN55doNo" tabindex="-1" role="presentation"></a>Mover píxeles desde una imagen u otro canvas a nuestro canvas se hace con el método <code>drawImage</code>. Por defecto, este método dibuja toda la imagen fuente, pero al darle más parámetros, puedes copiar un área específica de la imagen. Utilizamos esto para nuestro juego copiando poses individuales del personaje del juego de una imagen que contenía muchas poses.</p>

<p><a class="p_ident" id="p-DfCg8B2Ck8" href="#p-DfCg8B2Ck8" tabindex="-1" role="presentation"></a>Las transformaciones te permiten dibujar una forma en múltiples orientaciones. Un contexto de dibujo 2D tiene una transformación actual que se puede cambiar con los métodos <code>translate</code>, <code>scale</code> y <code>rotate</code>. Estos afectarán todas las operaciones de dibujo subsiguientes. Un estado de transformación se puede guardar con el método <code>save</code> y restaurar con el método <code>restore</code>.</p>

<p><a class="p_ident" id="p-RN8WgeZRpl" href="#p-RN8WgeZRpl" tabindex="-1" role="presentation"></a>Al mostrar una animación en un canvas, se puede usar el método <code>clearRect</code> para borrar parte del canvas antes de volver a dibujarlo.</p>

<h2><a class="h_ident" id="h-tkm7ntLto1" href="#h-tkm7ntLto1" tabindex="-1" role="presentation"></a>Ejercicios</h2>

<h3><a class="i_ident" id="i-6W3KpJZhnW" href="#i-6W3KpJZhnW" tabindex="-1" role="presentation"></a>Formas</h3>

<p><a class="p_ident" id="p-iT72bWnKCh" href="#p-iT72bWnKCh" tabindex="-1" role="presentation"></a>Escribe un programa que dibuje las siguientes formas en un lienzo canvas:</p>

<ol>

<li>

<p><a class="p_ident" id="p-r1g3z75bQs" href="#p-r1g3z75bQs" tabindex="-1" role="presentation"></a>Un trapecio (un rectángulo que es más ancho en un lado)</p></li>

<li>

<p><a class="p_ident" id="p-RnXEkaR+23" href="#p-RnXEkaR+23" tabindex="-1" role="presentation"></a>Un diamante rojo diamond (un rectángulo rotado 45 grados o ¼π radianes)</p></li>

<li>

<p><a class="p_ident" id="p-nAyyEMAyNl" href="#p-nAyyEMAyNl" tabindex="-1" role="presentation"></a>Una línea en zigzag</p></li>

<li>

<p><a class="p_ident" id="p-HMNmf2kRcX" href="#p-HMNmf2kRcX" tabindex="-1" role="presentation"></a>Un espiral compuesta por 100 segmentos de línea recta</p></li>

<li>

<p><a class="p_ident" id="p-UYtj+NTTI5" href="#p-UYtj+NTTI5" tabindex="-1" role="presentation"></a>Una estrella amarilla star</p></li>

</ol><figure><img src="img/exercise_shapes.png" alt="Imagen que muestra las formas que se te pide dibujar"></figure>

<p><a class="p_ident" id="p-Zg0P7TZXO0" href="#p-Zg0P7TZXO0" tabindex="-1" role="presentation"></a>Cuando dibujes las dos últimas, es posible que quieras consultar la explicación de <code>Math.cos</code> y <code>Math.sin</code> en el <a href="14_dom.html#sin_cos">Capítulo 14</a>, que describe cómo obtener coordenadas en un círculo utilizando estas funciones.</p>

<p><a class="p_ident" id="p-5++I4nM1YH" href="#p-5++I4nM1YH" tabindex="-1" role="presentation"></a>Recomiendo crear una función para cada forma. Pasa la posición y opcionalmente otras propiedades como el tamaño o el número de puntos, como parámetros. La alternativa, que es codificar números en todo tu código, tiende a hacer que el código sea innecesariamente difícil de leer y modificar.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-Lb4eOfSFvm" href="#c-Lb4eOfSFvm" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span> width=<span class="tok-string">&quot;600&quot;</span> height=<span class="tok-string">&quot;200&quot;</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);

  <span class="tok-comment">// Tu código aquí.</span>
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-hImc7Tohvp" href="#p-hImc7Tohvp" tabindex="-1" role="presentation"></a>El trapecio (1) es más fácil de dibujar usando un recorrido. Elige coordenadas centrales adecuadas y agrega cada una de las cuatro esquinas alrededor del centro.</p>

<p><a class="p_ident" id="p-5H/3njUG1K" href="#p-5H/3njUG1K" tabindex="-1" role="presentation"></a>{{index “función flipHorizontally”, rotación}}</p>

<p><a class="p_ident" id="p-v4JHTMrZvY" href="#p-v4JHTMrZvY" tabindex="-1" role="presentation"></a>El diamante diamond (2) se puede dibujar de forma directa, con un recorrido, o de forma interesante, con una transformación de <code>rotación</code>. Para usar la rotación, tendrás que aplicar un truco similar al que hicimos en la función <code>flipHorizontally</code>. Como tienes que rotar alrededor del centro de tu rectángulo y no alrededor del punto (0,0), primero debes hacer <code>translate</code> hasta allí, luego rotar, y luego volver a trasladar.</p>

<p><a class="p_ident" id="p-UT6K3d6lOT" href="#p-UT6K3d6lOT" tabindex="-1" role="presentation"></a>Asegúrate de restablecer la transformación después de dibujar cualquier forma que la cree.</p>

<p><a class="p_ident" id="p-6aPL81jRO0" href="#p-6aPL81jRO0" tabindex="-1" role="presentation"></a>Para el zigzag (3) se vuelve impráctico escribir una nueva llamada a <code>lineTo</code> para cada segmento de línea. En su lugar, deberías usar un bucle. En cada iteración, puedes hacer que dibuje dos segmentos de línea (derecha y luego izquierda nuevamente) o uno, en cuyo caso debes usar la paridad (<code>% 2</code>) del índice del bucle para determinar si ir a la izquierda o a la derecha.</p>

<p><a class="p_ident" id="p-3DikRGSFgr" href="#p-3DikRGSFgr" tabindex="-1" role="presentation"></a>También necesitarás un bucle para la espiral (4). Si dibujas una serie de puntos, con cada punto moviéndose más lejos a lo largo de un círculo alrededor del centro de la espiral, obtienes un círculo. Si, durante el bucle, varías el radio del círculo en el que estás poniendo el punto actual y das más de una vuelta, el resultado es una espiral.</p>

<p><a class="p_ident" id="p-nnbEXh4bjC" href="#p-nnbEXh4bjC" tabindex="-1" role="presentation"></a>La estrella (5) representada está construida con líneas <code>quadraticCurveTo</code>. También podrías dibujar una con líneas rectas. Divide un círculo en ocho piezas para una estrella con ocho puntas, o cuantas piezas desees. Dibuja líneas entre estos puntos, haciéndolas curvarse hacia el centro de la estrella. Con <code>quadraticCurveTo</code>, puedes usar el centro como punto de control.</p>

</div></details>

<h3 id="exercise_pie_chart"><a class="i_ident" id="i-BMrB5aTm8r" href="#i-BMrB5aTm8r" tabindex="-1" role="presentation"></a>El gráfico circular</h3>

<p><a class="p_ident" id="p-6jUrW+U79l" href="#p-6jUrW+U79l" tabindex="-1" role="presentation"></a>Anteriormente en este capítulo, vimos un programa de ejemplo que dibujaba un gráfico circular. Modifica este programa para que el nombre de cada categoría se muestre junto a la porción que la representa. Intenta encontrar una forma agradable de posicionar automáticamente este texto que funcione también para otros conjuntos de datos. Puedes asumir que las categorías son lo suficientemente grandes como para dejar espacio suficiente para sus etiquetas.</p>

<p><a class="p_ident" id="p-ydhZmqGWMr" href="#p-ydhZmqGWMr" tabindex="-1" role="presentation"></a>Podrías necesitar <code>Math.sin</code> y <code>Math.cos</code> de nuevo, que se describen en el <a href="14_dom.html#sin_cos">Capítulo 14</a>.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-DTliIvEhY1" href="#c-DTliIvEhY1" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span> width=<span class="tok-string">&quot;600&quot;</span> height=<span class="tok-string">&quot;300&quot;</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">total</span> = results
    .reduce((<span class="tok-definition">sum</span>, {count}) =&gt; sum + count, <span class="tok-number">0</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">currentAngle</span> = -<span class="tok-number">0.5</span> * Math.PI;
  <span class="tok-keyword">let</span> <span class="tok-definition">centerX</span> = <span class="tok-number">300</span>, <span class="tok-definition">centerY</span> = <span class="tok-number">150</span>;

  <span class="tok-comment">// Add code to draw the slice labels in this loop.</span>
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">result</span> <span class="tok-keyword">of</span> results) {
    <span class="tok-keyword">let</span> <span class="tok-definition">sliceAngle</span> = (result.count / total) * <span class="tok-number">2</span> * Math.PI;
    cx.beginPath();
    cx.arc(centerX, centerY, <span class="tok-number">100</span>,
           currentAngle, currentAngle + sliceAngle);
    currentAngle += sliceAngle;
    cx.lineTo(centerX, centerY);
    cx.fillStyle = result.color;
    cx.fill();
  }
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-K+C2avvWfz" href="#p-K+C2avvWfz" tabindex="-1" role="presentation"></a>Necesitarás llamar a <code>fillText</code> y establecer las propiedades <code>textAlign</code> y <code>textBaseline</code> del contexto de manera que el texto termine donde quieras.</p>

<p><a class="p_ident" id="p-/TzvRLyHWY" href="#p-/TzvRLyHWY" tabindex="-1" role="presentation"></a>Una forma sensata de posicionar las etiquetas sería poner el texto en la línea que va desde el centro del círculo a través del medio de la porción. No quieres poner el texto directamente contra el lado del círculo, sino mover el texto hacia afuera del círculo por un número determinado de píxeles.</p>

<p><a class="p_ident" id="p-haGP3J94Ub" href="#p-haGP3J94Ub" tabindex="-1" role="presentation"></a>El ángulo de esta línea es <code>currentAngle + 0.<wbr>5 * sliceAngle</code>. El siguiente código encuentra una posición en esta línea a 120 píxeles del centro:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-7kVY28rLLf" href="#c-7kVY28rLLf" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">middleAngle</span> = currentAngle + <span class="tok-number">0.5</span> * sliceAngle;
<span class="tok-keyword">let</span> <span class="tok-definition">textX</span> = Math.cos(middleAngle) * <span class="tok-number">120</span> + centerX;
<span class="tok-keyword">let</span> <span class="tok-definition">textY</span> = Math.sin(middleAngle) * <span class="tok-number">120</span> + centerY;</pre>

<p><a class="p_ident" id="p-icUXr4QXvM" href="#p-icUXr4QXvM" tabindex="-1" role="presentation"></a>Para <code>textBaseline</code>, el valor <code>&quot;middle&quot;</code> probablemente sea apropiado al usar este enfoque. Lo que se debe usar para <code>textAlign</code> depende de en qué lado del círculo nos encontremos. En el lado izquierdo, debería ser <code>&quot;right&quot;</code>, y en el lado derecho, debería ser <code>&quot;left&quot;</code>, de manera que el texto se posicione lejos del círculo.</p>

<p><a class="p_ident" id="p-DWuqvj0Dl2" href="#p-DWuqvj0Dl2" tabindex="-1" role="presentation"></a>Si no estás seguro de cómo averiguar en qué lado del círculo se encuentra un ángulo dado, consulta la explicación de <code>Math.cos</code> en el <a href="14_dom.html#sin_cos">Capítulo 14</a>. El coseno de un ángulo nos indica qué coordenada x le corresponde, lo que a su vez nos dice exactamente en qué lado del círculo estamos.</p>

</div></details>

<h3><a class="i_ident" id="i-V/3ulxW65J" href="#i-V/3ulxW65J" tabindex="-1" role="presentation"></a>Una pelota rebotando</h3>

<p><a class="p_ident" id="p-E0rF74dj7i" href="#p-E0rF74dj7i" tabindex="-1" role="presentation"></a>Utiliza la técnica de <code>requestAnimationFrame</code> que vimos en el <a href="14_dom.html#animationFrame">Capítulo 14</a> y <a href="16_game.html#runAnimation">Capítulo 16</a> para dibujar una caja con una pelota rebotando dentro. La pelota se mueve a una velocidad constante y rebota en los lados de la caja cuando los alcanza.</p>

<pre tabindex="0" class="snippet" data-language="html" ><a class="c_ident" id="c-gdyoJV+nv2" href="#c-gdyoJV+nv2" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">canvas</span> width=<span class="tok-string">&quot;400&quot;</span> height=<span class="tok-string">&quot;400&quot;</span>&gt;&lt;/<span class="tok-typeName">canvas</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = document.querySelector(<span class="tok-string">&quot;canvas&quot;</span>).getContext(<span class="tok-string">&quot;2d&quot;</span>);

  <span class="tok-keyword">let</span> <span class="tok-definition">lastTime</span> = <span class="tok-keyword">null</span>;
  <span class="tok-keyword">function</span> <span class="tok-definition">frame</span>(<span class="tok-definition">time</span>) {
    <span class="tok-keyword">if</span> (lastTime != <span class="tok-keyword">null</span>) {
      updateAnimation(Math.min(<span class="tok-number">100</span>, time - lastTime) / <span class="tok-number">1000</span>);
    }
    lastTime = time;
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  <span class="tok-keyword">function</span> <span class="tok-definition">updateAnimation</span>(<span class="tok-definition">step</span>) {
    <span class="tok-comment">// Tu código aquí.</span>
  }
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-Q3e575eaiY" href="#p-Q3e575eaiY" tabindex="-1" role="presentation"></a>Un cuadro es fácil de dibujar con <code>strokeRect</code>. Define una variable que contenga su tamaño o define dos variables si el ancho y alto de tu cuadro difieren. Para crear una pelota redonda, comienza un camino y llama a <code>arc(x, y, radio, 0, 7)</code>, que crea un arco que va desde cero a más de un círculo completo. Luego rellena el camino.</p>

<p><a class="p_ident" id="p-wCWbSjfD5D" href="#p-wCWbSjfD5D" tabindex="-1" role="presentation"></a>Para modelar la posición y la velocidad de la pelota, puedes usar la clase <code>Vec</code> del <a href="16_game.html#vector">Capítulo 16</a> (que está disponible en esta página){if interactive}. Dale una velocidad inicial, preferiblemente una que no sea puramente vertical u horizontal, y en cada cuadro multiplica esa velocidad por la cantidad de tiempo transcurrido. Cuando la pelota se acerca demasiado a una pared vertical, invierte el componente x en su velocidad. De manera similar, invierte el componente y cuando golpea una pared horizontal.</p>

<p><a class="p_ident" id="p-VxbSsJWTCt" href="#p-VxbSsJWTCt" tabindex="-1" role="presentation"></a>Después de encontrar la nueva posición y velocidad de la pelota, usa <code>clearRect</code> para borrar la escena y vuélvela a dibujar usando la nueva posición.</p>

</div></details>

<h3><a class="i_ident" id="i-bWN6DLs80w" href="#i-bWN6DLs80w" tabindex="-1" role="presentation"></a>Reflejo precalculado</h3>

<p><a class="p_ident" id="p-kI8Y5v6gUy" href="#p-kI8Y5v6gUy" tabindex="-1" role="presentation"></a>Una desventaja de las transformaciones es que ralentizan el dibujo de mapas de bits. La posición y el tamaño de cada píxel deben ser transformados, y aunque es posible que los navegadores se vuelvan más inteligentes en cuanto a las transformaciones en el futuro, actualmente causan un aumento medible en el tiempo que lleva dibujar un mapa de bits.</p>

<p><a class="p_ident" id="p-NG42ekOsOP" href="#p-NG42ekOsOP" tabindex="-1" role="presentation"></a>En un juego como el nuestro, en el que solo estamos dibujando un sprite transformado, esto no es un problema. Pero imagina que necesitamos dibujar cientos de personajes o miles de partículas giratorias de una explosión.</p>

<p><a class="p_ident" id="p-/D9ug4jUKG" href="#p-/D9ug4jUKG" tabindex="-1" role="presentation"></a>Piensa en una forma de permitirnos dibujar un personaje invertido sin cargar archivos de imagen adicionales y sin tener que hacer llamadas transformadas de <code>drawImage</code> en cada cuadro.</p>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-hHgQtZU0jT" href="#p-hHgQtZU0jT" tabindex="-1" role="presentation"></a>La clave para la solución está en el hecho de que podemos usar un elemento canvas como imagen de origen al usar <code>drawImage</code>. Es posible crear un elemento <code>&lt;canvas&gt;</code> adicional, sin agregarlo al documento, y dibujar nuestros sprites invertidos en él, una vez. Al dibujar un cuadro real, simplemente copiamos los sprites ya invertidos al lienzo principal.</p>

<p><a class="p_ident" id="p-Mr2v3L0lpj" href="#p-Mr2v3L0lpj" tabindex="-1" role="presentation"></a>Se requeriría cierto cuidado porque las imágenes no se cargan instantáneamente. Hacemos el dibujo invertido solo una vez y, si lo hacemos antes de que la imagen se cargue, no dibujará nada. Se puede usar un controlador de <code>&quot;load&quot;</code> en la imagen para dibujar las imágenes invertidas en el lienzo adicional. Este lienzo se puede usar como fuente de dibujo inmediatamente (simplemente estará en blanco hasta que dibujemos el personaje en él).</p>

</div></details><nav><a href="16_game.html" title="previous chapter" aria-label="previous chapter">◂</a> <a href="index.html" title="cover" aria-label="cover">●</a> <a href="18_http.html" title="next chapter" aria-label="next chapter">▸</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>
</nav>
</article>

<script src="ejs.js"></script>
