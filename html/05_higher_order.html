<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Funciones de Orden Superior :: Eloquent JavaScript</title>
  <link rel=stylesheet href="css/ejs.css"><script>
      var page = {"type":"chapter","number":5}</script></head>

<article>
<nav><a href="04_data.html" title="previous chapter" aria-label="previous chapter">‚óÇ</a>¬†<a href="index.html" title="cover" aria-label="cover">‚óè</a>¬†<a href="06_object.html" title="next chapter" aria-label="next chapter">‚ñ∏</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>
</nav>

<h1>Funciones de Orden Superior</h1>

<p><a class="p_ident" id="p-vkRKropLCL" href="#p-vkRKropLCL" tabindex="-1" role="presentation"></a><em>‚ÄúHay dos formas de construir un dise√±o de software: Una forma es hacerlo tan simple que obviamente no haya deficiencias, y la otra forma es hacerlo tan complicado que no haya deficiencias obvias.‚Äù</em></p>

<p><a class="p_ident" id="p-rComRYoME7" href="#p-rComRYoME7" tabindex="-1" role="presentation"></a>‚Äî C.A.R. Hoare, <em>Discurso de Recepci√≥n del Premio Turing de la ACM de 1980</em></p>

<p><a class="p_ident" id="p-UkjkuKBNDn" href="#p-UkjkuKBNDn" tabindex="-1" role="presentation"></a>Un programa grande es un programa costoso, y no solo por el tiempo que lleva construirlo. El tama√±o casi siempre implica complejidad, y la complejidad confunde a los programadores. Los programadores confundidos, a su vez, introducen errores (<em>bugs</em>) en los programas. Un programa grande proporciona mucho espacio para que estos errores se escondan, lo que los hace dif√≠ciles de encontrar.</p>

<p><a class="p_ident" id="p-JH/k/etNiT" href="#p-JH/k/etNiT" tabindex="-1" role="presentation"></a>Volviendo brevemente a los dos ejemplos finales de programas en la introducci√≥n. El primero es autocontenido y tiene seis l√≠neas:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-uIkg9pj99q" href="#c-uIkg9pj99q" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">total</span> = <span class="tok-number">0</span>, <span class="tok-definition">count</span> = <span class="tok-number">1</span>;
<span class="tok-keyword">while</span> (count &lt;= <span class="tok-number">10</span>) {
  total += count;
  count += <span class="tok-number">1</span>;
}
console.log(total);</pre>

<p><a class="p_ident" id="p-XpPbbvrjf7" href="#p-XpPbbvrjf7" tabindex="-1" role="presentation"></a>El segundo depende de dos funciones externas y tiene una l√≠nea:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-KTbQMmMCli" href="#c-KTbQMmMCli" tabindex="-1" role="presentation"></a>console.log(sum(range(<span class="tok-number">1</span>, <span class="tok-number">10</span>)));</pre>

<p><a class="p_ident" id="p-mQkKtUTj8f" href="#p-mQkKtUTj8f" tabindex="-1" role="presentation"></a>¬øCu√°l es m√°s probable que contenga un error?</p>

<p><a class="p_ident" id="p-kr8iBt6cDE" href="#p-kr8iBt6cDE" tabindex="-1" role="presentation"></a>Si contamos el tama√±o de las definiciones de <code>sum</code> y <code>range</code>, el segundo programa tambi√©n es grande, incluso m√°s que el primero. Pero, a√∫n as√≠, argumentar√≠a que es m√°s probable que sea correcto.</p>

<p><a class="p_ident" id="p-sdRHhhOglU" href="#p-sdRHhhOglU" tabindex="-1" role="presentation"></a>Esto se debe a que la soluci√≥n se expresa en un vocabulary que corresponde al problema que se est√° resolviendo. Sumar un rango de n√∫meros no se trata de bucles y contadores. Se trata de rangos y sumas.</p>

<p><a class="p_ident" id="p-ZVaOtVwzgJ" href="#p-ZVaOtVwzgJ" tabindex="-1" role="presentation"></a>Las definiciones de este vocabulario (las funciones <code>sum</code> y <code>range</code>) seguir√°n involucrando bucles, contadores y otros detalles incidentales. Pero debido a que expresan conceptos m√°s simples que el programa en su totalidad, son m√°s f√°ciles de hacer correctamente.</p>

<h2><a class="h_ident" id="h-jeqhU5hoax" href="#h-jeqhU5hoax" tabindex="-1" role="presentation"></a>Abstracci√≥n</h2>

<p><a class="p_ident" id="p-b96WneVaDi" href="#p-b96WneVaDi" tabindex="-1" role="presentation"></a>En el contexto de la programaci√≥n, este tipo de vocabularios se suelen llamar <em>abstractions</em>. Las abstracciones nos brindan la capacidad de hablar sobre problemas a un nivel superior (o m√°s abstracto), sin distraernos con detalles no interesantes.</p>

<p><a class="p_ident" id="p-vujVr5jCqZ" href="#p-vujVr5jCqZ" tabindex="-1" role="presentation"></a>Como analog√≠a, compara estas dos recetas de sopa de guisantes. La primera es as√≠:</p>

<p><a class="p_ident" id="p-fxkqqXVuPN" href="#p-fxkqqXVuPN" tabindex="-1" role="presentation"></a>_‚ÄùPon 1 taza de guisantes secos por persona en un recipiente. Agrega agua hasta que los guisantes est√©n bien cubiertos. Deja los guisantes en agua durante al menos 12 horas. Saca los guisantes del agua y ponlos en una olla. Agrega 4 tazas de agua por persona. Cubre la olla y deja que los guisantes hiervan a fuego lento durante dos horas. Toma media cebolla por persona. C√≥rtala en trozos con un cuchillo. Agr√©gala a los guisantes. Toma un tallo de apio por persona. C√≥rtalo en trozos con un cuchillo. Agr√©galo a los guisantes. Toma una zanahoria por persona. ¬°C√≥rtala en trozos! ¬°Con un cuchillo! Agr√©gala a los guisantes. Cocina durante 10 minutos m√°s.‚Äù_Cita:</p>

<p><a class="p_ident" id="p-dL6mnA4R6A" href="#p-dL6mnA4R6A" tabindex="-1" role="presentation"></a>Y esta es la segunda receta:</p>

<p><a class="p_ident" id="p-tZ51jSgceM" href="#p-tZ51jSgceM" tabindex="-1" role="presentation"></a>Por persona: 1 taza de guisantes partidos secos, 4 tazas de agua, media cebolla picada, un tallo de apio y una zanahoria.</p>

<p><a class="p_ident" id="p-pWLdoICo3H" href="#p-pWLdoICo3H" tabindex="-1" role="presentation"></a>Remoja los guisantes durante 12 horas. Cocina a fuego lento durante 2 horas. Pica y agrega las verduras. Cocina durante 10 minutos m√°s.</p>

<p><a class="p_ident" id="p-TaRmoVsqmE" href="#p-TaRmoVsqmE" tabindex="-1" role="presentation"></a>El segundo es m√°s corto y m√°s f√°cil de interpretar. Pero necesitas entender algunas palabras m√°s relacionadas con la cocina, como <em>remojar</em>, <em>cocinar a fuego lento</em>, <em>picar</em>, y, supongo, <em>verdura</em>.</p>

<p><a class="p_ident" id="p-qhHkdQl/il" href="#p-qhHkdQl/il" tabindex="-1" role="presentation"></a>Cuando se programa, no podemos depender de que todas las palabras que necesitamos est√©n esper√°ndonos en el diccionario. Por lo tanto, podr√≠amos caer en el patr√≥n de la primera receta: trabajar en los pasos precisos que la computadora tiene que realizar, uno por uno, ciegos a los conceptos de m√°s alto nivel que expresan.</p>

<p><a class="p_ident" id="p-NUMaFMlENr" href="#p-NUMaFMlENr" tabindex="-1" role="presentation"></a>Abstraer la repetici√≥n</p>

<p><a class="p_ident" id="p-+yKMsSOH6s" href="#p-+yKMsSOH6s" tabindex="-1" role="presentation"></a>Las funciones simples, como las hemos visto hasta ahora, son una buena manera de construir abstracciones. Pero a veces se quedan cortas.</p>

<p><a class="p_ident" id="p-S9ZNhpazRV" href="#p-S9ZNhpazRV" tabindex="-1" role="presentation"></a>Es com√∫n que un programa haga algo un n√∫mero determinado de veces. Puedes escribir un <code>for</code> para eso, as√≠:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-5c+C2+9IG1" href="#c-5c+C2+9IG1" tabindex="-1" role="presentation"></a><span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; i &lt; <span class="tok-number">10</span>; i++) {
  console.log(i);
}</pre>

<p><a class="p_ident" id="p-mYLOzu14uu" href="#p-mYLOzu14uu" tabindex="-1" role="presentation"></a>¬øPodemos abstraer ‚Äúhacer algo <em>N</em> veces‚Äù como una funci√≥n? Bueno, es f√°cil escribir una funci√≥n que llame a <code>console.log</code> <em>N</em> veces:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-QQAO5Io87Z" href="#c-QQAO5Io87Z" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">repeatLog</span>(<span class="tok-definition">n</span>) {
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; i &lt; n; i++) {
    console.log(i);
  }</pre>

<p><a class="p_ident" id="p-aHRJYV9dtZ" href="#p-aHRJYV9dtZ" tabindex="-1" role="presentation"></a>¬øY si queremos hacer algo que no sea solo registrar los n√∫meros? Dado que ‚Äúhacer algo‚Äù se puede representar como una funci√≥n y las funciones son solo valores, podemos pasar nuestra acci√≥n como un valor de funci√≥n:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-p03rPqGmn9" href="#c-p03rPqGmn9" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">repeat</span>(<span class="tok-definition">n</span>, <span class="tok-definition">action</span>) {
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; i &lt; n; i++) {
    action(i);
  }
}

repeat(<span class="tok-number">3</span>, console.log);
<span class="tok-comment">// ‚Üí 0</span>
<span class="tok-comment">// ‚Üí 1</span>
<span class="tok-comment">// ‚Üí 2</span></pre>

<p><a class="p_ident" id="p-MZU1WHGlo3" href="#p-MZU1WHGlo3" tabindex="-1" role="presentation"></a>No tenemos que pasar una funci√≥n predefinida a <code>repeat</code>. A menudo, es m√°s f√°cil crear un valor de funci√≥n en el momento:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-TvtkTVhk/v" href="#c-TvtkTVhk/v" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">etiquetas</span> = [];
repeat(<span class="tok-number">5</span>, <span class="tok-definition">i</span> =&gt; {
  etiquetas.push(<span class="tok-string2">`Unidad </span>${i + <span class="tok-number">1</span>}<span class="tok-string2">`</span>);
});
console.log(etiquetas);
<span class="tok-comment">// ‚Üí [&quot;Unidad 1&quot;, &quot;Unidad 2&quot;, &quot;Unidad 3&quot;, &quot;Unidad 4&quot;, &quot;Unidad 5&quot;]</span></pre>

<p><a class="p_ident" id="p-ZaxR2WEHob" href="#p-ZaxR2WEHob" tabindex="-1" role="presentation"></a>Esto est√° estructurado un poco como un <code>for</code> loop: primero describe el tipo de loop y luego proporciona un cuerpo. Sin embargo, el cuerpo ahora est√° escrito como un valor de funci√≥n, que est√° envuelto entre los par√©ntesis de la llamada a <code>repeat</code>. Por eso tiene que cerrarse con el corchete de cierre y el par√©ntesis de cierre. En casos como este ejemplo donde el cuerpo es una sola expresi√≥n peque√±a, tambi√©n podr√≠as omitir los corchetes y escribir el bucle en una sola l√≠nea.</p>

<p><a class="p_ident" id="p-sBm/RoOmVE" href="#p-sBm/RoOmVE" tabindex="-1" role="presentation"></a>Funciones de orden superior</p>

<p><a class="p_ident" id="p-mB+p2eklnH" href="#p-mB+p2eklnH" tabindex="-1" role="presentation"></a>Las funciones que operan en otras funciones, ya sea tomandolas como argumentos o devolvi√©ndolas, se llaman <em>funciones de orden superior</em>. Dado que ya hemos visto que las funciones son valores regulares, no hay nada particularmente notable sobre el hecho de que existan tales funciones. El t√©rmino proviene de las matem√°ticas, donde se toma m√°s en serio la distinci√≥n entre funciones y otros valores.</p>

<p><a class="p_ident" id="p-sGlpxAbe6R" href="#p-sGlpxAbe6R" tabindex="-1" role="presentation"></a>Las funciones de orden superior nos permiten abstraer sobre <em>acciones</em>, no solo sobre valores. Vienen en varias formas. Por ejemplo, podemos tener funciones que crean nuevas funciones:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-yl26zgd/Q+" href="#c-yl26zgd/Q+" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">mayorQue</span>(<span class="tok-definition">n</span>) {
  <span class="tok-keyword">return</span> <span class="tok-definition">m</span> =&gt; m &gt; n;
}
<span class="tok-keyword">let</span> <span class="tok-definition">mayorQue10</span> = mayorQue(<span class="tok-number">10</span>);
console.log(mayorQue10(<span class="tok-number">11</span>));
<span class="tok-comment">// ‚Üí true</span></pre>

<p><a class="p_ident" id="p-ZzQufg6k7a" href="#p-ZzQufg6k7a" tabindex="-1" role="presentation"></a>Tambi√©n podemos tener funciones que modifican otras funciones:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-x5IWKK9iS2" href="#c-x5IWKK9iS2" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">ruidosa</span>(<span class="tok-definition">f</span>) {
  <span class="tok-keyword">return</span> (...<span class="tok-definition">args</span>) =&gt; {
    console.log(<span class="tok-string">&quot;llamando con&quot;</span>, args);
    <span class="tok-keyword">let</span> <span class="tok-definition">resultado</span> = f(...args);
    console.log(<span class="tok-string">&quot;llamado con&quot;</span>, args, <span class="tok-string">&quot;, devolvi√≥&quot;</span>, resultado);
    <span class="tok-keyword">return</span> resultado;
  };
}
ruidosa(Math.min)(<span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>);
<span class="tok-comment">// ‚Üí llamando con [3, 2, 1]</span>
<span class="tok-comment">// ‚Üí llamado con [3, 2, 1] , devolvi√≥ 1</span></pre>

<p><a class="p_ident" id="p-XsceS57yr8" href="#p-XsceS57yr8" tabindex="-1" role="presentation"></a>Incluso podemos escribir funciones que proveen nuevos tipos de flujo de control:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-nuRXUnBX/r" href="#c-nuRXUnBX/r" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">aMenosQue</span>(<span class="tok-definition">prueba</span>, <span class="tok-definition">entonces</span>) {
  <span class="tok-keyword">if</span> (!prueba) entonces();
}

repetir(<span class="tok-number">3</span>, <span class="tok-definition">n</span> =&gt; {
  aMenosQue(n % <span class="tok-number">2</span> == <span class="tok-number">1</span>, () =&gt; {
    console.log(n, <span class="tok-string">&quot;es par&quot;</span>);
  });
});
<span class="tok-comment">// ‚Üí 0 es par</span>
<span class="tok-comment">// ‚Üí 2 es par</span></pre>

<p><a class="p_ident" id="p-Zjga2rFofq" href="#p-Zjga2rFofq" tabindex="-1" role="presentation"></a>Existe un m√©todo incorporado de arrays, <code>forEach</code>, que proporciona algo similar a un bucle <code>for</code>/<code>of</code> como una funci√≥n de orden superior:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-v9jL6NafRj" href="#c-v9jL6NafRj" tabindex="-1" role="presentation"></a>[<span class="tok-string">&quot;A&quot;</span>, <span class="tok-string">&quot;B&quot;</span>].forEach(<span class="tok-definition">l</span> =&gt; console.log(l));
<span class="tok-comment">// ‚Üí A</span>
<span class="tok-comment">// ‚Üí B</span></pre>

<h2 id="scripts"><a class="h_ident" id="h-1WwJcQwjxW" href="#h-1WwJcQwjxW" tabindex="-1" role="presentation"></a>Conjunto de datos de script</h2>

<p><a class="p_ident" id="p-nLcvnbV7JQ" href="#p-nLcvnbV7JQ" tabindex="-1" role="presentation"></a>Un √°rea donde las funciones de orden superior destacan es en el procesamiento de datos. Para procesar datos, necesitaremos algunos ejemplos de datos reales. Este cap√≠tulo utilizar√° un conjunto de datos sobre scripts‚Äîsistemas de escritura tales como el lat√≠n, cir√≠lico o √°rabe.</p>

<p><a class="p_ident" id="p-QWRc3oEeB3" href="#p-QWRc3oEeB3" tabindex="-1" role="presentation"></a>¬øRecuerdas Unicode del <a href="valores#unicode">Cap√≠tulo ?</a>, el sistema que asigna un n√∫mero a cada car√°cter en lenguaje escrito? La mayor√≠a de estos caracteres est√°n asociados con un script espec√≠fico. El est√°ndar contiene 140 scripts diferentes, de los cuales 81 a√∫n se utilizan hoy en d√≠a y 59 son hist√≥ricos.</p>

<p><a class="p_ident" id="p-Y+uBE+NY1X" href="#p-Y+uBE+NY1X" tabindex="-1" role="presentation"></a>Aunque solo puedo leer con fluidez caracteres latinos, aprecio el hecho de que las personas est√©n escribiendo textos en al menos otros 80 sistemas de escritura, muchos de los cuales ni siquiera reconocer√≠a. Por ejemplo, aqu√≠ tienes una muestra de escritura Tamil:</p><figure><img src="img/tamil.png" alt="Una l√≠nea de verso en escritura Tamil. Los caracteres son relativamente simples y separados ordenadamente, pero completamente diferentes de los caracteres latinos."></figure>

<p><a class="p_ident" id="p-JQFACqGSut" href="#p-JQFACqGSut" tabindex="-1" role="presentation"></a>El ejemplo del conjunto de datos contiene algunas piezas de informaci√≥n sobre los 140 scripts definidos en Unicode. Est√° disponible en el <a href="https://eloquentjavascript.net/code#5">sandbox de c√≥digo</a> para este cap√≠tulo como el enlace <code>SCRIPTS</code>. El enlace contiene un array de objetos, cada uno describe un script:</p>

<pre class="snippet" data-language="json" ><a class="c_ident" id="c-vN789s6onO" href="#c-vN789s6onO" tabindex="-1" role="presentation"></a>{
  <span class="tok-definition">name</span>: <span class="tok-string">&quot;Copto&quot;</span>,
  <span class="tok-definition">rangos</span>: [[<span class="tok-number">994</span>, <span class="tok-number">1008</span>], [<span class="tok-number">11392</span>, <span class="tok-number">11508</span>], [<span class="tok-number">11513</span>, <span class="tok-number">11520</span>]],
  <span class="tok-definition">direcci√≥n</span>: <span class="tok-string">&quot;ltr&quot;</span>,
  <span class="tok-definition">a√±o</span>: -<span class="tok-number">200</span>,
  <span class="tok-definition">vivo</span>: false,
  <span class="tok-definition">enlace</span>: <span class="tok-string">&quot;https://es.wikipedia.org/wiki/Alfabeto_copto&quot;</span>
}</pre>

<p><a class="p_ident" id="p-ua08rL6DL0" href="#p-ua08rL6DL0" tabindex="-1" role="presentation"></a>Tal objeto nos informa sobre el nombre del script, los rangos Unicode asignados a √©l, la direcci√≥n en la que se escribe, el tiempo de origen (aproximado), si todav√≠a se utiliza, y un enlace a m√°s informaci√≥n. La direcci√≥n puede ser <code>&quot;ltr&quot;</code> para izquierda a derecha, <code>&quot;rtl&quot;</code> para derecha a izquierda (como se escribe el texto en √°rabe y hebreo) o <code>&quot;ttb&quot;</code> para arriba hacia abajo (como en la escritura mongola).</p>

<p><a class="p_ident" id="p-DoOVtob5DG" href="#p-DoOVtob5DG" tabindex="-1" role="presentation"></a>La propiedad <code>ranges</code> contiene una matriz de rangos de caracteres Unicode, cada uno de los cuales es una matriz de dos elementos que contiene un l√≠mite inferior y un l√≠mite superior. Todos los c√≥digos de caracteres dentro de estos rangos se asignan al guion. El l√≠mite inferior es inclusivo (el c√≥digo 994 es un car√°cter copto) y el l√≠mite superior no es inclusivo (el c√≥digo 1008 no lo es).</p>

<h2><a class="h_ident" id="h-MtcnrMCox6" href="#h-MtcnrMCox6" tabindex="-1" role="presentation"></a>Filtrado de arrays</h2>

<p><a class="p_ident" id="p-HjjeDvBqja" href="#p-HjjeDvBqja" tabindex="-1" role="presentation"></a>Si queremos encontrar los guiones en el conjunto de datos que todav√≠a se utilizan, la siguiente funci√≥n puede ser √∫til. Filtra los elementos de una matriz que no pasan una prueba.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-POEf7pMCk0" href="#c-POEf7pMCk0" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">filter</span>(<span class="tok-definition">array</span>, <span class="tok-definition">test</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">passed</span> = [];
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">element</span> <span class="tok-keyword">of</span> array) {
    <span class="tok-keyword">if</span> (test(element)) {
      passed.push(element);
    }
  }
  <span class="tok-keyword">return</span> passed;
}

console.log(filter(SCRIPTS, <span class="tok-definition">script</span> =&gt; script.living));
<span class="tok-comment">// ‚Üí [{name: &quot;Adlam&quot;, ‚Ä¶}, ‚Ä¶]</span></pre>

<p><a class="p_ident" id="p-TR3HO2AiQA" href="#p-TR3HO2AiQA" tabindex="-1" role="presentation"></a>{{index [‚Äúfunci√≥n‚Äù, ‚Äúcomo valor‚Äù], [‚Äúfunci√≥n‚Äù, aplicaci√≥n]}}</p>

<p><a class="p_ident" id="p-vqNV3Gw5Wz" href="#p-vqNV3Gw5Wz" tabindex="-1" role="presentation"></a>La funci√≥n utiliza el argumento llamado <code>test</code>, un valor de funci√≥n, para llenar un ‚Äúvac√≠o‚Äù en la computaci√≥n, el proceso de decidir qu√© elementos recopilar.</p>

<p><a class="p_ident" id="p-rDTRpRs2b7" href="#p-rDTRpRs2b7" tabindex="-1" role="presentation"></a>Observa c√≥mo la funci√≥n <code>filter</code>, en lugar de eliminar elementos de la matriz existente, construye una nueva matriz con solo los elementos que pasan la prueba. Esta funci√≥n es <em>pura</em>. No modifica la matriz que se le pasa.</p>

<p><a class="p_ident" id="p-mflQRYwRQo" href="#p-mflQRYwRQo" tabindex="-1" role="presentation"></a>Al igual que <code>forEach</code>, <code>filter</code> es un m√©todo de matriz est√°ndar. El ejemplo defini√≥ la funci√≥n solo para mostrar qu√© hace internamente. De ahora en adelante, lo usaremos de esta manera en su lugar:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-x8e0PmGGB1" href="#c-x8e0PmGGB1" tabindex="-1" role="presentation"></a>console.log(SCRIPTS.filter(<span class="tok-definition">s</span> =&gt; s.direction == <span class="tok-string">&quot;ttb&quot;</span>));
<span class="tok-comment">// ‚Üí [{name: &quot;Mongolian&quot;, ‚Ä¶}, ‚Ä¶]</span></pre>

<h2 id="map"><a class="h_ident" id="h-S3rmMrmWka" href="#h-S3rmMrmWka" tabindex="-1" role="presentation"></a>Transformaci√≥n con map</h2>

<p><a class="p_ident" id="p-ydEMpih2aw" href="#p-ydEMpih2aw" tabindex="-1" role="presentation"></a>Digamos que tenemos una matriz de objetos que representan guiones, producida al filtrar la matriz <code>SCRIPTS</code> de alguna manera. Queremos una matriz de nombres en su lugar, que es m√°s f√°cil de inspeccionar.</p>

<p><a class="p_ident" id="p-eEu8IlZwFm" href="#p-eEu8IlZwFm" tabindex="-1" role="presentation"></a>El m√©todo <code>map</code> transforma una matriz aplicando una funci√≥n a todos sus elementos y construyendo una nueva matriz a partir de los valores devueltos. La nueva matriz tendr√° la misma longitud que la matriz de entrada, pero su contenido habr√° sido <em>mapeado</em> a una nueva forma por la funci√≥n:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-03caQcQElo" href="#c-03caQcQElo" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">map</span>(<span class="tok-definition">array</span>, <span class="tok-definition">transform</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">mapped</span> = [];
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">element</span> <span class="tok-keyword">of</span> array) {
    mapped.push(transform(element));
  }
  <span class="tok-keyword">return</span> mapped;
}

<span class="tok-keyword">let</span> <span class="tok-definition">rtlScripts</span> = SCRIPTS.filter(<span class="tok-definition">s</span> =&gt; s.direction == <span class="tok-string">&quot;rtl&quot;</span>);
console.log(map(rtlScripts, <span class="tok-definition">s</span> =&gt; s.name));
<span class="tok-comment">// ‚Üí [&quot;Adlam&quot;, &quot;Arabic&quot;, &quot;Imperial Aramaic&quot;, ‚Ä¶]</span></pre>

<p><a class="p_ident" id="p-CSoEP7cmmy" href="#p-CSoEP7cmmy" tabindex="-1" role="presentation"></a>Al igual que <code>forEach</code> y <code>filter</code>, <code>map</code> es un m√©todo de matriz est√°ndar.</p>

<h2><a class="h_ident" id="h-PT5vUNRTlZ" href="#h-PT5vUNRTlZ" tabindex="-1" role="presentation"></a>Resumen con reduce</h2>

<p><a class="p_ident" id="p-0sSdjIXjkE" href="#p-0sSdjIXjkE" tabindex="-1" role="presentation"></a>Otra cosa com√∫n que hacer con matrices es calcular un √∫nico valor a partir de ellas. Nuestro ejemplo recurrente, sumar una colecci√≥n de n√∫meros, es una instancia de esto. Otro ejemplo es encontrar el guion con m√°s caracteres.</p>

<p><a class="p_ident" id="p-saI2d9pHc9" href="#p-saI2d9pHc9" tabindex="-1" role="presentation"></a>{{index [‚Äúfunci√≥n‚Äù, ‚Äúde orden superior‚Äù], ‚Äúm√©todo de reducci√≥n‚Äù}}La operaci√≥n de orden superior que representa este patr√≥n se llama <em>reduce</em> (a veces tambi√©n llamada <em>fold</em>). Construye un valor tomando repetidamente un √∫nico elemento del array y combin√°ndolo con el valor actual. Al sumar n√∫meros, comenzar√≠as con el n√∫mero cero y, para cada elemento, lo sumar√≠as al total.</p>

<p><a class="p_ident" id="p-2kupqkikqu" href="#p-2kupqkikqu" tabindex="-1" role="presentation"></a>Los par√°metros de <code>reduce</code> son, adem√°s del array, una funci√≥n de combinaci√≥n y un valor inicial. Esta funci√≥n es un poco menos directa que <code>filter</code> y <code>map</code>, as√≠ que obs√©rvala detenidamente:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-k5GDHjqpSc" href="#c-k5GDHjqpSc" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">reduce</span>(<span class="tok-definition">array</span>, <span class="tok-definition">combine</span>, <span class="tok-definition">start</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">current</span> = start;
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">element</span> <span class="tok-keyword">of</span> array) {
    current = combine(current, element);
  }
  <span class="tok-keyword">return</span> current;
}

console.log(reduce([<span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>], (<span class="tok-definition">a</span>, <span class="tok-definition">b</span>) =&gt; a + b, <span class="tok-number">0</span>));
<span class="tok-comment">// ‚Üí 10</span></pre>

<p><a class="p_ident" id="p-tSi+CnrI8e" href="#p-tSi+CnrI8e" tabindex="-1" role="presentation"></a>El m√©todo est√°ndar de arrays <code>reduce</code>, que por supuesto corresponde a esta funci√≥n, tiene una conveniencia adicional. Si tu array contiene al menos un elemento, puedes omitir el argumento <code>start</code>. El m√©todo tomar√° el primer elemento del array como su valor inicial y comenzar√° a reducir en el segundo elemento.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Dxn7muuMkk" href="#c-Dxn7muuMkk" tabindex="-1" role="presentation"></a>console.log([<span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>].reduce((<span class="tok-definition">a</span>, <span class="tok-definition">b</span>) =&gt; a + b));
<span class="tok-comment">// ‚Üí 10</span></pre>

<p><a class="p_ident" id="p-aq58LUBIxu" href="#p-aq58LUBIxu" tabindex="-1" role="presentation"></a>Para usar <code>reduce</code> (dos veces) y encontrar el script con m√°s caracteres, podemos escribir algo as√≠:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-x76Ukt5X+H" href="#c-x76Ukt5X+H" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">characterCount</span>(<span class="tok-definition">script</span>) {
  <span class="tok-keyword">return</span> script.ranges.reduce((<span class="tok-definition">count</span>, [<span class="tok-definition">from</span>, <span class="tok-definition">to</span>]) =&gt; {
    <span class="tok-keyword">return</span> count + (to - from);
  }, <span class="tok-number">0</span>);
}

console.log(SCRIPTS.reduce((<span class="tok-definition">a</span>, <span class="tok-definition">b</span>) =&gt; {
  <span class="tok-keyword">return</span> characterCount(a) &lt; characterCount(b) ? b : a;
}));
<span class="tok-comment">// ‚Üí {name: &quot;Han&quot;, ‚Ä¶}</span></pre>

<p><a class="p_ident" id="p-h4Jk417+fU" href="#p-h4Jk417+fU" tabindex="-1" role="presentation"></a>La funci√≥n <code>characterCount</code> reduce los rangos asignados a un script sumando sus tama√±os. Observa el uso de la desestructuraci√≥n en la lista de par√°metros de la funci√≥n reductora. La segunda llamada a <code>reduce</code> luego utiliza esto para encontrar el script m√°s grande comparando repetidamente dos scripts y devolviendo el m√°s grande.</p>

<p><a class="p_ident" id="p-g8tYIN4Bkz" href="#p-g8tYIN4Bkz" tabindex="-1" role="presentation"></a>El script Han tiene m√°s de 89,000 caracteres asignados en el est√°ndar Unicode, convirti√©ndolo en el sistema de escritura m√°s grande en el conjunto de datos. Han es un script a veces utilizado para texto en chino, japon√©s y coreano. Esos idiomas comparten muchos caracteres, aunque tienden a escribirlos de manera diferente. El Consorcio Unicode (con sede en EE. UU.) decidi√≥ tratarlos como un √∫nico sistema de escritura para ahorrar c√≥digos de caracteres. Esto se llama <em>unificaci√≥n Han</em> y todav√≠a molesta a algunas personas.</p>

<h2><a class="h_ident" id="h-bzPoX82c4F" href="#h-bzPoX82c4F" tabindex="-1" role="presentation"></a>Composabilidad</h2>

<p><a class="p_ident" id="p-bFYtadUC4/" href="#p-bFYtadUC4/" tabindex="-1" role="presentation"></a>{{index bucle, m√°ximo}}</p>

<p><a class="p_ident" id="p-gP2bptAN2f" href="#p-gP2bptAN2f" tabindex="-1" role="presentation"></a>Considera c√≥mo hubi√©ramos escrito el ejemplo anterior (encontrando el script m√°s grande) sin funciones de orden superior. El c√≥digo no es mucho peor:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-1FmIKHNB24" href="#c-1FmIKHNB24" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">biggest</span> = <span class="tok-keyword">null</span>;
<span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">script</span> <span class="tok-keyword">of</span> SCRIPTS) {
  <span class="tok-keyword">if</span> (biggest == <span class="tok-keyword">null</span> ||
      characterCount(biggest) &lt; characterCount(script)) {
    biggest = script;
  }
}
console.log(biggest);
<span class="tok-comment">// ‚Üí {name: &quot;Han&quot;, ‚Ä¶}</span></pre>

<p><a class="p_ident" id="p-EtVmv7i/iI" href="#p-EtVmv7i/iI" tabindex="-1" role="presentation"></a>Hay algunas variables adicionales y el programa tiene cuatro l√≠neas m√°s, pero sigue siendo muy legible.</p>

<p><a class="p_ident" id="p-5fJ9IZD2F1" href="#p-5fJ9IZD2F1" tabindex="-1" role="presentation"></a>{{index ‚Äúfunci√≥n promedio‚Äù, composabilidad, [‚Äúfunci√≥n‚Äù, ‚Äúde orden superior‚Äù], ‚Äúm√©todo filter‚Äù, ‚Äúm√©todo map‚Äù, ‚Äúm√©todo reduce‚Äù}}{{id average_function}}</p>

<p><a class="p_ident" id="p-/CzAZCG1Ww" href="#p-/CzAZCG1Ww" tabindex="-1" role="presentation"></a>Las abstracciones proporcionadas por estas funciones brillan realmente cuando necesitas <em>componer</em> operaciones. Como ejemplo, escribamos un c√≥digo que encuentre el a√±o promedio de origen para scripts vivos y muertos en el conjunto de datos:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-rumPqbzokK" href="#c-rumPqbzokK" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">average</span>(<span class="tok-definition">array</span>) {
  <span class="tok-keyword">return</span> array.reduce((<span class="tok-definition">a</span>, <span class="tok-definition">b</span>) =&gt; a + b) / array.length;
}

console.log(Math.round(average(
  SCRIPTS.filter(<span class="tok-definition">s</span> =&gt; s.living).map(<span class="tok-definition">s</span> =&gt; s.year))));
<span class="tok-comment">// ‚Üí 1165</span>
console.log(Math.round(average(
  SCRIPTS.filter(<span class="tok-definition">s</span> =&gt; !s.living).map(<span class="tok-definition">s</span> =&gt; s.year))));
<span class="tok-comment">// ‚Üí 204</span></pre>

<p><a class="p_ident" id="p-HYrvIekBW0" href="#p-HYrvIekBW0" tabindex="-1" role="presentation"></a>Como puedes ver, los scripts muertos en Unicode son, en promedio, m√°s antiguos que los vivos. Esta no es una estad√≠stica muy significativa o sorprendente. Pero espero que est√©s de acuerdo en que el c√≥digo utilizado para calcularlo no es dif√≠cil de leer. Puedes verlo como un pipeline: empezamos con todos los scripts, filtramos los vivos (o muertos), tomamos los a√±os de esos scripts, calculamos el promedio y redondeamos el resultado.</p>

<p><a class="p_ident" id="p-Z4jAr6ljSn" href="#p-Z4jAr6ljSn" tabindex="-1" role="presentation"></a>Definitivamente tambi√©n podr√≠as escribir este c√°lculo como un √∫nico loop grande:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-noyYOD0Kiy" href="#c-noyYOD0Kiy" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">total</span> = <span class="tok-number">0</span>, <span class="tok-definition">count</span> = <span class="tok-number">0</span>;
<span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">script</span> <span class="tok-keyword">of</span> SCRIPTS) {
  <span class="tok-keyword">if</span> (script.living) {
    total += script.year;
    count += <span class="tok-number">1</span>;
  }
}
console.log(Math.round(total / count));
<span class="tok-comment">// ‚Üí 1165</span></pre>

<p><a class="p_ident" id="p-z1zZ1R3oEN" href="#p-z1zZ1R3oEN" tabindex="-1" role="presentation"></a>Sin embargo, es m√°s dif√≠cil ver qu√© se estaba calculando y c√≥mo. Y debido a que los resultados intermedios no se representan como valores coherentes, ser√≠a mucho m√°s trabajo extraer algo como <code>average</code> en una funci√≥n separada.</p>

<p><a class="p_ident" id="p-JaB+c9Bjg2" href="#p-JaB+c9Bjg2" tabindex="-1" role="presentation"></a>En t√©rminos de lo que realmente est√° haciendo la computadora, estos dos enfoques tambi√©n son bastante diferentes. El primero construir√° nuevos arrays al ejecutar <code>filter</code> y <code>map</code>, mientras que el segundo calcula solo algunos n√∫meros, haciendo menos trabajo. Por lo general, puedes permitirte el enfoque legible, pero si est√°s procesando matrices enormes y haci√©ndolo muchas veces, el estilo menos abstracto podr√≠a valer la pena por la velocidad adicional.</p>

<h2><a class="h_ident" id="h-XPdB1c6gdD" href="#h-XPdB1c6gdD" tabindex="-1" role="presentation"></a>Cadenas y c√≥digos de caracteres</h2>

<p><a class="p_ident" id="p-MXjFCWbW9t" href="#p-MXjFCWbW9t" tabindex="-1" role="presentation"></a>Un uso interesante de este conjunto de datos ser√≠a averiguar qu√© script est√° utilizando un fragmento de texto. Vamos a trav√©s de un programa que hace esto.</p>

<p><a class="p_ident" id="p-GatVMstQav" href="#p-GatVMstQav" tabindex="-1" role="presentation"></a>Recuerda que cada script tiene asociado un array de intervalos de c√≥digos de caracteres. Dado un c√≥digo de car√°cter, podr√≠amos usar una funci√≥n como esta para encontrar el script correspondiente (si lo hay):</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Q8918ecfHn" href="#c-Q8918ecfHn" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">characterScript</span>(<span class="tok-definition">code</span>) {
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">script</span> <span class="tok-keyword">of</span> SCRIPTS) {
    <span class="tok-keyword">if</span> (script.ranges.some(([<span class="tok-definition">from</span>, <span class="tok-definition">to</span>]) =&gt; {
      <span class="tok-keyword">return</span> code &gt;= from &amp;&amp; code &lt; to;
    })) {
      <span class="tok-keyword">return</span> script;
    }
  }
  <span class="tok-keyword">return</span> <span class="tok-keyword">null</span>;
}

console.log(characterScript(<span class="tok-number">121</span>));
<span class="tok-comment">// ‚Üí {name: &quot;Latin&quot;, ‚Ä¶}</span></pre>

<p><a class="p_ident" id="p-hJDL1Q3G7R" href="#p-hJDL1Q3G7R" tabindex="-1" role="presentation"></a>El m√©todo <code>some</code> es otra funci√≥n de orden superior. Toma una funci√≥n de prueba y te dice si esa funci√≥n devuelve true para alguno de los elementos en el array.</p>

<p id="code_units"><a class="p_ident" id="p-xwqTjYNDg/" href="#p-xwqTjYNDg/" tabindex="-1" role="presentation"></a>Pero, ¬øc√≥mo obtenemos los c√≥digos de caracteres en una cadena?</p>

<p><a class="p_ident" id="p-d3EBXodI+B" href="#p-d3EBXodI+B" tabindex="-1" role="presentation"></a>En <a href="01_values.html">Chapter 1</a> mencion√© que las cadenas de JavaScript est√°n codificadas como una secuencia de n√∫meros de 16 bits. Estos se llaman <em>unidades de c√≥digo</em>. Un c√≥digo de car√°cter Unicode inicialmente se supon√≠a que cab√≠a dentro de tal unidad (lo que te da un poco m√°s de 65,000 caracteres). Cuando qued√≥ claro que eso no iba a ser suficiente, muchas personas se mostraron reacias a la necesidad de usar m√°s memoria por car√°cter. Para abordar estas preocupaciones, se invent√≥ UTF-16, el formato tambi√©n utilizado por las cadenas de JavaScript. Describe la mayor√≠a de los caracteres comunes usando una √∫nica unidad de c√≥digo de 16 bits, pero usa un par de dos unidades de dicho tipo para otros.</p>

<p><a class="p_ident" id="p-MP7gPIVpo8" href="#p-MP7gPIVpo8" tabindex="-1" role="presentation"></a>UTF-16 generalmente se considera una mala idea hoy en d√≠a. Parece casi dise√±ado intencionalmente para invitar a errores. Es f√°cil escribir programas que pretendan que las unidades de c√≥digo y los caracteres son lo mismo. Y si tu lenguaje no utiliza caracteres de dos unidades, eso parecer√° funcionar perfectamente. Pero tan pronto como alguien intente usar dicho programa con algunos caracteres chinos menos comunes, fallar√°. Afortunadamente, con la llegada de los emoji, todo el mundo ha comenzado a usar caracteres de dos unidades, y la carga de tratar con tales problemas est√° m√°s equitativamente distribuida.</p>

<p><a class="p_ident" id="p-cIimdGgzlf" href="#p-cIimdGgzlf" tabindex="-1" role="presentation"></a>Lamentablemente, las operaciones obvias en las cadenas de JavaScript, como obtener su longitud a trav√©s de la propiedad <code>length</code> y acceder a su contenido usando corchetes cuadrados, tratan solo con unidades de c√≥digo.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-HNlpl48Xvg" href="#c-HNlpl48Xvg" tabindex="-1" role="presentation"></a><span class="tok-comment">// Dos caracteres emoji, caballo y zapato</span>
<span class="tok-keyword">let</span> <span class="tok-definition">horseShoe</span> = <span class="tok-string">&quot;üê¥üëü&quot;</span>;
console.log(horseShoe.length);
<span class="tok-comment">// ‚Üí 4</span>
console.log(horseShoe[<span class="tok-number">0</span>]);
<span class="tok-comment">// ‚Üí (Mitad de car√°cter inv√°lida)</span>
console.log(horseShoe.charCodeAt(<span class="tok-number">0</span>));
<span class="tok-comment">// ‚Üí 55357 (C√≥digo de la mitad de car√°cter)</span>
console.log(horseShoe.codePointAt(<span class="tok-number">0</span>));
<span class="tok-comment">// ‚Üí 128052 (C√≥digo real para el emoji de caballo)</span></pre>

<p><a class="p_ident" id="p-BS9MJRj/qW" href="#p-BS9MJRj/qW" tabindex="-1" role="presentation"></a>El m√©todo <code>charCodeAt</code> de JavaScript te da una unidad de c√≥digo, no un c√≥digo de car√°cter completo. El m√©todo <code>codePointAt</code>, a√±adido m√°s tarde, s√≠ da un car√°cter Unicode completo, por lo que podr√≠amos usarlo para obtener caracteres de una cadena. Pero el argumento pasado a <code>codePointAt</code> sigue siendo un √≠ndice en la secuencia de unidades de c√≥digo. Para recorrer todos los caracteres en una cadena, a√∫n necesitar√≠amos abordar la cuesti√≥n de si un car√°cter ocupa una o dos unidades de c√≥digo.</p>

<p><a class="p_ident" id="p-+k9Io/S3re" href="#p-+k9Io/S3re" tabindex="-1" role="presentation"></a>En el <a href="datos#bucle_for_of">cap√≠tulo anterior</a>, mencion√© que un bucle <code>for</code>/<code>of</code> tambi√©n se puede usar en cadenas. Al igual que <code>codePointAt</code>, este tipo de bucle se introdujo en un momento en que la gente era muy consciente de los problemas con UTF-16. Cuando lo usas para recorrer una cadena, te proporciona caracteres reales, no unidades de c√≥digo:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-9QIfA1qjtG" href="#c-9QIfA1qjtG" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">roseDragon</span> = <span class="tok-string">&quot;üåπüêâ&quot;</span>;
<span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">char</span> <span class="tok-keyword">of</span> roseDragon) {
  console.log(char);
}
<span class="tok-comment">// ‚Üí üåπ</span>
<span class="tok-comment">// ‚Üí üêâ</span></pre>

<p><a class="p_ident" id="p-crnlwccTvb" href="#p-crnlwccTvb" tabindex="-1" role="presentation"></a>Si tienes un car√°cter (que ser√° una cadena de una o dos unidades de c√≥digo), puedes usar <code>codePointAt(0)</code> para obtener su c√≥digo.</p>

<h2><a class="h_ident" id="h-6v14c/pbJh" href="#h-6v14c/pbJh" tabindex="-1" role="presentation"></a>Reconociendo texto</h2>

<p><a class="p_ident" id="p-US1jun7br4" href="#p-US1jun7br4" tabindex="-1" role="presentation"></a>Tenemos una funci√≥n <code>characterScript</code> y una forma de recorrer correctamente los caracteres. El pr√≥ximo paso es contar los caracteres que pertenecen a cada script. La siguiente abstracci√≥n de conteo ser√° √∫til para eso:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-b8ZEeu/LH5" href="#c-b8ZEeu/LH5" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">countBy</span>(<span class="tok-definition">items</span>, <span class="tok-definition">groupName</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">counts</span> = [];
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">item</span> <span class="tok-keyword">of</span> items) {
    <span class="tok-keyword">let</span> <span class="tok-definition">name</span> = groupName(item);
    <span class="tok-keyword">let</span> <span class="tok-definition">known</span> = counts.find(<span class="tok-definition">c</span> =&gt; c.name == name);
    <span class="tok-keyword">if</span> (!known) {
      counts.push({<span class="tok-definition">name</span>, <span class="tok-definition">count</span>: <span class="tok-number">1</span>});
    } <span class="tok-keyword">else</span> {
      known.count++;
    }
  }
  <span class="tok-keyword">return</span> counts;
}

console.log(countBy([<span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>], <span class="tok-definition">n</span> =&gt; n &gt; <span class="tok-number">2</span>));
<span class="tok-comment">// ‚Üí [{name: false, count: 2}, {name: true, count: 3}]</span></pre>

<p><a class="p_ident" id="p-BkGEda/6+p" href="#p-BkGEda/6+p" tabindex="-1" role="presentation"></a>La funci√≥n <code>countBy</code> espera una colecci√≥n (cualquier cosa por la que podamos iterar con <code>for</code>/<code>of</code>) y una funci√≥n que calcule un nombre de grupo para un elemento dado. Devuelve una matriz de objetos, cada uno de los cuales nombra un grupo y te dice el n√∫mero de elementos que se encontraron en ese grupo.</p>

<p><a class="p_ident" id="p-3D6sEDfZSV" href="#p-3D6sEDfZSV" tabindex="-1" role="presentation"></a>Utiliza otro m√©todo de array, <code>find</code>, que recorre los elementos en el array y devuelve el primero para el cual una funci√≥n devuelve true. Devuelve <code>undefined</code> cuando no se encuentra dicho elemento.</p>

<p><a class="p_ident" id="p-cOB6KMMgRg" href="#p-cOB6KMMgRg" tabindex="-1" role="presentation"></a>Usando <code>countBy</code>, podemos escribir la funci√≥n que nos dice qu√© scripts se utilizan en un fragmento de texto:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-i0Qwg5s1EB" href="#c-i0Qwg5s1EB" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">textScripts</span>(<span class="tok-definition">text</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">scripts</span> = countBy(text, <span class="tok-definition">char</span> =&gt; {
    <span class="tok-keyword">let</span> <span class="tok-definition">script</span> = characterScript(char.codePointAt(<span class="tok-number">0</span>));
    <span class="tok-keyword">return</span> script ? script.name : <span class="tok-string">&quot;ninguno&quot;</span>;
  }).filter(({name}) =&gt; name != <span class="tok-string">&quot;ninguno&quot;</span>);

  <span class="tok-keyword">let</span> <span class="tok-definition">total</span> = scripts.reduce((<span class="tok-definition">n</span>, {count}) =&gt; n + count, <span class="tok-number">0</span>);
  <span class="tok-keyword">if</span> (total == <span class="tok-number">0</span>) <span class="tok-keyword">return</span> <span class="tok-string">&quot;No se encontraron scripts&quot;</span>;

  <span class="tok-keyword">return</span> scripts.map(({name, count}) =&gt; {
    <span class="tok-keyword">return</span> <span class="tok-string2">`</span>${Math.round(count * <span class="tok-number">100</span> / total)}<span class="tok-string2">% </span>${name}<span class="tok-string2">`</span>;
  }).join(<span class="tok-string">&quot;, &quot;</span>);
}

console.log(textScripts(<span class="tok-string">'Ëã±ÂõΩÁöÑÁãóËØ¥&quot;woof&quot;, ‰øÑÁΩóÊñØÁöÑÁãóËØ¥&quot;—Ç—è–≤&quot;'</span>));
<span class="tok-comment">// ‚Üí 61% Han, 22% Latin, 17% Cyrillic</span></pre>

<p><a class="p_ident" id="p-6ZNN+7KNVP" href="#p-6ZNN+7KNVP" tabindex="-1" role="presentation"></a>La funci√≥n primero cuenta los caracteres por nombre, usando <code>characterScript</code> para asignarles un nombre y retrocediendo a la cadena <code>&quot;ninguno&quot;</code> para los caracteres que no forman parte de ning√∫n script. La llamada a <code>filter</code> elimina la entrada de <code>&quot;ninguno&quot;</code> del array resultante, ya que no nos interesan esos caracteres.</p>

<p><a class="p_ident" id="p-z0FN1vM2Io" href="#p-z0FN1vM2Io" tabindex="-1" role="presentation"></a>Para poder calcular porcentajes, primero necesitamos el n√∫mero total de caracteres que pertenecen a un script, lo cual podemos calcular con <code>reduce</code>. Si no se encuentran dichos caracteres, la funci√≥n devuelve una cadena espec√≠fica. De lo contrario, transforma las entradas de conteo en cadenas legibles con <code>map</code> y luego las combina con <code>join</code>.</p>

<h2><a class="h_ident" id="h-NUFOUyK+lw" href="#h-NUFOUyK+lw" tabindex="-1" role="presentation"></a>Resumen</h2>

<p><a class="p_ident" id="p-ua0YBHiMTm" href="#p-ua0YBHiMTm" tabindex="-1" role="presentation"></a>Poder pasar valores de funciones a otras funciones es un aspecto muy √∫til de JavaScript. Nos permite escribir funciones que modelan c√°lculos con ‚Äúvac√≠os‚Äù. El c√≥digo que llama a estas funciones puede llenar los vac√≠os proporcionando valores de funciones.</p>

<p><a class="p_ident" id="p-OvDSlYatKQ" href="#p-OvDSlYatKQ" tabindex="-1" role="presentation"></a>Los arrays proporcionan diversos m√©todos de orden superior √∫tiles. Puedes usar <code>forEach</code> para recorrer los elementos de un array. El m√©todo <code>filter</code> devuelve un nuevo array que contiene solo los elementos que pasan la funci√≥n de predicado. Transformar un array poniendo cada elemento en una funci√≥n se hace con <code>map</code>. Puedes usar <code>reduce</code> para combinar todos los elementos de un array en un √∫nico valor. El m√©todo <code>some</code> comprueba si alg√∫n elemento coincide con una funci√≥n de predicado dada, mientras que <code>find</code> encuentra el primer elemento que coincide con un predicado.</p>

<h2><a class="h_ident" id="h-tkm7ntLto1" href="#h-tkm7ntLto1" tabindex="-1" role="presentation"></a>Ejercicios</h2>

<h3><a class="i_ident" id="i-NYYN2FxNVG" href="#i-NYYN2FxNVG" tabindex="-1" role="presentation"></a>Aplanamiento</h3>

<p><a class="p_ident" id="p-2JTbAIwElU" href="#p-2JTbAIwElU" tabindex="-1" role="presentation"></a>Utiliza el m√©todo <code>reduce</code> en combinaci√≥n con el m√©todo <code>concat</code> para ‚Äúaplanar‚Äù un array de arrays en un √∫nico array que contenga todos los elementos de los arrays originales.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-9vAbUnn21O" href="#c-9vAbUnn21O" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">arrays</span> = [[<span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>], [<span class="tok-number">4</span>, <span class="tok-number">5</span>], [<span class="tok-number">6</span>]];
<span class="tok-comment">// Tu c√≥digo aqu√≠.</span>
<span class="tok-comment">// ‚Üí [1, 2, 3, 4, 5, 6]</span></pre>

<h3><a class="i_ident" id="i-cBnCXoHx6D" href="#i-cBnCXoHx6D" tabindex="-1" role="presentation"></a>Tu propio bucle</h3>

<p><a class="p_ident" id="p-eTd6UCJrnn" href="#p-eTd6UCJrnn" tabindex="-1" role="presentation"></a>Escribe una funci√≥n de orden superior <code>loop</code> que proporcione algo similar a una declaraci√≥n <code>for</code> loop. Deber√≠a recibir un valor, una funci√≥n de prueba, una funci√≥n de actualizaci√≥n y una funci√≥n de cuerpo. En cada iteraci√≥n, primero debe ejecutar la funci√≥n de prueba en el valor actual del bucle y detenerse si devuelve falso. Luego debe llamar a la funci√≥n de cuerpo, d√°ndole el valor actual, y finalmente llamar a la funci√≥n de actualizaci√≥n para crear un nuevo valor y empezar de nuevo desde el principio.</p>

<p><a class="p_ident" id="p-ZjRsh6UWeD" href="#p-ZjRsh6UWeD" tabindex="-1" role="presentation"></a>Al definir la funci√≥n, puedes usar un bucle regular para hacer el bucle real.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Fv1rc97GEM" href="#c-Fv1rc97GEM" tabindex="-1" role="presentation"></a><span class="tok-comment">// Your code here.</span>

loop(<span class="tok-number">3</span>, <span class="tok-definition">n</span> =&gt; n &gt; <span class="tok-number">0</span>, <span class="tok-definition">n</span> =&gt; n - <span class="tok-number">1</span>, console.log);
<span class="tok-comment">// ‚Üí 3</span>
<span class="tok-comment">// ‚Üí 2</span>
<span class="tok-comment">// ‚Üí 1</span></pre>

<h3><a class="i_ident" id="i-SmbRSAd5GA" href="#i-SmbRSAd5GA" tabindex="-1" role="presentation"></a>Everything</h3>

<p><a class="p_ident" id="p-4Pg9vLwvKg" href="#p-4Pg9vLwvKg" tabindex="-1" role="presentation"></a>Los arrays tambi√©n tienen un m√©todo <code>every</code> an√°logo al m√©todo <code>some</code>. Este m√©todo devuelve <code>true</code> cuando la funci√≥n dada devuelve <code>true</code> para <em>cada</em> elemento en el array. En cierto modo, <code>some</code> es una versi√≥n del operador <code>||</code> que act√∫a en arrays, y <code>every</code> es como el operador <code>&amp;&amp;</code>.</p>

<p><a class="p_ident" id="p-pg6rAnmtg7" href="#p-pg6rAnmtg7" tabindex="-1" role="presentation"></a>Implementa <code>every</code> como una funci√≥n que recibe un array y una funci√≥n de predicado como par√°metros. Escribe dos versiones, una usando un bucle y otra usando el m√©todo <code>some</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-NludaTWDls" href="#c-NludaTWDls" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">every</span>(<span class="tok-definition">array</span>, <span class="tok-definition">test</span>) {
  <span class="tok-comment">// Your code here.</span>
}

console.log(every([<span class="tok-number">1</span>, <span class="tok-number">3</span>, <span class="tok-number">5</span>], <span class="tok-definition">n</span> =&gt; n &lt; <span class="tok-number">10</span>));
<span class="tok-comment">// ‚Üí true</span>
console.log(every([<span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">16</span>], <span class="tok-definition">n</span> =&gt; n &lt; <span class="tok-number">10</span>));
<span class="tok-comment">// ‚Üí false</span>
console.log(every([], <span class="tok-definition">n</span> =&gt; n &lt; <span class="tok-number">10</span>));
<span class="tok-comment">// ‚Üí true</span></pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-3C1WcJRJ3U" href="#p-3C1WcJRJ3U" tabindex="-1" role="presentation"></a>Como el operador <code>&amp;&amp;</code>, el m√©todo <code>every</code> puede dejar de evaluar m√°s elementos tan pronto como encuentre uno que no coincida. Por lo tanto, la versi√≥n basada en bucle puede salir del bucle‚Äîcon <code>break</code> o `return‚Äîtan pronto como encuentre un elemento para el que la funci√≥n de predicado devuelva false. Si el bucle se ejecuta hasta el final sin encontrar dicho elemento, sabemos que todos los elementos coincidieron y deber√≠amos devolver true.</p>

<p><a class="p_ident" id="p-Coa0zWQNO0" href="#p-Coa0zWQNO0" tabindex="-1" role="presentation"></a>Para construir <code>every</code> sobre <code>some</code>, podemos aplicar <em>leyes de De Morgan</em>, que establecen que <code>a &amp;&amp; b</code> es igual a <code>!(!a || !b)</code>. Esto se puede generalizar a arrays, donde todos los elementos en el array coinciden si no hay ning√∫n elemento en el array que no coincida.</p>

</div></details>

<h3><a class="i_ident" id="i-kUUDTvgJ6V" href="#i-kUUDTvgJ6V" tabindex="-1" role="presentation"></a>Direcci√≥n de escritura dominante</h3>

<p><a class="p_ident" id="p-wNkAaSiwZs" href="#p-wNkAaSiwZs" tabindex="-1" role="presentation"></a>Escribe una funci√≥n que calcule la direcci√≥n de escritura dominante en una cadena de texto. Recuerda que cada objeto script tiene una propiedad <code>direction</code> que puede ser <code>&quot;ltr&quot;</code> (de izquierda a derecha), <code>&quot;rtl&quot;</code> (de derecha a izquierda) o <code>&quot;ttb&quot;</code> (de arriba a abajo).</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-CNawUvyti3" href="#c-CNawUvyti3" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">dominantDirection</span>(<span class="tok-definition">text</span>) {
  <span class="tok-comment">// Your code here.</span>
}

console.log(dominantDirection(<span class="tok-string">&quot;Hello!&quot;</span>));
<span class="tok-comment">// ‚Üí ltr</span>
console.log(dominantDirection(<span class="tok-string">&quot;Hey, ŸÖÿ≥ÿßÿ° ÿßŸÑÿÆŸäÿ±&quot;</span>));
<span class="tok-comment">// ‚Üí rtl</span></pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-1vPjppobMm" href="#p-1vPjppobMm" tabindex="-1" role="presentation"></a>Tu soluci√≥n podr√≠a parecerse mucho a la primera mitad del ejemplo de <code>textScripts</code>. De nuevo, debes contar caracteres seg√∫n un criterio basado en <code>characterScript</code> y luego filtrar la parte del resultado que se refiere a caracteres no interesantes (sin script).</p>

<p><a class="p_ident" id="p-FrVu7Vg3MC" href="#p-FrVu7Vg3MC" tabindex="-1" role="presentation"></a>Encontrar la direcci√≥n con el recuento de caracteres m√°s alto se puede hacer con <code>reduce</code>. Si no est√° claro c√≥mo hacerlo, consulta el ejemplo anterior en el cap√≠tulo, donde se us√≥ <code>reduce</code> para encontrar el script con m√°s caracteres.</p>

</div></details><nav><a href="04_data.html" title="previous chapter" aria-label="previous chapter">‚óÇ</a>¬†<a href="index.html" title="cover" aria-label="cover">‚óè</a>¬†<a href="06_object.html" title="next chapter" aria-label="next chapter">‚ñ∏</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>
</nav>
</article>

<script src="ejs.js"></script>
