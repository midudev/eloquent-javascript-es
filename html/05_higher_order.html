<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Funciones de Orden Superior :: Eloquent JavaScript</title>
  <link rel=stylesheet href="css/ejs.css"><script>
      var page = {"type":"chapter","number":5,"load_files":["code/scripts.js","code/chapter/05_higher_order.js","code/intro.js"]}</script></head>

<article>
<nav><a href="04_data.html" title="previous chapter" aria-label="previous chapter">‚óÇ</a>¬†<a href="index.html" title="cover" aria-label="cover">‚óè</a>¬†<a href="06_object.html" title="next chapter" aria-label="next chapter">‚ñ∏</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>
</nav>

<h1>Funciones de Orden Superior</h1>

<p><a class="p_ident" id="p-eV2Rh7S+DT" href="#p-eV2Rh7S+DT" tabindex="-1" role="presentation"></a><em>‚ÄúHay dos maneras de construir un dise√±o de software: una forma es hacerlo tan simple que obviamente no haya defectos, y la otra forma es hacerlo tan complicado que no haya defectos obvios.‚Äù</em></p>

<p><a class="p_ident" id="p-rComRYoME7" href="#p-rComRYoME7" tabindex="-1" role="presentation"></a>‚Äî C.A.R. Hoare, <em>Discurso de Recepci√≥n del Premio Turing de la ACM de 1980</em></p>

<p><a class="p_ident" id="p-UkjkuKBNDn" href="#p-UkjkuKBNDn" tabindex="-1" role="presentation"></a>Un programa grande es un programa costoso, y no solo por el tiempo que lleva construirlo. El tama√±o casi siempre implica complejidad, y la complejidad confunde a los programadores. Los programadores confundidos, a su vez, introducen errores (<em>bugs</em>) en los programas. Un programa grande da mucho hueco para que estos errores se escondan, lo que los hace dif√≠ciles de encontrar.</p>

<p><a class="p_ident" id="p-Q033k+pXx6" href="#p-Q033k+pXx6" tabindex="-1" role="presentation"></a>Vamos a volver por un momento a los dos ejemplos de programas del final de la introducci√≥n. El primero es autocontenido y tiene seis l√≠neas:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-NaiLvX4kR2" href="#c-NaiLvX4kR2" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">total</span> = <span class="tok-number">0</span>, <span class="tok-definition">contador</span> = <span class="tok-number">1</span>;
<span class="tok-keyword">while</span> (contador &lt;= <span class="tok-number">10</span>) {
  total += contador;
  contador += <span class="tok-number">1</span>;
}
console.log(total);</pre>

<p><a class="p_ident" id="p-XpPbbvrjf7" href="#p-XpPbbvrjf7" tabindex="-1" role="presentation"></a>El segundo depende de dos funciones externas y tiene una l√≠nea:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-pxsnyeb5dE" href="#c-pxsnyeb5dE" tabindex="-1" role="presentation"></a>console.log(suma(rango(<span class="tok-number">1</span>, <span class="tok-number">10</span>)));</pre>

<p><a class="p_ident" id="p-mQkKtUTj8f" href="#p-mQkKtUTj8f" tabindex="-1" role="presentation"></a>¬øCu√°l es m√°s probable que contenga un error?</p>

<p><a class="p_ident" id="p-kr8iBt6cDE" href="#p-kr8iBt6cDE" tabindex="-1" role="presentation"></a>Si contamos el tama√±o de las definiciones de <code>suma</code> y <code>rango</code>, el segundo programa tambi√©n es grande, incluso m√°s que el primero. Pero, a√∫n as√≠, dir√≠a que es m√°s probable que sea correcto.</p>

<p><a class="p_ident" id="p-DC41zE9LVe" href="#p-DC41zE9LVe" tabindex="-1" role="presentation"></a>Esto se debe a que la soluci√≥n se expresa en un vocabulario que corresponde al problema que se est√° resolviendo. Sumar un intervalo de n√∫meros no va considerar bucles y contadores. Va de intervalos y sumas.</p>

<p><a class="p_ident" id="p-ZVaOtVwzgJ" href="#p-ZVaOtVwzgJ" tabindex="-1" role="presentation"></a>Las definiciones de este vocabulario (las funciones <code>suma</code> y <code>rango</code>) no dejan de consistir en trabajar con bucles, contadores y otros detalles. Pero debido a que expresan conceptos m√°s simples que el programa en su totalidad, son m√°s f√°ciles de hacer correctamente.</p>

<h2><a class="h_ident" id="h-jeqhU5hoax" href="#h-jeqhU5hoax" tabindex="-1" role="presentation"></a>Abstracci√≥n</h2>

<p><a class="p_ident" id="p-b96WneVaDi" href="#p-b96WneVaDi" tabindex="-1" role="presentation"></a>En el contexto de la programaci√≥n, este tipo de vocabularios se suelen llamar <em>abstracciones</em>. Las abstracciones nos brindan la capacidad de hablar sobre problemas a un nivel superior (o m√°s abstracto), sin distraernos con detalles no interesantes.</p>

<p><a class="p_ident" id="p-vujVr5jCqZ" href="#p-vujVr5jCqZ" tabindex="-1" role="presentation"></a>Como analog√≠a, compara estas dos recetas de sopa de guisantes. La primera es as√≠:</p>

<blockquote>

<p><a class="p_ident" id="p-bHDeGVTCo+" href="#p-bHDeGVTCo+" tabindex="-1" role="presentation"></a>Pon 1 taza de guisantes secos por persona en un recipiente. A√±ade agua hasta que los guisantes est√©n bien cubiertos. Deja los guisantes en agua durante al menos 12 horas. Saca los guisantes del agua y ponlos en una olla. Agrega 4 tazas de agua por persona. Cubre la olla y deja los guisantes cociendo a fuego lento durante dos horas. Toma media cebolla por persona. C√≥rtala en trozos con un cuchillo. Agr√©gala a los guisantes. Toma un tallo de apio por persona. C√≥rtalo en trozos con un cuchillo. Agr√©galo a los guisantes. Toma una zanahoria por persona. ¬°C√≥rtala en trozos! ¬°Con un cuchillo! Agr√©gala a los guisantes. Cocina durante 10 minutos m√°s.</p>

</blockquote>

<p><a class="p_ident" id="p-dL6mnA4R6A" href="#p-dL6mnA4R6A" tabindex="-1" role="presentation"></a>Y esta es la segunda receta:</p>

<blockquote>

<p><a class="p_ident" id="p-tZ51jSgceM" href="#p-tZ51jSgceM" tabindex="-1" role="presentation"></a>Por persona: 1 taza de guisantes partidos secos, 4 tazas de agua, media cebolla picada, un tallo de apio y una zanahoria.</p>

<p><a class="p_ident" id="p-pWLdoICo3H" href="#p-pWLdoICo3H" tabindex="-1" role="presentation"></a>Remoja los guisantes durante 12 horas. Cocina a fuego lento durante 2 horas. Pica y agrega las verduras. Cocina durante 10 minutos m√°s.</p>

</blockquote>

<p><a class="p_ident" id="p-d9+qq62FnP" href="#p-d9+qq62FnP" tabindex="-1" role="presentation"></a>La segunda es m√°s corta y f√°cil de interpretar. Pero necesitas entender algunas palabras m√°s relacionadas con la cocina, como <em>remojar</em>, <em>cocinar a fuego lento</em>, <em>picar</em>, y, supongo, <em>verdura</em>.</p>

<p><a class="p_ident" id="p-qhHkdQl/il" href="#p-qhHkdQl/il" tabindex="-1" role="presentation"></a>Cuando se programa, no podemos depender de que todas las palabras que necesitamos est√©n ya escritas en el diccionario para nosotros. Por lo tanto, podr√≠amos caer en el patr√≥n de la primera receta: ejecutar los pasos precisos que la computadora tiene que realizar, uno por uno, sin atender a los conceptos de m√°s alto nivel que expresan.</p>

<p><a class="p_ident" id="p-k17Wm3bRzR" href="#p-k17Wm3bRzR" tabindex="-1" role="presentation"></a>Una habilidad √∫til en programaci√≥n es darse cuenta de cu√°ndo se est√° trabajando a un muy bajo nivel de abstracci√≥n.</p>

<h2><a class="h_ident" id="h-3uF6LnSOqd" href="#h-3uF6LnSOqd" tabindex="-1" role="presentation"></a>Abstraer la repetici√≥n</h2>

<p><a class="p_ident" id="p-ycCWB39qtV" href="#p-ycCWB39qtV" tabindex="-1" role="presentation"></a>Funciones simples como las hemos visto hasta ahora son una buena manera de construir abstracciones. Pero a veces se quedan cortas.</p>

<p><a class="p_ident" id="p-S9ZNhpazRV" href="#p-S9ZNhpazRV" tabindex="-1" role="presentation"></a>Es com√∫n que un programa haga algo una cantidad determinada de veces. Puedes escribir un <code>for</code> para eso, as√≠:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-5c+C2+9IG1" href="#c-5c+C2+9IG1" tabindex="-1" role="presentation"></a><span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; i &lt; <span class="tok-number">10</span>; i++) {
  console.log(i);
}</pre>

<p><a class="p_ident" id="p-mYLOzu14uu" href="#p-mYLOzu14uu" tabindex="-1" role="presentation"></a>¬øPodemos abstraer ‚Äúhacer algo <em>N</em> veces‚Äù como una funci√≥n? Bueno, es f√°cil escribir una funci√≥n que llame a <code>console.log</code> <em>N</em> veces:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-01lxFf/pce" href="#c-01lxFf/pce" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">repetirLog</span>(<span class="tok-definition">n</span>) {
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; i &lt; n; i++) {
    console.log(i);
  }
}</pre>

<p><a class="p_ident" id="p-aHRJYV9dtZ" href="#p-aHRJYV9dtZ" tabindex="-1" role="presentation"></a>¬øY si queremos hacer algo que no sea solo pintar los los n√∫meros? Dado que ‚Äúhacer algo‚Äù se puede representar como una funci√≥n y las funciones son solo valores, podemos pasar nuestra acci√≥n como un valor de funci√≥n:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-PTLJYIA4FA" href="#c-PTLJYIA4FA" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">repetir</span>(<span class="tok-definition">n</span>, <span class="tok-definition">acci√≥n</span>) {
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; i &lt; n; i++) {
    acci√≥n(i);
  }
}

repetir(<span class="tok-number">3</span>, console.log);
<span class="tok-comment">// ‚Üí 0</span>
<span class="tok-comment">// ‚Üí 1</span>
<span class="tok-comment">// ‚Üí 2</span></pre>

<p><a class="p_ident" id="p-MZU1WHGlo3" href="#p-MZU1WHGlo3" tabindex="-1" role="presentation"></a>No tenemos que pasar una funci√≥n predefinida a <code>repetir</code>. A menudo, es m√°s f√°cil crear un valor de funci√≥n en el momento:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-61hbFnWHXS" href="#c-61hbFnWHXS" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">etiquetas</span> = [];
repetir(<span class="tok-number">5</span>, <span class="tok-definition">x</span> =&gt; {
  etiquetas.push(<span class="tok-string2">`Unidad </span>${x + <span class="tok-number">1</span>}<span class="tok-string2">`</span>);
});
console.log(etiquetas);
<span class="tok-comment">// ‚Üí [&quot;Unidad 1&quot;, &quot;Unidad 2&quot;, &quot;Unidad 3&quot;, &quot;Unidad 4&quot;, &quot;Unidad 5&quot;]</span></pre>

<div class="translator-note"><p><strong>N. del T.:</strong> Con respecto a la versi√≥n original del texto, se ha cambiado el nombre del par√°metro en la funci√≥n flecha de <code>i</code> a <code>x</code> para enfatizar la no necesidad de que el par√°metro de dicha funci√≥n se llame como el par√°metro contador del bucle for de la implementaci√≥n de la funci√≥n <code>repetir</code>.</p>
</div>

<p><a class="p_ident" id="p-ZaxR2WEHob" href="#p-ZaxR2WEHob" tabindex="-1" role="presentation"></a>Esto est√° estructurado un poco como un bucle <code>for</code>: primero describe el tipo de bucle y luego proporciona un cuerpo. Sin embargo, el cuerpo ahora est√° escrito como un valor de funci√≥n, que est√° envuelto entre los par√©ntesis de la llamada a <code>repetir</code>. Por eso tiene que cerrarse con el corchete de cierre <em>y</em> el par√©ntesis de cierre. En casos como este ejemplo donde el cuerpo es una sola expresi√≥n peque√±a, tambi√©n podr√≠as omitir los corchetes y escribir el bucle en una sola l√≠nea.</p>

<h2><a class="h_ident" id="h-sBm/RoOmVE" href="#h-sBm/RoOmVE" tabindex="-1" role="presentation"></a>Funciones de orden superior</h2>

<p><a class="p_ident" id="p-mB+p2eklnH" href="#p-mB+p2eklnH" tabindex="-1" role="presentation"></a>Las funciones que operan sobre otras funciones, ya sea tom√°ndolas como argumentos o devolvi√©ndolas, se llaman <em>funciones de orden superior</em>. Dado que ya hemos visto que las funciones son valores como cualquier otro, no hay nada particularmente notable en el hecho de que existan tales funciones. El t√©rmino proviene de las matem√°ticas, donde se toma m√°s en serio la distinci√≥n entre funciones y otros valores.</p>

<p><a class="p_ident" id="p-sGlpxAbe6R" href="#p-sGlpxAbe6R" tabindex="-1" role="presentation"></a>Las funciones de orden superior nos permiten abstraer <em>acciones</em>, no solo valores. Las hay de muchas formas. Por ejemplo, podemos tener funciones que crean nuevas funciones:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-yl26zgd/Q+" href="#c-yl26zgd/Q+" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">mayorQue</span>(<span class="tok-definition">n</span>) {
  <span class="tok-keyword">return</span> <span class="tok-definition">m</span> =&gt; m &gt; n;
}
<span class="tok-keyword">let</span> <span class="tok-definition">mayorQue10</span> = mayorQue(<span class="tok-number">10</span>);
console.log(mayorQue10(<span class="tok-number">11</span>));
<span class="tok-comment">// ‚Üí true</span></pre>

<p><a class="p_ident" id="p-ZzQufg6k7a" href="#p-ZzQufg6k7a" tabindex="-1" role="presentation"></a>Tambi√©n podemos tener funciones que modifican otras funciones:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-x5IWKK9iS2" href="#c-x5IWKK9iS2" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">ruidosa</span>(<span class="tok-definition">f</span>) {
  <span class="tok-keyword">return</span> (...<span class="tok-definition">args</span>) =&gt; {
    console.log(<span class="tok-string">&quot;llamando con&quot;</span>, args);
    <span class="tok-keyword">let</span> <span class="tok-definition">resultado</span> = f(...args);
    console.log(<span class="tok-string">&quot;llamado con&quot;</span>, args, <span class="tok-string">&quot;, devolvi√≥&quot;</span>, resultado);
    <span class="tok-keyword">return</span> resultado;
  };
}
ruidosa(Math.min)(<span class="tok-number">3</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>);
<span class="tok-comment">// ‚Üí llamando con [3, 2, 1]</span>
<span class="tok-comment">// ‚Üí llamado con [3, 2, 1] , devolvi√≥ 1</span></pre>

<p><a class="p_ident" id="p-XsceS57yr8" href="#p-XsceS57yr8" tabindex="-1" role="presentation"></a>Incluso podemos escribir funciones que proveen nuevos tipos de flujo de control:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-nuRXUnBX/r" href="#c-nuRXUnBX/r" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">aMenosQue</span>(<span class="tok-definition">prueba</span>, <span class="tok-definition">entonces</span>) {
  <span class="tok-keyword">if</span> (!prueba) entonces();
}

repetir(<span class="tok-number">3</span>, <span class="tok-definition">n</span> =&gt; {
  aMenosQue(n % <span class="tok-number">2</span> == <span class="tok-number">1</span>, () =&gt; {
    console.log(n, <span class="tok-string">&quot;es par&quot;</span>);
  });
});
<span class="tok-comment">// ‚Üí 0 es par</span>
<span class="tok-comment">// ‚Üí 2 es par</span></pre>

<p><a class="p_ident" id="p-Zjga2rFofq" href="#p-Zjga2rFofq" tabindex="-1" role="presentation"></a>Existe un m√©todo ya incorporado en los arrays, <code>forEach</code>, que proporciona algo similar a un bucle <code>for</code>/<code>of</code> como una funci√≥n de orden superior:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-v9jL6NafRj" href="#c-v9jL6NafRj" tabindex="-1" role="presentation"></a>[<span class="tok-string">&quot;A&quot;</span>, <span class="tok-string">&quot;B&quot;</span>].forEach(<span class="tok-definition">l</span> =&gt; console.log(l));
<span class="tok-comment">// ‚Üí A</span>
<span class="tok-comment">// ‚Üí B</span></pre>

<h2 id="scripts"><a class="h_ident" id="h-OdHcd1haxZ" href="#h-OdHcd1haxZ" tabindex="-1" role="presentation"></a>Conjunto de datos de sistemas de escritura</h2>

<p><a class="p_ident" id="p-nLcvnbV7JQ" href="#p-nLcvnbV7JQ" tabindex="-1" role="presentation"></a>Un √°rea donde las funciones de orden superior destacan es en el procesamiento de datos. Para procesar datos, vamos a necesitar algunos datos de ejemplo. Este cap√≠tulo utilizar√° un conjunto de datos sobre sistemas de escritura tales como el lat√≠n, cir√≠lico o √°rabe.</p>

<p><a class="p_ident" id="p-QWRc3oEeB3" href="#p-QWRc3oEeB3" tabindex="-1" role="presentation"></a>¬øRecuerdas Unicode del <a href="01_values.html#unicode">Cap√≠tulo 1</a>, el sistema que asigna un n√∫mero a cada car√°cter en lenguaje escrito? La mayor√≠a de estos caracteres est√°n asociados con un sistema de escritura concreto. El est√°ndar contiene 140 sistemas diferentes, de los cuales 81 a√∫n se utilizan hoy en d√≠a y 59 son hist√≥ricos.</p>

<p><a class="p_ident" id="p-Y+uBE+NY1X" href="#p-Y+uBE+NY1X" tabindex="-1" role="presentation"></a>Aunque solo puedo leer con fluidez caracteres latinos, aprecio el hecho de que las personas est√©n escribiendo textos en al menos otros 80 sistemas de escritura, muchos de los cuales ni siquiera reconocer√≠a. Por ejemplo, aqu√≠ tienes una muestra de escritura Tamil:</p><figure><img src="img/tamil.png" alt="Una l√≠nea de verso en escritura Tamil. Los caracteres son relativamente simples y separados ordenadamente, pero completamente diferentes de los caracteres latinos."></figure>

<p><a class="p_ident" id="p-ELQZberUtO" href="#p-ELQZberUtO" tabindex="-1" role="presentation"></a>El conjunto de datos de ejemplo contiene informaci√≥n sobre los 140 sistemas de escritura definidos en Unicode. Est√° disponible en el <a href="https://eloquentjavascript.net/code#5">sandbox de c√≥digo</a> para este cap√≠tulo como la asociaci√≥n de nombre <code>SCRIPTS</code>. La variable contiene un array de objetos, cada uno describiendo un sistema de escritura:</p>

<pre class="snippet" data-language="json" ><a class="c_ident" id="c-YkfuyBG2fl" href="#c-YkfuyBG2fl" tabindex="-1" role="presentation"></a>{
  <span class="tok-definition">name</span>: <span class="tok-string">&quot;Coptic&quot;</span>,
  <span class="tok-definition">ranges</span>: [[<span class="tok-number">994</span>, <span class="tok-number">1008</span>], [<span class="tok-number">11392</span>, <span class="tok-number">11508</span>], [<span class="tok-number">11513</span>, <span class="tok-number">11520</span>]],
  <span class="tok-definition">direction</span>: <span class="tok-string">&quot;ltr&quot;</span>,
  <span class="tok-definition">year</span>: -<span class="tok-number">200</span>,
  <span class="tok-definition">living</span>: false,
  <span class="tok-definition">link</span>: <span class="tok-string">&quot;https://en.wikipedia.org/wiki/Coptic_alphabet&quot;</span>
}</pre>

<p><a class="p_ident" id="p-ua08rL6DL0" href="#p-ua08rL6DL0" tabindex="-1" role="presentation"></a>Tal objeto nos informa sobre el nombre del sistema de lenguaje, los rangos Unicode asignados a √©l, la direcci√≥n en la que se escribe, el momento de origen (aproximado), si todav√≠a se utiliza, y un enlace a m√°s informaci√≥n. La direcci√≥n puede ser <code>&quot;ltr&quot;</code> para izquierda a derecha, <code>&quot;rtl&quot;</code> para derecha a izquierda (como se escribe el texto en √°rabe y hebreo) o <code>&quot;ttb&quot;</code> para arriba hacia abajo (como en la escritura mongola).</p>

<p><a class="p_ident" id="p-DoOVtob5DG" href="#p-DoOVtob5DG" tabindex="-1" role="presentation"></a>La propiedad <code>ranges</code> contiene un array de rangos de caracteres Unicode, cada uno de los cuales es un array de dos elementos que contiene un l√≠mite inferior y un l√≠mite superior. Todos los c√≥digos de caracteres dentro de estos rangos se asignan al sistema de escritura en cuesti√≥n. El l√≠mite inferior es inclusivo (el c√≥digo 994 es un car√°cter copto) y el l√≠mite superior es no inclusivo (el c√≥digo 1008 no lo es).</p>

<h2><a class="h_ident" id="h-MtcnrMCox6" href="#h-MtcnrMCox6" tabindex="-1" role="presentation"></a>Filtrado de arrays</h2>

<p><a class="p_ident" id="p-lJs1/KLSN1" href="#p-lJs1/KLSN1" tabindex="-1" role="presentation"></a>Si queremos encontrar en el conjunto de datos qu√© sistemas de escritura todav√≠a se utilizan, la siguiente funci√≥n puede ser √∫til. Deja fuera los elementos de un array que no cumplen una cierta comprobaci√≥n.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-lyHwMa/zZ6" href="#c-lyHwMa/zZ6" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">filtrar</span>(<span class="tok-definition">array</span>, <span class="tok-definition">comprobaci√≥n</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">pasada</span> = [];
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">elemento</span> <span class="tok-keyword">of</span> array) {
    <span class="tok-keyword">if</span> (comprobaci√≥n(elemento)) {
      pasada.push(elemento);
    }
  }
  <span class="tok-keyword">return</span> pasada;
}

console.log(filtrar(SCRIPTS, <span class="tok-definition">sistema</span> =&gt; sistema.living));
<span class="tok-comment">// ‚Üí [{name: &quot;Adlam&quot;, ‚Ä¶}, ‚Ä¶]</span></pre>

<p><a class="p_ident" id="p-vqNV3Gw5Wz" href="#p-vqNV3Gw5Wz" tabindex="-1" role="presentation"></a>La funci√≥n utiliza el argumento llamado <code>comprobaci√≥n</code>, un valor de funci√≥n, para llenar un ‚Äúhueco‚Äù en el procedimiento de filtrado: el proceso de decidir qu√© elementos recopilar.</p>

<p><a class="p_ident" id="p-rDTRpRs2b7" href="#p-rDTRpRs2b7" tabindex="-1" role="presentation"></a>Observa c√≥mo la funci√≥n <code>filtrar</code>, en lugar de eliminar elementos de la matriz existente, construye una nueva matriz con solo los elementos que pasan la prueba. Esta funci√≥n es <em>pura</em>. No modifica la matriz que se le pasa.</p>

<p><a class="p_ident" id="p-mflQRYwRQo" href="#p-mflQRYwRQo" tabindex="-1" role="presentation"></a>Al igual que con <code>forEach</code>, hay un m√©todo est√°ndar para <code>filtrar</code> en los arrays, el m√©todo <code>filter</code>. En el ejemplo se define la funci√≥n solo para mostrar qu√© hace internamente. De ahora en adelante, lo usaremos de esta manera en su lugar:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-x8e0PmGGB1" href="#c-x8e0PmGGB1" tabindex="-1" role="presentation"></a>console.log(SCRIPTS.filter(<span class="tok-definition">s</span> =&gt; s.direction == <span class="tok-string">&quot;ttb&quot;</span>));
<span class="tok-comment">// ‚Üí [{name: &quot;Mongolian&quot;, ‚Ä¶}, ‚Ä¶]</span></pre>

<h2 id="map"><a class="h_ident" id="h-S3rmMrmWka" href="#h-S3rmMrmWka" tabindex="-1" role="presentation"></a>Transformaci√≥n con map</h2>

<p><a class="p_ident" id="p-ydEMpih2aw" href="#p-ydEMpih2aw" tabindex="-1" role="presentation"></a>Digamos que tenemos un array de objetos que representan sistemas de escritura, producido al filtrar el array <code>SCRIPTS</code> de alguna manera. En su lugar, queremos un array de nombres, que es m√°s f√°cil de inspeccionar.</p>

<p><a class="p_ident" id="p-eEu8IlZwFm" href="#p-eEu8IlZwFm" tabindex="-1" role="presentation"></a>El m√©todo <code>map</code> transforma un array aplicando una funci√≥n a todos sus elementos y construyendo un nuevo array a partir de los valores devueltos. El nuevo array tendr√° la misma longitud que el de entrada, pero su contenido habr√° sido <em>mapeado</em> a una nueva forma por la funci√≥n:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-HNoE2R2koX" href="#c-HNoE2R2koX" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">mapear</span>(<span class="tok-definition">array</span>, <span class="tok-definition">transformaci√≥n</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">mapeados</span> = [];
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">elemento</span> <span class="tok-keyword">of</span> array) {
    mapeados.push(transformaci√≥n(elemento));
  }
  <span class="tok-keyword">return</span> mapeados;
}

<span class="tok-keyword">let</span> <span class="tok-definition">rtlScripts</span> = SCRIPTS.filter(<span class="tok-definition">s</span> =&gt; s.direction == <span class="tok-string">&quot;rtl&quot;</span>);
console.log(mapear(rtlScripts, <span class="tok-definition">s</span> =&gt; s.name));
<span class="tok-comment">// ‚Üí [&quot;Adlam&quot;, &quot;Arabic&quot;, &quot;Imperial Aramaic&quot;, ‚Ä¶]</span></pre>

<p><a class="p_ident" id="p-0CRJOsl5nV" href="#p-0CRJOsl5nV" tabindex="-1" role="presentation"></a>Al igual que <code>forEach</code> y <code>filter</code>, hay un m√©todo est√°ndar para <code>mapear</code> en los arrays, el m√©todo <code>map</code>.</p>

<h2><a class="h_ident" id="h-ddK/7bb9/9" href="#h-ddK/7bb9/9" tabindex="-1" role="presentation"></a>Resumiendo con reduce</h2>

<p><a class="p_ident" id="p-0sSdjIXjkE" href="#p-0sSdjIXjkE" tabindex="-1" role="presentation"></a>Otra cosa com√∫n que hacer con arrays es calcular un √∫nico valor a partir de ellos. Nuestro ejemplo de siempre, sumar una colecci√≥n de n√∫meros, es una ejemplo de esto. Otro ejemplo es encontrar el sistema de escritura con m√°s caracteres.</p>

<p><a class="p_ident" id="p-EiDL8H6ZNm" href="#p-EiDL8H6ZNm" tabindex="-1" role="presentation"></a>La operaci√≥n de orden superior que representa esta idea se llama <em>reduce</em> (a veces tambi√©n llamada <em>fold</em>). Construye un valor tomando repetidamente un √∫nico elemento del array y combin√°ndolo con el valor actual. Al sumar n√∫meros empezar√≠as con el n√∫mero cero y a√±adir√≠as cada elemento a la suma.</p>

<p><a class="p_ident" id="p-zhoVactJlx" href="#p-zhoVactJlx" tabindex="-1" role="presentation"></a>Los par√°metros de <code>reduce</code> son, adem√°s del array, una funci√≥n de combinaci√≥n y un valor inicial. Esta funci√≥n es un poco menos directa que <code>filter</code> y <code>map</code>, as√≠ que obs√©rva detenidamente:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-MPEcux0ztP" href="#c-MPEcux0ztP" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">reducir</span>(<span class="tok-definition">array</span>, <span class="tok-definition">combinaci√≥n</span>, <span class="tok-definition">principio</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">actual</span> = inicio;
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">elemento</span> <span class="tok-keyword">of</span> array) {
    actual = combinaci√≥n(actual, elemento);
  }
  <span class="tok-keyword">return</span> actual;
}

console.log(reducir([<span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>], (<span class="tok-definition">a</span>, <span class="tok-definition">b</span>) =&gt; a + b, <span class="tok-number">0</span>));
<span class="tok-comment">// ‚Üí 10</span></pre>

<p><a class="p_ident" id="p-tSi+CnrI8e" href="#p-tSi+CnrI8e" tabindex="-1" role="presentation"></a>El m√©todo est√°ndar de arrays, <code>reduce</code> ‚Äîque por supuesto corresponde a esta funci√≥n‚Äî tiene una ventaja adicional. Si tu array contiene al menos un elemento, puedes omitir el argumento <code>start</code>. El m√©todo tomar√° el primer elemento del array como su valor inicial y comenzar√° a reducir en el segundo elemento.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Dxn7muuMkk" href="#c-Dxn7muuMkk" tabindex="-1" role="presentation"></a>console.log([<span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>].reduce((<span class="tok-definition">a</span>, <span class="tok-definition">b</span>) =&gt; a + b));
<span class="tok-comment">// ‚Üí 10</span></pre>

<p><a class="p_ident" id="p-aq58LUBIxu" href="#p-aq58LUBIxu" tabindex="-1" role="presentation"></a>Para usar <code>reduce</code> (dos veces) y encontrar el sistema de escritura con m√°s caracteres, podemos escribir algo as√≠:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-9muvALBVGr" href="#c-9muvALBVGr" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">contarCaracteres</span>(<span class="tok-definition">sistema</span>) {
  <span class="tok-keyword">return</span> sistema.ranges.reduce((<span class="tok-definition">contador</span>, [<span class="tok-definition">desde</span>, <span class="tok-definition">hasta</span>]) =&gt; {
    <span class="tok-keyword">return</span> contador + (hasta - desde);
  }, <span class="tok-number">0</span>);
}

console.log(SCRIPTS.reduce((<span class="tok-definition">a</span>, <span class="tok-definition">b</span>) =&gt; {
  <span class="tok-keyword">return</span> contarCaracteres(a) &lt; contarCaracteres(b) ? b : a;
}));
<span class="tok-comment">// ‚Üí {name: &quot;Han&quot;, ‚Ä¶}</span></pre>

<p><a class="p_ident" id="p-h4Jk417+fU" href="#p-h4Jk417+fU" tabindex="-1" role="presentation"></a>La funci√≥n <code>contarCaracteres</code> reduce los rangos asignados a un sistema de escritura sumando sus tama√±os. Observa el uso de la desestructuraci√≥n en la lista de par√°metros de la funci√≥n reductora. La segunda llamada a <code>reduce</code> luego utiliza esto para encontrar el sistema de escritura m√°s grande comparando repetidamente dos sistemas y devolviendo el m√°s grande.</p>

<p><a class="p_ident" id="p-lRRvnFoqP7" href="#p-lRRvnFoqP7" tabindex="-1" role="presentation"></a>El sistema de escritura Han (es decir, el sistema de escritura chino actual) tiene m√°s de 89000 caracteres asignados en el est√°ndar Unicode, convirti√©ndolo en el sistema de escritura m√°s grande del conjunto de datos. El sistema Han es un sistema a veces utilizado para texto en chino, japon√©s y coreano. Estos idiomas comparten muchos caracteres, aunque tienden a escribirlos de manera diferente. El Consorcio Unicode (con sede en EE. UU.) decidi√≥ tratarlos como un √∫nico sistema de escritura para ahorrar c√≥digos de caracteres. Esto se llama <em>unificaci√≥n Han</em> y a√∫n hay gente que no est√° muy contenta con ella.</p>

<h2><a class="h_ident" id="h-bzPoX82c4F" href="#h-bzPoX82c4F" tabindex="-1" role="presentation"></a>Composabilidad</h2>

<p><a class="p_ident" id="p-077XGN/TLg" href="#p-077XGN/TLg" tabindex="-1" role="presentation"></a>Considera c√≥mo hubi√©ramos escrito el ejemplo anterior (encontrar el sistema m√°s grande) sin funciones de orden superior. El c√≥digo no es tan inferior al anterior.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-vfhIpzue2u" href="#c-vfhIpzue2u" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">m√°sGrande</span> = <span class="tok-keyword">null</span>;
<span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">sistema</span> <span class="tok-keyword">of</span> SCRIPTS) {
  <span class="tok-keyword">if</span> (m√°sGrande == <span class="tok-keyword">null</span> ||
      contarCaracteres(m√°sGrande) &lt; contarCaracteres(sistema)) {
    m√°sGrande = sistema;
  }
}
console.log(m√°sGrande);
<span class="tok-comment">// ‚Üí {name: &quot;Han&quot;, ‚Ä¶}</span></pre>

<p><a class="p_ident" id="p-EtVmv7i/iI" href="#p-EtVmv7i/iI" tabindex="-1" role="presentation"></a>Hay algunas variables m√°s y el programa tiene cuatro l√≠neas m√°s, pero sigue siendo muy legible.</p>

<p id="average_function"><a class="p_ident" id="p-/CzAZCG1Ww" href="#p-/CzAZCG1Ww" tabindex="-1" role="presentation"></a>Las abstracciones proporcionadas por estas funciones brillan realmente cuando necesitas <em>componer</em> operaciones. Como ejemplo, escribamos un c√≥digo que encuentre el a√±o promedio de origen para sistemas vivos y muertos en el conjunto de datos:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-DlxRx+dU7R" href="#c-DlxRx+dU7R" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">promedio</span>(<span class="tok-definition">array</span>) {
  <span class="tok-keyword">return</span> array.reduce((<span class="tok-definition">a</span>, <span class="tok-definition">b</span>) =&gt; a + b) / array.length;
}

console.log(Math.round(promedio(
  SCRIPTS.filter(<span class="tok-definition">s</span> =&gt; s.living).map(<span class="tok-definition">s</span> =&gt; s.year))));
<span class="tok-comment">// ‚Üí 1165</span>
console.log(Math.round(promedio(
  SCRIPTS.filter(<span class="tok-definition">s</span> =&gt; !s.living).map(<span class="tok-definition">s</span> =&gt; s.year))));
<span class="tok-comment">// ‚Üí 204</span></pre>

<p><a class="p_ident" id="p-HYrvIekBW0" href="#p-HYrvIekBW0" tabindex="-1" role="presentation"></a>Como puedes ver, los sistemas de escritura muertos en Unicode son, en promedio, m√°s antiguos que los vivos. Esta no es una estad√≠stica muy significativa o sorprendente. Pero espero que est√©s de acuerdo en que el c√≥digo utilizado para calcularlo no es dif√≠cil de leer. Puedes verlo como una cadena de procesos (pipeline): empezamos con todos los sistemas, filtramos los vivos (o muertos), tomamos los a√±os de esos sistemas, calculamos el promedio y redondeamos el resultado.</p>

<p><a class="p_ident" id="p-KGXXlw/EvR" href="#p-KGXXlw/EvR" tabindex="-1" role="presentation"></a>Definitivamente tambi√©n podr√≠as escribir este c√°lculo como un √∫nico bucle grande:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-rI3MU9TnSK" href="#c-rI3MU9TnSK" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">total</span> = <span class="tok-number">0</span>, <span class="tok-definition">contador</span> = <span class="tok-number">0</span>;
<span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">sistema</span> <span class="tok-keyword">of</span> SCRIPTS) {
  <span class="tok-keyword">if</span> (sistema.living) {
    total += sistema.year;
    contador += <span class="tok-number">1</span>;
  }
}
console.log(Math.round(total / contador));
<span class="tok-comment">// ‚Üí 1165</span></pre>

<p><a class="p_ident" id="p-z1zZ1R3oEN" href="#p-z1zZ1R3oEN" tabindex="-1" role="presentation"></a>Sin embargo, es m√°s dif√≠cil ver qu√© se estaba calculando y c√≥mo. Y como los resultados intermedios no se representan como valores coherentes, ser√≠a mucho m√°s trabajo extraer algo como el <code>promedio</code> en una funci√≥n separada.</p>

<p><a class="p_ident" id="p-PY6JQfUdBq" href="#p-PY6JQfUdBq" tabindex="-1" role="presentation"></a>En t√©rminos de lo que realmente est√° haciendo la computadora, estos dos enfoques tambi√©n son bastante distintos. El primero construir√° nuevos arrays al ejecutar <code>filter</code> y <code>map</code>, mientras que el segundo calcula solo algunos n√∫meros, haciendo menos trabajo. Por lo general, puedes permitirte el enfoque legible, pero si est√°s procesando arrays enormes y haci√©ndolo muchas veces, un estilo menos abstracto podr√≠a valer la pena a cambio de velocidad adicional.</p>

<h2><a class="h_ident" id="h-XPdB1c6gdD" href="#h-XPdB1c6gdD" tabindex="-1" role="presentation"></a>Cadenas y c√≥digos de caracteres</h2>

<p><a class="p_ident" id="p-MXjFCWbW9t" href="#p-MXjFCWbW9t" tabindex="-1" role="presentation"></a>Un uso interesante de este conjunto de datos ser√≠a averiguar qu√© sistema de escritura est√° utilizando un fragmento de texto. Veamos un programa que hace esto.</p>

<p><a class="p_ident" id="p-GatVMstQav" href="#p-GatVMstQav" tabindex="-1" role="presentation"></a>Recuerda que cada sistema de escritura tiene asociado un array de intervalos de c√≥digos de caracteres. Dado un c√≥digo de car√°cter, podr√≠amos usar una funci√≥n como esta para encontrar el sistema correspondiente (si lo hay):</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-R9pXaLnTza" href="#c-R9pXaLnTza" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">sistemaCaracteres</span>(<span class="tok-definition">c√≥digo</span>) {
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">sistema</span> <span class="tok-keyword">of</span> SCRIPTS) {
    <span class="tok-keyword">if</span> (sistema.ranges.some(([<span class="tok-definition">desde</span>, <span class="tok-definition">hasta</span>]) =&gt; {
      <span class="tok-keyword">return</span> c√≥digo &gt;= desde &amp;&amp; c√≥digo &lt; hasta;
    })) {
      <span class="tok-keyword">return</span> sistema;
    }
  }
  <span class="tok-keyword">return</span> <span class="tok-keyword">null</span>;
}

console.log(sistemaCaracteres(<span class="tok-number">121</span>));
<span class="tok-comment">// ‚Üí {name: &quot;Latin&quot;, ‚Ä¶}</span></pre>

<p><a class="p_ident" id="p-hJDL1Q3G7R" href="#p-hJDL1Q3G7R" tabindex="-1" role="presentation"></a>El m√©todo <code>some</code> es otra funci√≥n de orden superior. Toma una funci√≥n de comprobaci√≥n y te dice si esa funci√≥n devuelve true para alguno de los elementos en el array.</p>

<p id="code_units"><a class="p_ident" id="p-xwqTjYNDg/" href="#p-xwqTjYNDg/" tabindex="-1" role="presentation"></a>Pero, ¬øc√≥mo obtenemos los c√≥digos de caracteres en una cadena?</p>

<p><a class="p_ident" id="p-QaWyxrrWcl" href="#p-QaWyxrrWcl" tabindex="-1" role="presentation"></a>En el <a href="01_values.html">Cap√≠tulo 1</a> mencion√© que las cadenas de JavaScript est√°n codificadas como una secuencia de n√∫meros de 16 bits. Estos se llaman <em>unidades de c√≥digo</em>. Al principio, se supon√≠a que un c√≥digo de car√°cter Unicode cab√≠a dentro de tal unidad (lo que te da algo m√°s de 65000 caracteres). Cuando qued√≥ claro que eso no iba a ser suficiente, mucha gente se mostr√≥ reacia a la necesidad de usar m√°s memoria por car√°cter. Para abordar estas preocupaciones, se invent√≥ UTF-16, el formato que usan las cadenas de JavaScript. Describe la mayor√≠a de los caracteres comunes usando una √∫nica unidad de c√≥digo de 16 bits, pero usa un par de dos unidades de dicho tipo para otros.</p>

<p><a class="p_ident" id="p-giEN4jUd0U" href="#p-giEN4jUd0U" tabindex="-1" role="presentation"></a>UTF-16 generalmente se considera una mala idea hoy en d√≠a. Parece casi dise√±ado intencionalmente para provocar errores. Es f√°cil escribir programas que asuman que las unidades de c√≥digo y los caracteres son lo mismo. Y si tu lenguaje no utiliza caracteres de dos unidades, eso parecer√° funcionar perfectamente. Pero tan pronto como alguien intente usar dicho programa con algunos caracteres menos comunes como los chinos, fallar√°. Por suerte, con la llegada de los emoji, todo el mundo ha comenzado a usar caracteres de dos unidades, y tratar con tales problemas se est√° haciendo m√°s llevadero.</p>

<p><a class="p_ident" id="p-cIimdGgzlf" href="#p-cIimdGgzlf" tabindex="-1" role="presentation"></a>Lamentablemente, las operaciones obvias en las cadenas de JavaScript, como obtener su longitud a trav√©s de la propiedad <code>length</code> y acceder a su contenido usando corchetes cuadrados, tratan solo con unidades de c√≥digo.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-y07dTF1oUr" href="#c-y07dTF1oUr" tabindex="-1" role="presentation"></a><span class="tok-comment">// Dos caracteres emoji, caballo y zapato</span>
<span class="tok-keyword">let</span> <span class="tok-definition">caballoZapato</span> = <span class="tok-string">&quot;üê¥üëü&quot;</span>;
console.log(caballoZapato.length);
<span class="tok-comment">// ‚Üí 4</span>
console.log(caballoZapato[<span class="tok-number">0</span>]);
<span class="tok-comment">// ‚Üí (Mitad de car√°cter inv√°lida)</span>
console.log(caballoZapato.charCodeAt(<span class="tok-number">0</span>));
<span class="tok-comment">// ‚Üí 55357 (C√≥digo de la mitad de caracter)</span>
console.log(caballoZapato.codePointAt(<span class="tok-number">0</span>));
<span class="tok-comment">// ‚Üí 128052 (C√≥digo real para el emoji de caballo)</span></pre>

<p><a class="p_ident" id="p-BS9MJRj/qW" href="#p-BS9MJRj/qW" tabindex="-1" role="presentation"></a>El m√©todo <code>charCodeAt</code> de JavaScript te da una unidad de c√≥digo, no un c√≥digo de car√°cter completo. El m√©todo <code>codePointAt</code>, a√±adido m√°s tarde, s√≠ da un car√°cter Unicode completo, por lo que podr√≠amos usarlo para obtener caracteres de una cadena. Pero el argumento pasado a <code>codePointAt</code> sigue siendo un √≠ndice en la secuencia de unidades de c√≥digo. Para recorrer todos los caracteres en una cadena, a√∫n necesitar√≠amos abordar la cuesti√≥n de si un car√°cter ocupa una o dos unidades de c√≥digo.</p>

<p><a class="p_ident" id="p-+k9Io/S3re" href="#p-+k9Io/S3re" tabindex="-1" role="presentation"></a>En el <a href="datos#bucle_for_of">cap√≠tulo anterior</a>, mencion√© que un bucle <code>for</code>/<code>of</code> tambi√©n se puede usar en cadenas. Al igual que <code>codePointAt</code>, este tipo de bucle se introdujo en un momento en que la gente era muy consciente de los problemas con UTF-16. Cuando lo usas para recorrer una cadena, te proporciona caracteres reales, no unidades de c√≥digo:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-5IPW3Z/swv" href="#c-5IPW3Z/swv" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">rosaDrag√≥n</span> = <span class="tok-string">&quot;üåπüêâ&quot;</span>;
<span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">car√°cter</span> <span class="tok-keyword">of</span> rosaDrag√≥n) {
  console.log(caracter);
}
<span class="tok-comment">// ‚Üí üåπ</span>
<span class="tok-comment">// ‚Üí üêâ</span></pre>

<p><a class="p_ident" id="p-crnlwccTvb" href="#p-crnlwccTvb" tabindex="-1" role="presentation"></a>Si tienes un car√°cter (que ser√° una cadena de una o dos unidades de c√≥digo), puedes usar <code>codePointAt(0)</code> para obtener su c√≥digo.</p>

<h2><a class="h_ident" id="h-6v14c/pbJh" href="#h-6v14c/pbJh" tabindex="-1" role="presentation"></a>Reconociendo texto</h2>

<p><a class="p_ident" id="p-US1jun7br4" href="#p-US1jun7br4" tabindex="-1" role="presentation"></a>Tenemos una funci√≥n <code>sistemaCaracteres</code> y una forma de recorrer correctamente los caracteres. El pr√≥ximo paso es contar los caracteres que pertenecen a cada sistema de escritura. La siguiente abstracci√≥n de recuento ser√° √∫til para eso:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-TEPk63dZNo" href="#c-TEPk63dZNo" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">contarPor</span>(<span class="tok-definition">items</span>, <span class="tok-definition">nombreGrupo</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">recuentos</span> = [];
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">item</span> <span class="tok-keyword">of</span> items) {
    <span class="tok-keyword">let</span> <span class="tok-definition">nombre</span> = nombreGrupo(item);
    <span class="tok-keyword">let</span> <span class="tok-definition">conocido</span> = recuentos.find(<span class="tok-definition">c</span> =&gt; c.nombre == nombre);
    <span class="tok-keyword">if</span> (!conocido) {
      recuentos.push({<span class="tok-definition">nombre</span>, <span class="tok-definition">recuento</span>: <span class="tok-number">1</span>});
    } <span class="tok-keyword">else</span> {
      conocido.recuento++;
    }
  }
  <span class="tok-keyword">return</span> recuentos;
}

console.log(contarPor([<span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>, <span class="tok-number">4</span>, <span class="tok-number">5</span>], <span class="tok-definition">n</span> =&gt; n &gt; <span class="tok-number">2</span>));
<span class="tok-comment">// ‚Üí [{nombre: false, recuento: 2}, {nombre: true, recuento: 3}]</span></pre>

<p><a class="p_ident" id="p-BkGEda/6+p" href="#p-BkGEda/6+p" tabindex="-1" role="presentation"></a>La funci√≥n <code>contarPor</code> espera una colecci√≥n (cualquier cosa por la que podamos iterar con <code>for</code>/<code>of</code>) y una funci√≥n que calcule un nombre de grupo para un elemento dado. Devuelve una matriz de objetos, cada uno de los cuales nombra un grupo y te dice el n√∫mero de elementos que se encontraron en ese grupo.</p>

<p><a class="p_ident" id="p-3D6sEDfZSV" href="#p-3D6sEDfZSV" tabindex="-1" role="presentation"></a>Utiliza otro m√©todo de array, <code>find</code>, que recorre los elementos en el array y devuelve el primero para el cual una funci√≥n devuelve true. Devuelve <code>undefined</code> cuando no se encuentra dicho elemento.</p>

<p><a class="p_ident" id="p-cOB6KMMgRg" href="#p-cOB6KMMgRg" tabindex="-1" role="presentation"></a>Usando <code>contarPor</code>, podemos escribir la funci√≥n que nos dice qu√© sistemas de escritura se utilizan en un fragmento de texto:</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-IBybQjGQ9Z" href="#c-IBybQjGQ9Z" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">sistemasTexto</span>(<span class="tok-definition">texto</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">sistemas</span> = contarPor(texto, <span class="tok-definition">car√°cter</span> =&gt; {
    <span class="tok-keyword">let</span> <span class="tok-definition">sistema</span> = sistemaCaracteres(car√°cter.codePointAt(<span class="tok-number">0</span>));
    <span class="tok-keyword">return</span> sistema ? sistema.name : <span class="tok-string">&quot;ninguno&quot;</span>;
  }).filter(({nombre}) =&gt; nombre != <span class="tok-string">&quot;ninguno&quot;</span>);

  <span class="tok-keyword">let</span> <span class="tok-definition">total</span> = sistemas.reduce((<span class="tok-definition">n</span>, {recuento}) =&gt; n + recuento, <span class="tok-number">0</span>);
  <span class="tok-keyword">if</span> (total == <span class="tok-number">0</span>) <span class="tok-keyword">return</span> <span class="tok-string">&quot;No se encontraron sistemas&quot;</span>;

  <span class="tok-keyword">return</span> sistemas.map(({nombre, recuento}) =&gt; {
    <span class="tok-keyword">return</span> <span class="tok-string2">`</span>${Math.round(recuento * <span class="tok-number">100</span> / total)}<span class="tok-string2">% </span>${nombre}<span class="tok-string2">`</span>;
  }).join(<span class="tok-string">&quot;, &quot;</span>);
}

console.log(sistemasTexto(<span class="tok-string">'Ëã±ÂõΩÁöÑÁãóËØ¥&quot;woof&quot;, ‰øÑÁΩóÊñØÁöÑÁãóËØ¥&quot;—Ç—è–≤&quot;'</span>));
<span class="tok-comment">// ‚Üí 61% Han, 22% Latin, 17% Cyrillic</span></pre>

<p><a class="p_ident" id="p-6ZNN+7KNVP" href="#p-6ZNN+7KNVP" tabindex="-1" role="presentation"></a>La funci√≥n primero recoge los nombres de los sistemas de escritura de los caracteres en el texto usando <code>sistemaCaracteres</code> para asignarles un nombre y recurriendo a la cadena <code>&quot;ninguno&quot;</code> para los caracteres que no forman parte de ning√∫n sistema. La llamada a <code>filter</code> elimina la entrada correspondiente a <code>&quot;ninguno&quot;</code> del array resultante, ya que no nos interesan esos caracteres.</p>

<p><a class="p_ident" id="p-z0FN1vM2Io" href="#p-z0FN1vM2Io" tabindex="-1" role="presentation"></a>Para poder calcular porcentajes, primero necesitamos el n√∫mero total de caracteres que pertenecen a un sistema dado, lo cual podemos calcular con <code>reduce</code>. Si no se encuentran dichos caracteres, la funci√≥n devuelve una cadena espec√≠fica. De lo contrario, transforma las entradas de conteo en cadenas legibles con <code>map</code> y luego las combina con <code>join</code>.</p>

<h2><a class="h_ident" id="h-NUFOUyK+lw" href="#h-NUFOUyK+lw" tabindex="-1" role="presentation"></a>Resumen</h2>

<p><a class="p_ident" id="p-ua0YBHiMTm" href="#p-ua0YBHiMTm" tabindex="-1" role="presentation"></a>Poder pasar valores de funciones a otras funciones es un aspecto muy √∫til de JavaScript. Nos permite escribir funciones que modelan c√°lculos con ‚Äúhuecos a rellenar‚Äù en ellas. El c√≥digo que llama a estas funciones puede llenar los huecos proporcionando valores de funciones.</p>

<p><a class="p_ident" id="p-AxW84COxvD" href="#p-AxW84COxvD" tabindex="-1" role="presentation"></a>Los arrays proporcionan diversos m√©todos de orden superior muy √∫tiles. Puedes usar <code>forEach</code> para recorrer los elementos de un array. El m√©todo <code>filter</code> devuelve un nuevo array que contiene solo los elementos que pasan la funci√≥n de predicado. Transformar un array poniendo cada elemento en una funci√≥n se hace con <code>map</code>. Puedes usar <code>reduce</code> para combinar todos los elementos de un array en un √∫nico valor. El m√©todo <code>some</code> comprueba si alg√∫n elemento satisface una funci√≥n de predicado dada, mientras que <code>find</code> encuentra el primer elemento que satisface un predicado.</p>

<h2><a class="h_ident" id="h-tkm7ntLto1" href="#h-tkm7ntLto1" tabindex="-1" role="presentation"></a>Ejercicios</h2>

<h3><a class="i_ident" id="i-NYYN2FxNVG" href="#i-NYYN2FxNVG" tabindex="-1" role="presentation"></a>Aplanamiento</h3>

<p><a class="p_ident" id="p-2JTbAIwElU" href="#p-2JTbAIwElU" tabindex="-1" role="presentation"></a>Utiliza el m√©todo <code>reduce</code> en combinaci√≥n con el m√©todo <code>concat</code> para ‚Äúaplanar‚Äù un array de arrays en un √∫nico array que contenga todos los elementos de los arrays originales.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-9vAbUnn21O" href="#c-9vAbUnn21O" tabindex="-1" role="presentation"></a><span class="tok-keyword">let</span> <span class="tok-definition">arrays</span> = [[<span class="tok-number">1</span>, <span class="tok-number">2</span>, <span class="tok-number">3</span>], [<span class="tok-number">4</span>, <span class="tok-number">5</span>], [<span class="tok-number">6</span>]];
<span class="tok-comment">// Tu c√≥digo aqu√≠.</span>
<span class="tok-comment">// ‚Üí [1, 2, 3, 4, 5, 6]</span></pre>

<h3><a class="i_ident" id="i-cBnCXoHx6D" href="#i-cBnCXoHx6D" tabindex="-1" role="presentation"></a>Tu propio bucle</h3>

<p><a class="p_ident" id="p-eTd6UCJrnn" href="#p-eTd6UCJrnn" tabindex="-1" role="presentation"></a>Escribe una funci√≥n de orden superior <code>loop</code> que proporcione algo similar a una declaraci√≥n de bucle <code>for</code>. Deber√≠a recibir un valor, una funci√≥n de comprobaci√≥n, una funci√≥n de actualizaci√≥n y una funci√≥n de cuerpo. En cada iteraci√≥n, primero debe ejecutar la funci√≥n de comprobaci√≥n en el valor actual del bucle y detenerse si devuelve falso. Luego debe llamar a la funci√≥n de cuerpo, pas√°ndole el valor actual, y finalmente llamar a la funci√≥n de actualizaci√≥n para crear un nuevo valor y empezar de nuevo desde el principio.</p>

<p><a class="p_ident" id="p-ZjRsh6UWeD" href="#p-ZjRsh6UWeD" tabindex="-1" role="presentation"></a>Al definir la funci√≥n, puedes usar un bucle normal para hacer el bucle real.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-Fv1rc97GEM" href="#c-Fv1rc97GEM" tabindex="-1" role="presentation"></a><span class="tok-comment">// Your code here.</span>

loop(<span class="tok-number">3</span>, <span class="tok-definition">n</span> =&gt; n &gt; <span class="tok-number">0</span>, <span class="tok-definition">n</span> =&gt; n - <span class="tok-number">1</span>, console.log);
<span class="tok-comment">// ‚Üí 3</span>
<span class="tok-comment">// ‚Üí 2</span>
<span class="tok-comment">// ‚Üí 1</span></pre>

<h3><a class="i_ident" id="i-SmbRSAd5GA" href="#i-SmbRSAd5GA" tabindex="-1" role="presentation"></a>Everything</h3>

<p><a class="p_ident" id="p-4Pg9vLwvKg" href="#p-4Pg9vLwvKg" tabindex="-1" role="presentation"></a>Los arrays tambi√©n tienen un m√©todo <code>every</code> an√°logo al m√©todo <code>some</code>. Este m√©todo devuelve <code>true</code> cuando la funci√≥n dada devuelve <code>true</code> para <em>todo</em> elemento en el array. En cierto modo, <code>some</code> es una versi√≥n del operador <code>||</code> que act√∫a en arrays, y <code>every</code> es como el operador <code>&amp;&amp;</code>.</p>

<p><a class="p_ident" id="p-pg6rAnmtg7" href="#p-pg6rAnmtg7" tabindex="-1" role="presentation"></a>Implementa <code>every</code> como una funci√≥n que recibe un array y una funci√≥n de predicado como par√°metros. Escribe dos versiones, una usando un bucle y otra usando el m√©todo <code>some</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-NludaTWDls" href="#c-NludaTWDls" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">every</span>(<span class="tok-definition">array</span>, <span class="tok-definition">test</span>) {
  <span class="tok-comment">// Your code here.</span>
}

console.log(every([<span class="tok-number">1</span>, <span class="tok-number">3</span>, <span class="tok-number">5</span>], <span class="tok-definition">n</span> =&gt; n &lt; <span class="tok-number">10</span>));
<span class="tok-comment">// ‚Üí true</span>
console.log(every([<span class="tok-number">2</span>, <span class="tok-number">4</span>, <span class="tok-number">16</span>], <span class="tok-definition">n</span> =&gt; n &lt; <span class="tok-number">10</span>));
<span class="tok-comment">// ‚Üí false</span>
console.log(every([], <span class="tok-definition">n</span> =&gt; n &lt; <span class="tok-number">10</span>));
<span class="tok-comment">// ‚Üí true</span></pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-2enp9r8UmW" href="#p-2enp9r8UmW" tabindex="-1" role="presentation"></a>Al igual que el operador <code>&amp;&amp;</code>, el m√©todo <code>every</code> puede dejar de evaluar m√°s elementos tan pronto como encuentre uno que no coincida. Por lo tanto, la versi√≥n basada en un bucle puede salir del bucle ‚Äîcon <code>break</code> o <code>return</code>‚Äî tan pronto como encuentre un elemento para el que la funci√≥n de predicado devuelva false. Si el bucle se ejecuta hasta el final sin encontrar dicho elemento, sabemos que todos los elementos coincidieron y deber√≠amos devolver true.</p>

<p><a class="p_ident" id="p-Coa0zWQNO0" href="#p-Coa0zWQNO0" tabindex="-1" role="presentation"></a>Para construir <code>every</code> sobre <code>some</code>, podemos aplicar <em>leyes de De Morgan</em>, que establecen que <code>a &amp;&amp; b</code> tiene el mismo valor que <code>!(!a || !b)</code>. Esto se puede generalizar a arrays, donde todos los elementos en el array coinciden si no hay ning√∫n elemento en el array que no coincida.</p>

</div></details>

<h3><a class="i_ident" id="i-kUUDTvgJ6V" href="#i-kUUDTvgJ6V" tabindex="-1" role="presentation"></a>Direcci√≥n de escritura dominante</h3>

<p><a class="p_ident" id="p-wNkAaSiwZs" href="#p-wNkAaSiwZs" tabindex="-1" role="presentation"></a>Escribe una funci√≥n que calcule la direcci√≥n de escritura dominante en una cadena de texto. Recuerda que cada objeto de sistema de escritura tiene una propiedad <code>direction</code> que puede ser <code>&quot;ltr&quot;</code> (de izquierda a derecha), <code>&quot;rtl&quot;</code> (de derecha a izquierda) o <code>&quot;ttb&quot;</code> (de arriba a abajo).</p>

<pre tabindex="0" class="snippet" data-language="javascript" ><a class="c_ident" id="c-CNawUvyti3" href="#c-CNawUvyti3" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">dominantDirection</span>(<span class="tok-definition">text</span>) {
  <span class="tok-comment">// Your code here.</span>
}

console.log(dominantDirection(<span class="tok-string">&quot;Hello!&quot;</span>));
<span class="tok-comment">// ‚Üí ltr</span>
console.log(dominantDirection(<span class="tok-string">&quot;Hey, ŸÖÿ≥ÿßÿ° ÿßŸÑÿÆŸäÿ±&quot;</span>));
<span class="tok-comment">// ‚Üí rtl</span></pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-lyuHx3ewV/" href="#p-lyuHx3ewV/" tabindex="-1" role="presentation"></a>Tu soluci√≥n podr√≠a parecerse mucho a la primera mitad del ejemplo de <code>sistemasTexto</code>. De nuevo, debes contar caracteres seg√∫n un criterio basado en <code>sistemaCaracteres</code> y luego filtrar la parte del resultado que se refiere a caracteres no interesantes (sin sistema asociado).</p>

<p><a class="p_ident" id="p-FrVu7Vg3MC" href="#p-FrVu7Vg3MC" tabindex="-1" role="presentation"></a>Encontrar la direcci√≥n con el recuento de caracteres m√°s alto es algo que se puede hacer con <code>reduce</code>. Si no est√° claro c√≥mo hacerlo, consulta el ejemplo que vimos antes en el cap√≠tulo, donde se us√≥ <code>reduce</code> para encontrar el script con m√°s caracteres.</p>

</div></details><nav><a href="04_data.html" title="previous chapter" aria-label="previous chapter">‚óÇ</a>¬†<a href="index.html" title="cover" aria-label="cover">‚óè</a>¬†<a href="06_object.html" title="next chapter" aria-label="next chapter">‚ñ∏</a>&nbsp;<button class=help title="help" aria-label="help"><strong>?</strong></button>
</nav>
</article>

<script src="ejs.js"></script>
