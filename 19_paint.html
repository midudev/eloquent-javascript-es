<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Proyecto: Un Editor de Arte Pixel :: JavaScript Elocuente</title>
  <link rel="stylesheet" href="css/ejs.css"><script>
      var page = {"type":"chapter","number":19,"load_files":["code/chapter/19_paint.js"]}</script></head>

<body><article>
<nav><a href="18_http.html" title="cap√≠tulo anterior" aria-label="cap√≠tulo anterior">‚óÇ</a>&nbsp;<a href="index.html" title="portada" aria-label="portada">‚óè</a>&nbsp;<a href="20_node.html" title="pr√≥ximo cap√≠tulo" aria-label="pr√≥ximo cap√≠tulo">‚ñ∏</a>&nbsp;<button class="help" title="ayuda" aria-label="ayuda"><strong>?</strong></button>
</nav>

<h1>Proyecto: Un Editor de Arte Pixel</h1>

<blockquote>

<p><a class="p_ident" id="p-YcWG8HTlFz" href="#p-YcWG8HTlFz" tabindex="-1" role="presentation"></a>Miro los muchos colores ante m√≠. Miro mi lienzo en blanco. Entonces, intento aplicar colores como palabras que dan forma a poemas, como notas que dan forma a la m√∫sica.</p>

<footer>Joan Mir√≥</footer>

</blockquote><figure class="chapter framed"><img src="images/chapter_picture_19.jpg" alt="Ilustraci√≥n que muestra un mosaico de baldosas negras, con tarros de otras baldosas al lado"></figure>

<p><a class="p_ident" id="p-4VGZtxD2xS" href="#p-4VGZtxD2xS" tabindex="-1" role="presentation"></a>El material de los cap√≠tulos anteriores te proporciona todos los elementos que necesitas para construir una aplicaci√≥n web b√°sica. En este cap√≠tulo, haremos justamente eso.</p>

<p><a class="p_ident" id="p-1emWaHj7VO" href="#p-1emWaHj7VO" tabindex="-1" role="presentation"></a>Nuestra aplicaci√≥n ser√° un programa de dibujo de p√≠xeles, donde puedes modificar una imagen p√≠xel por p√≠xel manipulando una vista ampliada de la misma, mostrada como una cuadr√≠cula de cuadrados de colores. Puedes utilizar el programa para abrir archivos de imagen, garabatear en ellos con tu rat√≥n u otro dispositivo se√±alador, y guardarlos. As√≠ es como se ver√°:</p><figure><img src="images/pixel_editor.png" alt="Captura de pantalla de la interfaz del editor de p√≠xeles, con una cuadr√≠cula de p√≠xeles de colores en la parte superior y varios controles, en forma de campos y botones HTML, debajo de eso"></figure>

<p><a class="p_ident" id="p-p5MrFAzNpG" href="#p-p5MrFAzNpG" tabindex="-1" role="presentation"></a>Pintar en un ordenador es genial. No necesitas preocuparte por materiales, habilidad o talento. Simplemente comienzas a difuminar y ves d√≥nde terminas.</p>

<h2><a class="h_ident" id="h-kolHPu7a7g" href="#h-kolHPu7a7g" tabindex="-1" role="presentation"></a>Componentes</h2>

<p><a class="p_ident" id="p-FdzFEXmy5/" href="#p-FdzFEXmy5/" tabindex="-1" role="presentation"></a>La interfaz de la aplicaci√≥n muestra un gran elemento <code>&lt;canvas&gt;</code> en la parte superior, con varios campos de formulario debajo de √©l. El usuario dibuja en la imagen seleccionando una herramienta de un campo <code>&lt;select&gt;</code> y luego haciendo clic, tocando o arrastrando a trav√©s del lienzo. Hay herramientas para dibujar p√≠xeles individuales o rect√°ngulos, para rellenar un √°rea y para seleccionar un color de la imagen.</p>

<p><a class="p_ident" id="p-NhRI/7J4/9" href="#p-NhRI/7J4/9" tabindex="-1" role="presentation"></a>Estructuraremos la interfaz del editor como una serie de <em>componentes</em>, objetos que son responsables de una parte del DOM y que pueden contener otros componentes en su interior.</p><p><a class="p_ident" id="p-fkKmP4oVNw" href="#p-fkKmP4oVNw" tabindex="-1" role="presentation"></a>El estado de la aplicaci√≥n consiste en la imagen actual, la herramienta seleccionada y el color seleccionado. Configuraremos las cosas de manera que el estado resida en un √∫nico valor, y los componentes de la interfaz siempre se basen en el estado actual para verse.</p>

<p><a class="p_ident" id="p-oe6YnJcpK9" href="#p-oe6YnJcpK9" tabindex="-1" role="presentation"></a>Para ver por qu√© esto es importante, consideremos la alternativa: distribuir partes del estado por toda la interfaz. Hasta cierto punto, esto es m√°s f√°cil de programar. Solo necesitamos colocar un campo de color y leer su valor cuando necesitemos saber el color actual.</p>

<p><a class="p_ident" id="p-l1Xnwp6j2Z" href="#p-l1Xnwp6j2Z" tabindex="-1" role="presentation"></a>Pero luego agregamos el selector de color: una herramienta que te permite hacer clic en la imagen para seleccionar el color de un p√≠xel dado. Para mantener el campo de color mostrando el color correcto, esa herramienta tendr√≠a que saber que el campo de color existe y actualizarlo cada vez que elige un nuevo color. Si alguna vez a√±ades otro lugar que muestre el color (quiz√°s el cursor del rat√≥n podr√≠a mostrarlo), tendr√≠as que actualizar tu c√≥digo de cambio de color para mantener eso sincronizado tambi√©n.</p>

<p><a class="p_ident" id="p-V/rEZY0rXG" href="#p-V/rEZY0rXG" tabindex="-1" role="presentation"></a>En efecto, esto crea un problema donde cada parte de la interfaz necesita saber acerca de todas las dem√°s partes, lo cual no es muy modular. Para aplicaciones peque√±as como la que se muestra en este cap√≠tulo, eso puede no ser un problema. Para proyectos m√°s grandes, puede convertirse en una pesadilla real.</p>

<p><a class="p_ident" id="p-g1VVb9/ySC" href="#p-g1VVb9/ySC" tabindex="-1" role="presentation"></a>Para evitar esta pesadilla en principio, vamos a ser estrictos acerca del <em>flujo de datos</em>. Existe un estado, y la interfaz se dibuja basada en ese estado. Un componente de la interfaz puede responder a las acciones del usuario actualizando el estado, momento en el cual los componentes tienen la oportunidad de sincronizarse con este nuevo estado.</p>

<p><a class="p_ident" id="p-y9QbZFxmjm" href="#p-y9QbZFxmjm" tabindex="-1" role="presentation"></a>En la pr√°ctica, cada componente est√° configurado de manera que cuando se le proporciona un nuevo estado, tambi√©n notifica a sus componentes hijos, en la medida en que estos necesiten actualizarse. Configurar esto es un poco molesto. Hacer que esto sea m√°s conveniente es el principal punto de venta de muchas bibliotecas de programaci√≥n de navegadores. Pero para una aplicaci√≥n peque√±a como esta, podemos hacerlo sin una infraestructura de ese tipo.</p>

<p><a class="p_ident" id="p-lPz3O+BIo4" href="#p-lPz3O+BIo4" tabindex="-1" role="presentation"></a>Las actualizaciones en el estado est√°n representadas como objetos, a los cuales llamaremos <em>acciones</em>. Los componentes pueden crear tales acciones y <em>despacharlas</em> ‚Äîenviarlas a una funci√≥n central de gesti√≥n de estado. Esa funci√≥n calcula el pr√≥ximo estado, tras lo cual los componentes de la interfaz se actualizan a este nuevo estado.</p>

<p><a class="p_ident" id="p-5gofo0W3xD" href="#p-5gofo0W3xD" tabindex="-1" role="presentation"></a>Estamos tomando la tarea desordenada de ejecutar una interfaz de usuario y aplic√°ndole estructura. Aunque las piezas relacionadas con el DOM a√∫n est√°n llenas de efectos secundarios, se sostienen por un esqueleto conceptualmente simple: el ciclo de actualizaci√≥n del estado. El estado determina c√≥mo se ve el DOM y la √∫nica forma en que los eventos del DOM pueden cambiar el estado es despachando acciones al estado.</p><p><a class="p_ident" id="p-/EcvUcHPZo" href="#p-/EcvUcHPZo" tabindex="-1" role="presentation"></a>Existen <em>muchas</em> variantes de este enfoque, cada una con sus propios beneficios y problemas, pero su idea central es la misma: los cambios de estado deben pasar por un √∫nico canal bien definido, no deben ocurrir por todos lados.</p>

<p><a class="p_ident" id="p-bfcKcmqXGB" href="#p-bfcKcmqXGB" tabindex="-1" role="presentation"></a>Nuestros componentes ser√°n clases que cumplen con una interfaz. Su constructor recibe un estado, que puede ser el estado completo de la aplicaci√≥n o alg√∫n valor m√°s peque√±o si no necesita acceso a todo, y utiliza eso para construir una propiedad <code>dom</code>. Este es el elemento del DOM que representa al componente. La mayor√≠a de los constructores tambi√©n recibir√°n otros valores que no cambiar√°n con el tiempo, como la funci√≥n que pueden usar para enviar una acci√≥n.</p>

<p><a class="p_ident" id="p-//+fikMSC2" href="#p-//+fikMSC2" tabindex="-1" role="presentation"></a>Cada componente tiene un m√©todo <code>syncState</code> que se utiliza para sincronizarlo con un nuevo valor de estado. El m√©todo recibe un argumento, el estado, que es del mismo tipo que el primer argumento de su constructor.</p>

<h2><a class="h_ident" id="h-ftf/mS/U0E" href="#h-ftf/mS/U0E" tabindex="-1" role="presentation"></a>El estado</h2>

<p><a class="p_ident" id="p-bfnMVWQbM8" href="#p-bfnMVWQbM8" tabindex="-1" role="presentation"></a>El estado de la aplicaci√≥n ser√° un objeto con propiedades <code>picture</code>, <code>tool</code> y <code>color</code>. La imagen es en s√≠ un objeto que almacena el ancho, alto y contenido de p√≠xeles de la imagen. Los p√≠xeles se almacenan en un √∫nico array, fila por fila, de arriba abajo.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-FaXS4E1Q9/" href="#c-FaXS4E1Q9/" tabindex="-1" role="presentation"></a><span class="tok-keyword">class</span> Picture {
  <span class="tok-definition">constructor</span>(<span class="tok-definition">ancho</span>, <span class="tok-definition">alto</span>, <span class="tok-definition">p√≠xeles</span>) {
    <span class="tok-keyword">this</span>.width = ancho;
    <span class="tok-keyword">this</span>.height = alto;
    <span class="tok-keyword">this</span>.pixels = p√≠xeles;
  }
  <span class="tok-keyword">static</span> <span class="tok-definition">empty</span>(<span class="tok-definition">ancho</span>, <span class="tok-definition">alto</span>, <span class="tok-definition">color</span>) {
    <span class="tok-keyword">let</span> <span class="tok-definition">p√≠xeles</span> = <span class="tok-keyword">new</span> Array(ancho * alto).fill(color);
    <span class="tok-keyword">return</span> <span class="tok-keyword">new</span> Picture(ancho, alto, p√≠xeles);
  }
  <span class="tok-definition">p√≠xel</span>(<span class="tok-definition">x</span>, <span class="tok-definition">y</span>) {
    <span class="tok-keyword">return</span> <span class="tok-keyword">this</span>.pixels[x + y * <span class="tok-keyword">this</span>.width];
  }
  <span class="tok-definition">dibujar</span>(<span class="tok-definition">p√≠xeles</span>) {
    <span class="tok-keyword">let</span> <span class="tok-definition">copia</span> = <span class="tok-keyword">this</span>.pixels.slice();
    <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> {x, y, color} <span class="tok-keyword">of</span> p√≠xeles) {
      copia[x + y * <span class="tok-keyword">this</span>.width] = color;
    }
    <span class="tok-keyword">return</span> <span class="tok-keyword">new</span> Picture(<span class="tok-keyword">this</span>.width, <span class="tok-keyword">this</span>.height, copia);
  }
}</pre><p><a class="p_ident" id="p-gEQNun84hI" href="#p-gEQNun84hI" tabindex="-1" role="presentation"></a>Queremos poder tratar una imagen como un valor inmutable, por razones a las que volveremos m√°s adelante en el cap√≠tulo. Pero a veces tambi√©n necesitamos actualizar un mont√≥n de p√≠xeles a la vez. Para poder hacer eso, la clase tiene un m√©todo <code>draw</code> que espera un array de p√≠xeles actualizados ‚Äî objetos con propiedades <code>x</code>, <code>y</code> y <code>color</code> ‚Äî y crea una nueva imagen con esos p√≠xeles sobrescritos. Este m√©todo utiliza <code>slice</code> sin argumentos para copiar todo el array de p√≠xeles ‚Äî el inicio del slice se establece por defecto en 0 y el final en la longitud del array.</p>

<p><a class="p_ident" id="p-WuI3QLNiPA" href="#p-WuI3QLNiPA" tabindex="-1" role="presentation"></a>El m√©todo <code>empty</code> utiliza dos funcionalidades de arrays que no hemos visto antes. El constructor <code>Array</code> puede ser llamado con un n√∫mero para crear un array vac√≠o de la longitud dada. Luego, el m√©todo <code>fill</code> puede ser utilizado para llenar este array con un valor dado. Estos se utilizan para crear un array en el cual todos los p√≠xeles tienen el mismo color.</p>

<p><a class="p_ident" id="p-06+YtnEEH5" href="#p-06+YtnEEH5" tabindex="-1" role="presentation"></a>Los colores se almacenan como cadenas que contienen c√≥digos de color CSS tradicionales compuestos por un signo de almohadilla (<code>#</code>) seguido de seis d√≠gitos hexadecimales (base-16) ‚Äî dos para el componente rojo, dos para el componente verde y dos para el componente azul. Esta es una forma algo cr√≠ptica e inc√≥moda de escribir colores, pero es el formato que utiliza el campo de entrada de color de HTML y puede ser utilizado en la propiedad <code>fillStyle</code> de un contexto de dibujo de lienzo, as√≠ que para las formas en las que usaremos colores en este programa, es lo suficientemente pr√°ctico.</p>

<p><a class="p_ident" id="p-EsZKxAfcSW" href="#p-EsZKxAfcSW" tabindex="-1" role="presentation"></a>El negro, donde todos los componentes son cero, se escribe <code>"#000000"</code>, y el rosa brillante se ve como <code>"#ff00ff"</code>, donde los componentes rojo y azul tienen el valor m√°ximo de 255, escrito como <code>ff</code> en d√≠gitos hexadecimales (que utilizan <em>a</em> a <em>f</em> para representar los d√≠gitos 10 a 15).</p>

<p><a class="p_ident" id="p-4GL2zfxucK" href="#p-4GL2zfxucK" tabindex="-1" role="presentation"></a>Vamos a permitir que la interfaz env√≠e acciones como objetos cuyas propiedades sobrescriben las propiedades del estado anterior. El campo de color, cuando el usuario lo cambia, podr√≠a enviar un objeto como <code>{color: field.<wbr>value}</code>, a partir del cual esta funci√≥n de actualizaci√≥n puede calcular un nuevo estado.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-9ilVJcm5s/" href="#c-9ilVJcm5s/" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">actualizarEstado</span>(<span class="tok-definition">estado</span>, <span class="tok-definition">acci√≥n</span>) {
  <span class="tok-keyword">return</span> {...estado, ...acci√≥n};
}</pre><p><a class="p_ident" id="p-ra2/kSr+SN" href="#p-ra2/kSr+SN" tabindex="-1" role="presentation"></a>Este patr√≥n, en el que se utiliza object spread para primero a√±adir las propiedades de un objeto existente y luego sobrescribir algunas de ellas, es com√∫n en el c√≥digo JavaScript que utiliza objetos inmutables.</p>

<h2><a class="h_ident" id="h-sNxHTHiM3l" href="#h-sNxHTHiM3l" tabindex="-1" role="presentation"></a>Construcci√≥n del DOM</h2>

<p><a class="p_ident" id="p-pW7WuvagbQ" href="#p-pW7WuvagbQ" tabindex="-1" role="presentation"></a>Una de las cosas principales que hacen los componentes de interfaz es crear la estructura del DOM. Nuevamente, no queremos usar directamente los m√©todos verbosos del DOM para eso, por lo que aqu√≠ hay una versi√≥n ligeramente ampliada de la funci√≥n <code>elt</code>:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-bpc/osm9kD" href="#c-bpc/osm9kD" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">elt</span>(<span class="tok-definition">type</span>, <span class="tok-definition">props</span>, ...<span class="tok-definition">children</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">dom</span> = document.createElement(type);
  <span class="tok-keyword">if</span> (props) Object.assign(dom, props);
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">child</span> <span class="tok-keyword">of</span> children) {
    <span class="tok-keyword">if</span> (<span class="tok-keyword">typeof</span> child != <span class="tok-string">"string"</span>) dom.appendChild(child);
    <span class="tok-keyword">else</span> dom.appendChild(document.createTextNode(child));
  }
  <span class="tok-keyword">return</span> dom;
}</pre>

<p><a class="p_ident" id="p-BpQHRZu5+n" href="#p-BpQHRZu5+n" tabindex="-1" role="presentation"></a>La principal diferencia entre esta versi√≥n y la que usamos en <a href="16_game.html#domdisplay">Cap√≠tulo 16</a> es que asigna <em>propiedades</em> a los nodos del DOM, no <em>atributos</em>. Esto significa que no podemos usarlo para establecer atributos arbitrarios, pero <em>s√≠</em> podemos usarlo para establecer propiedades cuyo valor no sea una cadena, como <code>onclick</code>, que se puede establecer como una funci√≥n para registrar un controlador de eventos clic.</p>

<p><a class="p_ident" id="p-OWHeoYeR/L" href="#p-OWHeoYeR/L" tabindex="-1" role="presentation"></a>Esto permite este estilo conveniente para registrar controladores de eventos:</p>

<pre tabindex="0" class="snippet" data-language="html"><a class="c_ident" id="c-UrXW9qBNM+" href="#c-UrXW9qBNM+" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">body</span>&gt;
  &lt;<span class="tok-typeName">script</span>&gt;
    document.body.appendChild(elt(<span class="tok-string">"button"</span>, {
      <span class="tok-definition">onclick</span>: () =&gt; console.log(<span class="tok-string">"click"</span>)
    }, <span class="tok-string">"El bot√≥n"</span>));
  &lt;/<span class="tok-typeName">script</span>&gt;
&lt;/<span class="tok-typeName">body</span>&gt;</pre><h2><a class="h_ident" id="h-amGIg81orI" href="#h-amGIg81orI" tabindex="-1" role="presentation"></a>El lienzo</h2>

<p><a class="p_ident" id="p-BmCCXvkmPk" href="#p-BmCCXvkmPk" tabindex="-1" role="presentation"></a>El primer componente que definiremos es la parte de la interfaz que muestra la imagen como una cuadr√≠cula de cuadros de colores. Este componente es responsable de dos cosas: mostrar una imagen y comunicar eventos de puntero en esa imagen al resto de la aplicaci√≥n.</p>

<p><a class="p_ident" id="p-A/ZPezFryZ" href="#p-A/ZPezFryZ" tabindex="-1" role="presentation"></a>Como tal, podemos definirlo como un componente que solo conoce la imagen actual, no todo el estado de la aplicaci√≥n. Debido a que no sabe c√≥mo funciona la aplicaci√≥n en su totalidad, no puede despachar acciones directamente. En lugar de eso, al responder a eventos de puntero, llama a una funci√≥n de devoluci√≥n proporcionada por el c√≥digo que lo cre√≥, que manejar√° las partes espec√≠ficas de la aplicaci√≥n.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-uknkIx/3Hs" href="#c-uknkIx/3Hs" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">escala</span> = <span class="tok-number">10</span>;

<span class="tok-keyword">class</span> PictureCanvas {
  <span class="tok-definition">constructor</span>(<span class="tok-definition">imagen</span>, <span class="tok-definition">punteroAbajo</span>) {
    <span class="tok-keyword">this</span>.dom = elt(<span class="tok-string">"canvas"</span>, {
      <span class="tok-definition">onmousedown</span>: <span class="tok-definition">evento</span> =&gt; <span class="tok-keyword">this</span>.mouse(evento, punteroAbajo),
      <span class="tok-definition">ontouchstart</span>: <span class="tok-definition">evento</span> =&gt; <span class="tok-keyword">this</span>.touch(evento, punteroAbajo)
    });
    <span class="tok-keyword">this</span>.syncState(imagen);
  }
  <span class="tok-definition">syncState</span>(<span class="tok-definition">imagen</span>) {
    <span class="tok-keyword">if</span> (<span class="tok-keyword">this</span>.imagen == imagen) <span class="tok-keyword">return</span>;
    <span class="tok-keyword">this</span>.imagen = imagen;
    drawPicture(<span class="tok-keyword">this</span>.imagen, <span class="tok-keyword">this</span>.dom, escala);
  }
}</pre>

<p><a class="p_ident" id="p-tqCWoFvVxy" href="#p-tqCWoFvVxy" tabindex="-1" role="presentation"></a>Dibujamos cada p√≠xel como un cuadro de 10 por 10, seg√∫n lo determinado por la constante <code>escala</code>. Para evitar trabajo innecesario, el componente lleva un registro de su imagen actual y realiza un redibujo solo cuando <code>syncState</code> recibe una nueva imagen.</p>

<p><a class="p_ident" id="p-/GlLku5ZRF" href="#p-/GlLku5ZRF" tabindex="-1" role="presentation"></a>La funci√≥n de dibujo real establece el tama√±o del lienzo basado en la escala y el tama√±o de la imagen y lo llena con una serie de cuadrados, uno para cada p√≠xel.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-kMF9hx2xSw" href="#c-kMF9hx2xSw" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">drawPicture</span>(<span class="tok-definition">imagen</span>, <span class="tok-definition">lienzo</span>, <span class="tok-definition">escala</span>) {
  lienzo.width = imagen.width * escala;
  lienzo.height = imagen.height * escala;
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = lienzo.getContext(<span class="tok-string">"2d"</span>);<pre>
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">y</span> = <span class="tok-number">0</span>; y &lt; picture.height; y++) {
    <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">x</span> = <span class="tok-number">0</span>; x &lt; picture.width; x++) {
      cx.fillStyle = picture.pixel(x, y);
      cx.fillRect(x * scale, y * scale, scale, scale);
    }
  }
}</pre>

<p><a class="p_ident" id="p-wPTPY1JmU4" href="#p-wPTPY1JmU4" tabindex="-1" role="presentation"></a>When the left mouse button is pressed while the mouse is over the picture canvas, the component calls the <code>pointerDown</code> callback, giving it the position of the pixel that was clicked‚Äîin picture coordinates. This will be used to implement mouse interaction with the picture. The callback may return another callback function to be notified when the pointer is moved to a different pixel while the button is held down.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-G1LWj2jAqP" href="#c-G1LWj2jAqP" tabindex="-1" role="presentation"></a>PictureCanvas.prototype.mouse = <span class="tok-keyword">function</span>(<span class="tok-definition">downEvent</span>, <span class="tok-definition">onDown</span>) {
  <span class="tok-keyword">if</span> (downEvent.button != <span class="tok-number">0</span>) <span class="tok-keyword">return</span>;
  <span class="tok-keyword">let</span> <span class="tok-definition">pos</span> = pointerPosition(downEvent, <span class="tok-keyword">this</span>.dom);
  <span class="tok-keyword">let</span> <span class="tok-definition">onMove</span> = onDown(pos);
  <span class="tok-keyword">if</span> (!onMove) <span class="tok-keyword">return</span>;
  <span class="tok-keyword">let</span> <span class="tok-definition">move</span> = <span class="tok-definition">moveEvent</span> =&gt; {
    <span class="tok-keyword">if</span> (moveEvent.buttons == <span class="tok-number">0</span>) {
      <span class="tok-keyword">this</span>.dom.removeEventListener(<span class="tok-string">"mousemove"</span>, move);
    } <span class="tok-keyword">else</span> {
      <span class="tok-keyword">let</span> <span class="tok-definition">newPos</span> = pointerPosition(moveEvent, <span class="tok-keyword">this</span>.dom);
      <span class="tok-keyword">if</span> (newPos.x == pos.x &amp;&amp; newPos.y == pos.y) <span class="tok-keyword">return</span>;
      pos = newPos;
      onMove(newPos);
    }
  };
  <span class="tok-keyword">this</span>.dom.addEventListener(<span class="tok-string">"mousemove"</span>, move);
};

<span class="tok-keyword">function</span> <span class="tok-definition">pointerPosition</span>(<span class="tok-definition">pos</span>, <span class="tok-definition">domNode</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">rect</span> = domNode.getBoundingClientRect();
  <span class="tok-keyword">return</span> {<span class="tok-definition">x</span>: Math.floor((pos.clientX - rect.left) / scale),
          <span class="tok-definition">y</span>: Math.floor((pos.clientY - rect.top) / scale)};
}</pre><p><a class="p_ident" id="p-B/cdI1TfFV" href="#p-B/cdI1TfFV" tabindex="-1" role="presentation"></a>Dado que conocemos el tama√±o de los p√≠xeles y podemos utilizar <code>getBoundingClientRect</code> para encontrar la posici√≥n del lienzo en la pantalla, es posible convertir las coordenadas del evento del mouse (<code>clientX</code> y <code>clientY</code>) a coordenadas de imagen. Estas siempre se redondean hacia abajo para que se refieran a un p√≠xel espec√≠fico.</p>

<p><a class="p_ident" id="p-iTkf+HH3B/" href="#p-iTkf+HH3B/" tabindex="-1" role="presentation"></a>Con eventos t√°ctiles, tenemos que hacer algo similar, pero utilizando diferentes eventos y asegur√°ndonos de llamar a <code>preventDefault</code> en el evento <code>"touchstart"</code> para evitar el desplazamiento.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-HUiWca6Gb7" href="#c-HUiWca6Gb7" tabindex="-1" role="presentation"></a>PictureCanvas.prototype.touch = <span class="tok-keyword">function</span>(<span class="tok-definition">startEvent</span>,
                                         <span class="tok-definition">onDown</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">pos</span> = pointerPosition(startEvent.touches[<span class="tok-number">0</span>], <span class="tok-keyword">this</span>.dom);
  <span class="tok-keyword">let</span> <span class="tok-definition">onMove</span> = onDown(pos);
  startEvent.preventDefault();
  <span class="tok-keyword">if</span> (!onMove) <span class="tok-keyword">return</span>;
  <span class="tok-keyword">let</span> <span class="tok-definition">move</span> = <span class="tok-definition">moveEvent</span> =&gt; {
    <span class="tok-keyword">let</span> <span class="tok-definition">newPos</span> = pointerPosition(moveEvent.touches[<span class="tok-number">0</span>],
                                 <span class="tok-keyword">this</span>.dom);
    <span class="tok-keyword">if</span> (newPos.x == pos.x &amp;&amp; newPos.y == pos.y) <span class="tok-keyword">return</span>;
    pos = newPos;
    onMove(newPos);
  };
  <span class="tok-keyword">let</span> <span class="tok-definition">end</span> = () =&gt; {
    <span class="tok-keyword">this</span>.dom.removeEventListener(<span class="tok-string">"touchmove"</span>, move);
    <span class="tok-keyword">this</span>.dom.removeEventListener(<span class="tok-string">"touchend"</span>, end);
  };
  <span class="tok-keyword">this</span>.dom.addEventListener(<span class="tok-string">"touchmove"</span>, move);
  <span class="tok-keyword">this</span>.dom.addEventListener(<span class="tok-string">"touchend"</span>, end);
};</pre>

<p><a class="p_ident" id="p-oah1AjpovX" href="#p-oah1AjpovX" tabindex="-1" role="presentation"></a>Para eventos t√°ctiles, <code>clientX</code> y <code>clientY</code> no est√°n disponibles directamente en el objeto de evento, pero podemos usar las coordenadas del primer objeto de toque en la propiedad <code>touches</code>.</p>

<h2><a class="h_ident" id="h-bxOeMBlEZu" href="#h-bxOeMBlEZu" tabindex="-1" role="presentation"></a>La aplicaci√≥n</h2><p><a class="p_ident" id="p-TMYAdkLCzm" href="#p-TMYAdkLCzm" tabindex="-1" role="presentation"></a>Para poder construir la aplicaci√≥n paso a paso, implementaremos el componente principal como una estructura alrededor de un lienzo de imagen y un conjunto din√°mico de herramientas y controles que pasamos a su constructor.</p>

<p><a class="p_ident" id="p-CDXEkDDx7o" href="#p-CDXEkDDx7o" tabindex="-1" role="presentation"></a>Los <em>controles</em> son los elementos de interfaz que aparecen debajo de la imagen. Se proporcionar√°n como un array de constructores de componentes.</p>

<p><a class="p_ident" id="p-kvW756MNWH" href="#p-kvW756MNWH" tabindex="-1" role="presentation"></a>Las <em>herramientas</em> realizan acciones como dibujar p√≠xeles o rellenar √°reas. La aplicaci√≥n muestra el conjunto de herramientas disponibles como un campo <code>&lt;select&gt;</code>. La herramienta seleccionada actualmente determina lo que sucede cuando el usuario interact√∫a con la imagen con un dispositivo puntero. El conjunto de herramientas disponibles se proporciona como un objeto que mapea los nombres que aparecen en el campo desplegable a funciones que implementan las herramientas. Estas funciones reciben como argumentos una posici√≥n de imagen, un estado de la aplicaci√≥n actual y una funci√≥n <code>dispatch</code>. Pueden devolver una funci√≥n manejadora de movimientos que se llama con una nueva posici√≥n y un estado actual cuando el puntero se mueve a un p√≠xel diferente.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-bksTXX2fO6" href="#c-bksTXX2fO6" tabindex="-1" role="presentation"></a><span class="tok-keyword">class</span> PixelEditor {
  <span class="tok-definition">constructor</span>(<span class="tok-definition">state</span>, <span class="tok-definition">config</span>) {
    <span class="tok-keyword">let</span> {tools, controls, dispatch} = config;
    <span class="tok-keyword">this</span>.state = state;

    <span class="tok-keyword">this</span>.canvas = <span class="tok-keyword">new</span> PictureCanvas(state.picture, <span class="tok-definition">pos</span> =&gt; {
      <span class="tok-keyword">let</span> <span class="tok-definition">tool</span> = tools[<span class="tok-keyword">this</span>.state.tool];
      <span class="tok-keyword">let</span> <span class="tok-definition">onMove</span> = tool(pos, <span class="tok-keyword">this</span>.state, dispatch);
      <span class="tok-keyword">if</span> (onMove) <span class="tok-keyword">return</span> <span class="tok-definition">pos</span> =&gt; onMove(pos, <span class="tok-keyword">this</span>.state);
    });
    <span class="tok-keyword">this</span>.controls = controls.map(
      <span class="tok-definition">Control</span> =&gt; <span class="tok-keyword">new</span> Control(state, config));
    <span class="tok-keyword">this</span>.dom = elt(<span class="tok-string">"div"</span>, {}, <span class="tok-keyword">this</span>.canvas.dom, elt(<span class="tok-string">"br"</span>),
                   ...<span class="tok-keyword">this</span>.controls.reduce(
                     (<span class="tok-definition">a</span>, <span class="tok-definition">c</span>) =&gt; a.concat(<span class="tok-string">" "</span>, c.dom), []));
  }
  <span class="tok-definition">syncState</span>(<span class="tok-definition">state</span>) {
    <span class="tok-keyword">this</span>.state = state;
    <span class="tok-keyword">this</span>.canvas.syncState(state.picture);
    <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">ctrl</span> <span class="tok-keyword">of</span> <span class="tok-keyword">this</span>.controls) ctrl.syncState(state);
  }
}</pre><p><a class="p_ident" id="p-5ni0DeofjL" href="#p-5ni0DeofjL" tabindex="-1" role="presentation"></a>El manejador de punteros proporcionado a <code>PictureCanvas</code> llama a la herramienta actualmente seleccionada con los argumentos apropiados y, si eso devuelve un manejador de movimiento, lo adapta para tambi√©n recibir el estado.</p>

<p><a class="p_ident" id="p-gOumsrO7+U" href="#p-gOumsrO7+U" tabindex="-1" role="presentation"></a>Todos los controles se construyen y almacenan en <code>this.controls</code> para que puedan actualizarse cuando cambia el estado de la aplicaci√≥n. La llamada a <code>reduce</code> introduce espacios entre los elementos del DOM de los controles. De esta manera no se ven tan apretados juntos.</p>

<p><a class="p_ident" id="p-KM7knGXuoO" href="#p-KM7knGXuoO" tabindex="-1" role="presentation"></a>El primer control es el men√∫ de selecci√≥n de herramientas. Crea un elemento <code>&lt;select&gt;</code> con una opci√≥n para cada herramienta y configura un manejador de evento <code>"change"</code> que actualiza el estado de la aplicaci√≥n cuando el usuario selecciona una herramienta diferente.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-ErM/S5/GMa" href="#c-ErM/S5/GMa" tabindex="-1" role="presentation"></a><span class="tok-keyword">class</span> ToolSelect {
  <span class="tok-definition">constructor</span>(<span class="tok-definition">state</span>, {tools, dispatch}) {
    <span class="tok-keyword">this</span>.select = elt(<span class="tok-string">"select"</span>, {
      <span class="tok-definition">onchange</span>: () =&gt; dispatch({<span class="tok-definition">tool</span>: <span class="tok-keyword">this</span>.select.value})
    }, ...Object.keys(tools).map(<span class="tok-definition">name</span> =&gt; elt(<span class="tok-string">"option"</span>, {
      <span class="tok-definition">selected</span>: name == state.tool
    }, name)));
    <span class="tok-keyword">this</span>.dom = elt(<span class="tok-string">"label"</span>, <span class="tok-keyword">null</span>, <span class="tok-string">"üñå Herramienta: "</span>, <span class="tok-keyword">this</span>.select);
  }
  <span class="tok-definition">syncState</span>(<span class="tok-definition">state</span>) { <span class="tok-keyword">this</span>.select.value = state.tool; }
}</pre>

<p><a class="p_ident" id="p-7EVkxldvIa" href="#p-7EVkxldvIa" tabindex="-1" role="presentation"></a>Al envolver el texto de etiqueta y el campo en un elemento <code>&lt;label&gt;</code>, le decimos al navegador que la etiqueta pertenece a ese campo para que, por ejemplo, se pueda hacer clic en la etiqueta para enfocar el campo.</p>

<p><a class="p_ident" id="p-avuZ1LKe/u" href="#p-avuZ1LKe/u" tabindex="-1" role="presentation"></a>Tambi√©n necesitamos poder cambiar el color, as√≠ que agreguemos un control para eso. Un elemento HTML <code>&lt;input&gt;</code> con un atributo <code>type</code> de <code>color</code> nos proporciona un campo de formulario especializado para seleccionar colores. El valor de dicho campo es siempre un c√≥digo de color CSS en formato <code>"#RRGGBB"</code> (componentes rojo, verde y azul, dos d√≠gitos por color). El navegador mostrar√° una interfaz de seleccionador de colores cuando el usuario interact√∫e con √©l.</p><p><a class="p_ident" id="p-mUiMIeOUud" href="#p-mUiMIeOUud" tabindex="-1" role="presentation"></a>This control creates such a field and wires it up to stay synchronized with the application state‚Äôs <code>color</code> property.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-CNKBIFujc0" href="#c-CNKBIFujc0" tabindex="-1" role="presentation"></a><span class="tok-keyword">class</span> ColorSelect {
  <span class="tok-definition">constructor</span>(<span class="tok-definition">state</span>, {dispatch}) {
    <span class="tok-keyword">this</span>.input = elt(<span class="tok-string">"input"</span>, {
      <span class="tok-definition">type</span>: <span class="tok-string">"color"</span>,
      <span class="tok-definition">value</span>: state.color,
      <span class="tok-definition">onchange</span>: () =&gt; dispatch({<span class="tok-definition">color</span>: <span class="tok-keyword">this</span>.input.value})
    });
    <span class="tok-keyword">this</span>.dom = elt(<span class="tok-string">"label"</span>, <span class="tok-keyword">null</span>, <span class="tok-string">"üé® Color: "</span>, <span class="tok-keyword">this</span>.input);
  }
  <span class="tok-definition">syncState</span>(<span class="tok-definition">state</span>) { <span class="tok-keyword">this</span>.input.value = state.color; }
}</pre>

<h2><a class="h_ident" id="h-dRTuNLyniP" href="#h-dRTuNLyniP" tabindex="-1" role="presentation"></a>Herramientas de dibujo</h2>

<p><a class="p_ident" id="p-zMXAaVz6Dy" href="#p-zMXAaVz6Dy" tabindex="-1" role="presentation"></a>Antes de poder dibujar algo, necesitamos implementar las herramientas que controlar√°n la funcionalidad de los eventos del mouse o del tacto en el lienzo.</p>

<p><a class="p_ident" id="p-km565kqis+" href="#p-km565kqis+" tabindex="-1" role="presentation"></a>La herramienta m√°s b√°sica es la herramienta de dibujo, que cambia cualquier p√≠xel en el que hagas clic o toques al color actualmente seleccionado. Despacha una acci√≥n que actualiza la imagen a una versi√≥n en la que el p√≠xel se√±alado recibe el color actualmente seleccionado.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-CZoPfAkoSo" href="#c-CZoPfAkoSo" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">draw</span>(<span class="tok-definition">pos</span>, <span class="tok-definition">state</span>, <span class="tok-definition">dispatch</span>) {
  <span class="tok-keyword">function</span> <span class="tok-definition">drawPixel</span>({x, y}, <span class="tok-definition">state</span>) {
    <span class="tok-keyword">let</span> <span class="tok-definition">drawn</span> = {<span class="tok-definition">x</span>, <span class="tok-definition">y</span>, <span class="tok-definition">color</span>: state.color};
    dispatch({<span class="tok-definition">picture</span>: state.picture.draw([drawn])});
  }
  drawPixel(pos, state);
  <span class="tok-keyword">return</span> drawPixel;
}</pre>

<p><a class="p_ident" id="p-NV0WFpOefQ" href="#p-NV0WFpOefQ" tabindex="-1" role="presentation"></a>La funci√≥n llama inmediatamente a la funci√≥n <code>drawPixel</code> pero tambi√©n la devuelve para que sea llamada nuevamente para los p√≠xeles reci√©n tocados cuando el usuario arrastra o desliza sobre la imagen.</p><p><a class="p_ident" id="p-zzmdcb6+s1" href="#p-zzmdcb6+s1" tabindex="-1" role="presentation"></a>Para dibujar formas m√°s grandes, puede ser √∫til crear r√°pidamente rect√°ngulos. La herramienta <code>rectangle</code> dibuja un rect√°ngulo entre el punto donde comienzas a arrastrar y el punto al que arrastras.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-cHtZqBzkqi" href="#c-cHtZqBzkqi" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">rect√°ngulo</span>(<span class="tok-definition">start</span>, <span class="tok-definition">state</span>, <span class="tok-definition">dispatch</span>) {
  <span class="tok-keyword">function</span> <span class="tok-definition">dibujarRect√°ngulo</span>(<span class="tok-definition">pos</span>) {
    <span class="tok-keyword">let</span> <span class="tok-definition">xInicio</span> = Math.min(start.x, pos.x);
    <span class="tok-keyword">let</span> <span class="tok-definition">yInicio</span> = Math.min(start.y, pos.y);
    <span class="tok-keyword">let</span> <span class="tok-definition">xFin</span> = Math.max(start.x, pos.x);
    <span class="tok-keyword">let</span> <span class="tok-definition">yFin</span> = Math.max(start.y, pos.y);
    <span class="tok-keyword">let</span> <span class="tok-definition">dibujado</span> = [];
    <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">y</span> = yInicio; y &lt;= yFin; y++) {
      <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">x</span> = xInicio; x &lt;= xFin; x++) {
        dibujado.push({<span class="tok-definition">x</span>, <span class="tok-definition">y</span>, <span class="tok-definition">color</span>: state.color});
      }
    }
    dispatch({<span class="tok-definition">picture</span>: state.picture.draw(dibujado)});
  }
  dibujarRect√°ngulo(start);
  <span class="tok-keyword">return</span> dibujarRect√°ngulo;
}</pre>

<p><a class="p_ident" id="p-Fdi8lpCnu5" href="#p-Fdi8lpCnu5" tabindex="-1" role="presentation"></a>Un detalle importante en esta implementaci√≥n es que al arrastrar, el rect√°ngulo se vuelve a dibujar en la imagen desde el estado <em>original</em>. De esta manera, puedes hacer que el rect√°ngulo sea m√°s grande o m√°s peque√±o nuevamente mientras lo creas, sin que los rect√°ngulos intermedios permanezcan en la imagen final. Esta es una de las razones por las que los objetos de imagen inmutables son √∫tiles, veremos otra raz√≥n m√°s adelante.</p>

<p><a class="p_ident" id="p-IN3YD5TiR4" href="#p-IN3YD5TiR4" tabindex="-1" role="presentation"></a>Implementar el relleno por inundaci√≥n es algo m√°s complejo. Esta es una herramienta que llena el p√≠xel bajo el puntero y todos los p√≠xeles adyacentes que tienen el mismo color. "Adyacente" significa directamente adyacente horizontalmente o verticalmente, no diagonalmente. Esta imagen ilustra el conjunto de p√≠xeles coloreados cuando se utiliza la herramienta de relleno por inundaci√≥n en el p√≠xel marcado:</p><figure><img src="fonts/flood-grid.svg" alt="Diagrama de una cuadr√≠cula de p√≠xeles mostrando el √°rea llenada por una operaci√≥n de relleno por inundaci√≥n"></figure><p><a class="p_ident" id="p-g4IQdiCX9d" href="#p-g4IQdiCX9d" tabindex="-1" role="presentation"></a>Interesantemente, la forma en que haremos esto se parece un poco al c√≥digo de b√∫squeda de rutas de <a href="07_robot.html">Cap√≠tulo 7</a>. Mientras que ese c√≥digo buscaba a trav√©s de un gr√°fico para encontrar una ruta, este c√≥digo busca a trav√©s de una cuadr√≠cula para encontrar todos los p√≠xeles "conectados". El problema de llevar registro de un conjunto ramificado de rutas posibles es similar.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-phleJauNOp" href="#c-phleJauNOp" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">around</span> = [{<span class="tok-definition">dx</span>: -<span class="tok-number">1</span>, <span class="tok-definition">dy</span>: <span class="tok-number">0</span>}, {<span class="tok-definition">dx</span>: <span class="tok-number">1</span>, <span class="tok-definition">dy</span>: <span class="tok-number">0</span>},
                {<span class="tok-definition">dx</span>: <span class="tok-number">0</span>, <span class="tok-definition">dy</span>: -<span class="tok-number">1</span>}, {<span class="tok-definition">dx</span>: <span class="tok-number">0</span>, <span class="tok-definition">dy</span>: <span class="tok-number">1</span>}];

<span class="tok-keyword">function</span> <span class="tok-definition">fill</span>({x, y}, <span class="tok-definition">state</span>, <span class="tok-definition">dispatch</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">targetColor</span> = state.picture.pixel(x, y);
  <span class="tok-keyword">let</span> <span class="tok-definition">drawn</span> = [{<span class="tok-definition">x</span>, <span class="tok-definition">y</span>, <span class="tok-definition">color</span>: state.color}];
  <span class="tok-keyword">let</span> <span class="tok-definition">visited</span> = <span class="tok-keyword">new</span> Set();
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">done</span> = <span class="tok-number">0</span>; done &lt; drawn.length; done++) {
    <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> {dx, dy} <span class="tok-keyword">of</span> around) {
      <span class="tok-keyword">let</span> <span class="tok-definition">x</span> = drawn[done].x + dx, <span class="tok-definition">y</span> = drawn[done].y + dy;
      <span class="tok-keyword">if</span> (x &gt;= <span class="tok-number">0</span> &amp;&amp; x &lt; state.picture.width &amp;&amp;
          y &gt;= <span class="tok-number">0</span> &amp;&amp; y &lt; state.picture.height &amp;&amp;
          !visited.has(x + <span class="tok-string">","</span> + y) &amp;&amp;
          state.picture.pixel(x, y) == targetColor) {
        drawn.push({<span class="tok-definition">x</span>, <span class="tok-definition">y</span>, <span class="tok-definition">color</span>: state.color});
        visited.add(x + <span class="tok-string">","</span> + y);
      }
    }
  }
  dispatch({<span class="tok-definition">picture</span>: state.picture.draw(drawn)});
}</pre><p><a class="p_ident" id="p-GNt7QuVK5r" href="#p-GNt7QuVK5r" tabindex="-1" role="presentation"></a>La matriz de p√≠xeles dibujados sirve tambi√©n como lista de trabajo de la funci√≥n. Para cada p√≠xel alcanzado, tenemos que ver si alg√∫n p√≠xel adyacente tiene el mismo color y no ha sido pintado todav√≠a. El contador del bucle se retrasa con respecto a la longitud de la matriz <code>drawn</code> a medida que se a√±aden nuevos p√≠xeles. Los p√≠xeles que est√°n delante todav√≠a necesitan ser explorados. Cuando alcanza la longitud, ya no quedan p√≠xeles sin explorar y la funci√≥n ha finalizado.</p>

<p><a class="p_ident" id="p-ExOoxU8nGm" href="#p-ExOoxU8nGm" tabindex="-1" role="presentation"></a>La herramienta final es un selector de color, que te permite apuntar a un color en la imagen para usarlo como color de dibujo actual.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-JK2K2M0XJH" href="#c-JK2K2M0XJH" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">pick</span>(<span class="tok-definition">pos</span>, <span class="tok-definition">state</span>, <span class="tok-definition">dispatch</span>) {
  dispatch({<span class="tok-definition">color</span>: state.picture.pixel(pos.x, pos.y)});
}</pre>

<p><a class="p_ident" id="p-JOsrRsRZs3" href="#p-JOsrRsRZs3" tabindex="-1" role="presentation"></a>¬°Ahora podemos probar nuestra aplicaci√≥n!</p>

<pre tabindex="0" class="snippet" data-language="html"><a class="c_ident" id="c-OAsV4NrCrn" href="#c-OAsV4NrCrn" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">div</span>&gt;&lt;/<span class="tok-typeName">div</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">let</span> <span class="tok-definition">state</span> = {
    <span class="tok-definition">tool</span>: <span class="tok-string">"draw"</span>,
    <span class="tok-definition">color</span>: <span class="tok-string">"#000000"</span>,
    <span class="tok-definition">picture</span>: Picture.empty(<span class="tok-number">60</span>, <span class="tok-number">30</span>, <span class="tok-string">"#f0f0f0"</span>)
  };
  <span class="tok-keyword">let</span> <span class="tok-definition">app</span> = <span class="tok-keyword">new</span> PixelEditor(state, {
    <span class="tok-definition">tools</span>: {<span class="tok-definition">draw</span>, <span class="tok-definition">fill</span>, <span class="tok-definition">rectangle</span>, <span class="tok-definition">pick</span>},
    <span class="tok-definition">controls</span>: [ToolSelect, ColorSelect],
    <span class="tok-definition">dispatch</span>(<span class="tok-definition">action</span>) {
      state = updateState(state, action);
      app.syncState(state);
    }
  });
  document.querySelector(<span class="tok-string">"div"</span>).appendChild(app.dom);
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<h2><a class="h_ident" id="h-7eec4RKHJi" href="#h-7eec4RKHJi" tabindex="-1" role="presentation"></a>Guardado y carga</h2>

<p><a class="p_ident" id="p-apCzJ1aUDN" href="#p-apCzJ1aUDN" tabindex="-1" role="presentation"></a>Cuando hayamos dibujado nuestra obra maestra, querramos guardarla para m√°s tarde. Deber√≠amos a√±adir un bot√≥n para descargar la imagen actual como un archivo de imagen. Este control proporciona ese bot√≥n:</p><pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-4+FAPgY7mH" href="#c-4+FAPgY7mH" tabindex="-1" role="presentation"></a><span class="tok-keyword">class</span> SaveButton {
  <span class="tok-definition">constructor</span>(<span class="tok-definition">state</span>) {
    <span class="tok-keyword">this</span>.picture = state.picture;
    <span class="tok-keyword">this</span>.dom = elt(<span class="tok-string">"button"</span>, {
      <span class="tok-definition">onclick</span>: () =&gt; <span class="tok-keyword">this</span>.save()
    }, <span class="tok-string">"üíæ Guardar"</span>);
  }
  <span class="tok-definition">save</span>() {
    <span class="tok-keyword">let</span> <span class="tok-definition">canvas</span> = elt(<span class="tok-string">"canvas"</span>);
    drawPicture(<span class="tok-keyword">this</span>.picture, canvas, <span class="tok-number">1</span>);
    <span class="tok-keyword">let</span> <span class="tok-definition">link</span> = elt(<span class="tok-string">"a"</span>, {
      <span class="tok-definition">href</span>: canvas.toDataURL(),
      <span class="tok-definition">download</span>: <span class="tok-string">"pixelart.png"</span>
    });
    document.body.appendChild(link);
    link.click();
    link.remove();
  }
  <span class="tok-definition">syncState</span>(<span class="tok-definition">state</span>) { <span class="tok-keyword">this</span>.picture = state.picture; }
}</pre>

<p><a class="p_ident" id="p-pdnEnbG3o4" href="#p-pdnEnbG3o4" tabindex="-1" role="presentation"></a>El componente realiza un seguimiento de la imagen actual para poder acceder a ella al guardarla. Para crear el archivo de imagen, utiliza un elemento <code>&lt;canvas&gt;</code> en el que dibuja la imagen (a una escala de un p√≠xel por p√≠xel).</p>

<p><a class="p_ident" id="p-RBRB3ggvxG" href="#p-RBRB3ggvxG" tabindex="-1" role="presentation"></a>El m√©todo <code>toDataURL</code> en un elemento canvas crea una URL que comienza con <code>data:</code>. A diferencia de las URL <code>http:</code> y <code>https:</code>, las URL de datos contienen todo el recurso en la URL. Suelen ser muy largas, pero nos permiten crear enlaces funcionales a im√°genes arbitrarias directamente en el navegador.</p>

<p><a class="p_ident" id="p-wLm+MTv/IH" href="#p-wLm+MTv/IH" tabindex="-1" role="presentation"></a>Para que el navegador descargue realmente la imagen, creamos un elemento de enlace que apunta a esta URL y tiene un atributo <code>download</code>. Estos enlaces, al hacer clic en ellos, hacen que el navegador muestre un cuadro de di√°logo de guardado de archivos. Agregamos ese enlace al documento, simulamos un clic en √©l y lo eliminamos nuevamente. Se puede hacer mucho con la tecnolog√≠a del navegador, pero a veces la forma de hacerlo es bastante extra√±a.</p>

<p><a class="p_ident" id="p-vpclgP0SX6" href="#p-vpclgP0SX6" tabindex="-1" role="presentation"></a>Y empeora. Tambi√©n querremos poder cargar archivos de imagen existentes en nuestra aplicaci√≥n. Para ello, nuevamente definimos un componente de bot√≥n.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-6tKjwwpwls" href="#c-6tKjwwpwls" tabindex="-1" role="presentation"></a><span class="tok-keyword">class</span> LoadButton {
  <span class="tok-definition">constructor</span>(<span class="tok-definition">_</span>, {dispatch}) {
    <span class="tok-keyword">this</span>.dom = elt(<span class="tok-string">"button"</span>, {
      <span class="tok-definition">onclick</span>: () =&gt; startLoad(dispatch)
    }, <span class="tok-string">"üìÅ Cargar"</span>);
  }
  <span class="tok-definition">syncState</span>() {}
}

```html
<span class="tok-keyword">function</span> <span class="tok-definition">startLoad</span>(<span class="tok-definition">dispatch</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">input</span> = elt(<span class="tok-string">"input"</span>, {
    <span class="tok-definition">type</span>: <span class="tok-string">"file"</span>,
    <span class="tok-definition">onchange</span>: () =&gt; finishLoad(input.files[<span class="tok-number">0</span>], dispatch)
  });
  document.body.appendChild(input);
  input.click();
  input.remove();
}</pre>

<p><a class="p_ident" id="p-7z5lWv7c7k" href="#p-7z5lWv7c7k" tabindex="-1" role="presentation"></a>Para acceder a un archivo en la computadora del usuario, necesitamos que el usuario seleccione el archivo a trav√©s de un campo de entrada de archivo. Pero no quiero que el bot√≥n de carga parezca un campo de entrada de archivo, as√≠ que creamos el campo de entrada de archivo cuando se hace clic en el bot√≥n y luego pretendemos que este campo de entrada de archivo mismo fue clickeado.</p>

<p><a class="p_ident" id="p-HpRHURGqcK" href="#p-HpRHURGqcK" tabindex="-1" role="presentation"></a>Cuando el usuario ha seleccionado un archivo, podemos usar <code>FileReader</code> para acceder a su contenido, de nuevo como una URL de datos. Esa URL puede ser usada para crear un elemento <code>&lt;img&gt;</code>, pero debido a que no podemos acceder directamente a los p√≠xeles en tal imagen, no podemos crear un objeto <code>Picture</code> a partir de eso.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-bRy4XNFu3R" href="#c-bRy4XNFu3R" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">finishLoad</span>(<span class="tok-definition">file</span>, <span class="tok-definition">dispatch</span>) {
  <span class="tok-keyword">if</span> (file == <span class="tok-keyword">null</span>) <span class="tok-keyword">return</span>;
  <span class="tok-keyword">let</span> <span class="tok-definition">reader</span> = <span class="tok-keyword">new</span> FileReader();
  reader.addEventListener(<span class="tok-string">"load"</span>, () =&gt; {
    <span class="tok-keyword">let</span> <span class="tok-definition">image</span> = elt(<span class="tok-string">"img"</span>, {
      <span class="tok-definition">onload</span>: () =&gt; dispatch({
        <span class="tok-definition">picture</span>: pictureFromImage(image)
      }),
      <span class="tok-definition">src</span>: reader.result
    });
  });
  reader.readAsDataURL(file);
}</pre>

<p><a class="p_ident" id="p-GCbWh2o/H9" href="#p-GCbWh2o/H9" tabindex="-1" role="presentation"></a>Para acceder a los p√≠xeles, primero debemos dibujar la imagen en un elemento <code>&lt;canvas&gt;</code>. El contexto del lienzo tiene un m√©todo <code>getImageData</code> que permite a un script leer sus p√≠xeles. Entonces, una vez que la imagen est√° en el lienzo, podemos acceder a ella y construir un objeto <code>Picture</code>.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-bHE23Qbgos" href="#c-bHE23Qbgos" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">pictureFromImage</span>(<span class="tok-definition">image</span>) {
  <span class="tok-keyword">let</span> <span class="tok-definition">width</span> = Math.min(<span class="tok-number">100</span>, image.width);
  <span class="tok-keyword">let</span> <span class="tok-definition">height</span> = Math.min(<span class="tok-number">100</span>, image.height);
  <span class="tok-keyword">let</span> <span class="tok-definition">canvas</span> = elt(<span class="tok-string">"canvas"</span>, {<span class="tok-definition">width</span>, <span class="tok-definition">height</span>});
  <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = canvas.getContext(<span class="tok-string">"2d"</span>);
  cx.drawImage(image, <span class="tok-number">0</span>, <span class="tok-number">0</span>);
  <span class="tok-keyword">let</span> <span class="tok-definition">pixels</span> = [];
  <span class="tok-keyword">let</span> {data} = cx.getImageData(<span class="tok-number">0</span>, <span class="tok-number">0</span>, width, height);
``````html
<span class="tok-keyword">function</span> <span class="tok-definition">hex</span>(<span class="tok-definition">n</span>) {
    <span class="tok-keyword">return</span> n.toString(<span class="tok-number">16</span>).padStart(<span class="tok-number">2</span>, <span class="tok-string">"0"</span>);
  }
  <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">i</span> = <span class="tok-number">0</span>; i &lt; data.length; i += <span class="tok-number">4</span>) {
    <span class="tok-keyword">let</span> [<span class="tok-definition">r</span>, <span class="tok-definition">g</span>, <span class="tok-definition">b</span>] = data.slice(i, i + <span class="tok-number">3</span>);
    pixels.push(<span class="tok-string">"#"</span> + hex(r) + hex(g) + hex(b));
  }
  <span class="tok-keyword">return</span> <span class="tok-keyword">new</span> Picture(width, height, pixels);
```

<p><a class="p_ident" id="p-KgRf0FlE06" href="#p-KgRf0FlE06" tabindex="-1" role="presentation"></a>Vamos a limitar el tama√±o de las im√°genes a 100 por 100 p√≠xeles, ya que cualquier cosa m√°s grande se ver√° enorme en nuestra pantalla y podr√≠a ralentizar la interfaz.</p>

<p><a class="p_ident" id="p-9BhQWl518s" href="#p-9BhQWl518s" tabindex="-1" role="presentation"></a>La propiedad <code>data</code> del objeto devuelto por <code>getImageData</code> es un array de componentes de color. Para cada p√≠xel en el rect√°ngulo especificado por los argumentos, contiene cuatro valores que representan los componentes rojo, verde, azul y <em>alfa</em> del color del p√≠xel, como n√∫meros entre 0 y 255. La parte alfa representa la opacidad: cuando es cero, el p√≠xel es completamente transparente, y cuando es 255, es completamente opaco. Para nuestro prop√≥sito, podemos ignorarlo.</p>

<p><a class="p_ident" id="p-ISSui65mS1" href="#p-ISSui65mS1" tabindex="-1" role="presentation"></a>Los dos d√≠gitos hexadecimales por componente, como se usan en nuestra notaci√≥n de color, corresponden precisamente al rango de 0 a 255. Dos d√≠gitos en base 16 pueden expresar 16<sup>2</sup> = 256 n√∫meros diferentes. El m√©todo <code>toString</code> de los n√∫meros puede recibir una base como argumento, por lo que <code>n.toString(16)</code> producir√° una representaci√≥n en cadena en base 16. Debemos asegurarnos de que cada n√∫mero ocupe dos d√≠gitos, as√≠ que la funci√≥n auxiliar <code>hex</code> llama a <code>padStart</code> para a√±adir un cero inicial cuando sea necesario.</p>

<p><a class="p_ident" id="p-6IivpBfRDE" href="#p-6IivpBfRDE" tabindex="-1" role="presentation"></a>¬°Ya podemos cargar y guardar! Eso deja una caracter√≠stica m√°s antes de que terminemos.</p>

<h2><a class="h_ident" id="h-6z5Bscg+0R" href="#h-6z5Bscg+0R" tabindex="-1" role="presentation"></a>Historial de deshacer</h2>

<p><a class="p_ident" id="p-9BV8ZF7PJo" href="#p-9BV8ZF7PJo" tabindex="-1" role="presentation"></a>La mitad del proceso de edici√≥n es cometer peque√±os errores y corregirlos. Por lo tanto, una caracter√≠stica importante en un programa de dibujo es un historial de deshacer.</p>

<p><a class="p_ident" id="p-Gnol1X09SZ" href="#p-Gnol1X09SZ" tabindex="-1" role="presentation"></a>Para poder deshacer cambios, necesitamos almacenar versiones anteriores de la imagen. Dado que es un valor inmutable, eso es f√°cil. Pero requiere un campo adicional en el estado de la aplicaci√≥n.</p>
```<p><a class="p_ident" id="p-ylDRpE2dGz" href="#p-ylDRpE2dGz" tabindex="-1" role="presentation"></a>Agregaremos un array <code>done</code> para mantener versiones anteriores de la imagen. Mantener esta propiedad requiere una funci√≥n de actualizaci√≥n de estado m√°s complicada que a√±ade im√°genes al array.</p>

<p><a class="p_ident" id="p-Rjg7sBJ+/e" href="#p-Rjg7sBJ+/e" tabindex="-1" role="presentation"></a>Pero no queremos almacenar <em>todos</em> los cambios, solo cambios separados por cierto tiempo. Para poder hacer eso, necesitaremos una segunda propiedad, <code>doneAt</code>, que rastree el momento en el que almacenamos por √∫ltima vez una imagen en el historial.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-ZVURrzkhxG" href="#c-ZVURrzkhxG" tabindex="-1" role="presentation"></a><span class="tok-keyword">function</span> <span class="tok-definition">historyUpdateState</span>(<span class="tok-definition">state</span>, <span class="tok-definition">action</span>) {
  <span class="tok-keyword">if</span> (action.undo == true) {
    <span class="tok-keyword">if</span> (state.done.length == <span class="tok-number">0</span>) <span class="tok-keyword">return</span> state;
    <span class="tok-keyword">return</span> {
      ...state,
      <span class="tok-definition">picture</span>: state.done[<span class="tok-number">0</span>],
      <span class="tok-definition">done</span>: state.done.slice(<span class="tok-number">1</span>),
      <span class="tok-definition">doneAt</span>: <span class="tok-number">0</span>
    };
  } <span class="tok-keyword">else</span> <span class="tok-keyword">if</span> (action.picture &amp;&amp;
             state.doneAt &lt; Date.now() - <span class="tok-number">1000</span>) {
    <span class="tok-keyword">return</span> {
      ...state,
      ...action,
      <span class="tok-definition">done</span>: [state.picture, ...state.done],
      <span class="tok-definition">doneAt</span>: Date.now()
    };
  } <span class="tok-keyword">else</span> {
    <span class="tok-keyword">return</span> {...state, ...action};
  }
}</pre>

<p><a class="p_ident" id="p-CU+yNT8jA+" href="#p-CU+yNT8jA+" tabindex="-1" role="presentation"></a>Cuando la acci√≥n es un paso atr√°s, la funci√≥n toma la imagen m√°s reciente del historial y la convierte en la imagen actual. Establece <code>doneAt</code> en cero para garantizar que el pr√≥ximo cambio almacene la imagen de nuevo en el historial, permiti√©ndote revertir a ella en otro momento si lo deseas.</p>

<p><a class="p_ident" id="p-shSVZQRIbR" href="#p-shSVZQRIbR" tabindex="-1" role="presentation"></a>De lo contrario, si la acci√≥n contiene una nueva imagen y el √∫ltimo momento en el que almacenamos algo fue hace m√°s de un segundo (1000 milisegundos), las propiedades <code>done</code> y <code>doneAt</code> se actualizan para almacenar la imagen anterior.</p>

<p><a class="p_ident" id="p-Uo7Cny2ro1" href="#p-Uo7Cny2ro1" tabindex="-1" role="presentation"></a>El componente del bot√≥n de deshacer no hace mucho. Despacha acciones de deshacer cuando se hace clic y se deshabilita cuando no hay nada que deshacer.</p><pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-V5SwZIdQv8" href="#c-V5SwZIdQv8" tabindex="-1" role="presentation"></a><span class="tok-keyword">class</span> UndoButton {
  <span class="tok-definition">constructor</span>(<span class="tok-definition">state</span>, {dispatch}) {
    <span class="tok-keyword">this</span>.dom = elt(<span class="tok-string">"button"</span>, {
      <span class="tok-definition">onclick</span>: () =&gt; dispatch({<span class="tok-definition">undo</span>: true}),
      <span class="tok-definition">disabled</span>: state.done.length == <span class="tok-number">0</span>
    }, <span class="tok-string">"‚Æ™ Undo"</span>);
  }
  <span class="tok-definition">syncState</span>(<span class="tok-definition">state</span>) {
    <span class="tok-keyword">this</span>.dom.disabled = state.done.length == <span class="tok-number">0</span>;
  }
}</pre>

<h2><a class="h_ident" id="h-rUniBhw5Qd" href="#h-rUniBhw5Qd" tabindex="-1" role="presentation"></a>Dibujemos</h2>

<p><a class="p_ident" id="p-jIw4zXAanZ" href="#p-jIw4zXAanZ" tabindex="-1" role="presentation"></a>Para configurar la aplicaci√≥n, necesitamos crear un estado, un conjunto de herramientas, un conjunto de controles y una funci√≥n de despacho. Podemos pasarlos al constructor de <code>PixelEditor</code> para crear el componente principal. Dado que necesitaremos crear varios editores en los ejercicios, primero definimos algunos enlaces.</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-PyNgZwUySd" href="#c-PyNgZwUySd" tabindex="-1" role="presentation"></a><span class="tok-keyword">const</span> <span class="tok-definition">startState</span> = {
  <span class="tok-definition">tool</span>: <span class="tok-string">"draw"</span>,
  <span class="tok-definition">color</span>: <span class="tok-string">"#000000"</span>,
  <span class="tok-definition">picture</span>: Picture.empty(<span class="tok-number">60</span>, <span class="tok-number">30</span>, <span class="tok-string">"#f0f0f0"</span>),
  <span class="tok-definition">done</span>: [],
  <span class="tok-definition">doneAt</span>: <span class="tok-number">0</span>
};

<span class="tok-keyword">const</span> <span class="tok-definition">baseTools</span> = {<span class="tok-definition">draw</span>, <span class="tok-definition">fill</span>, <span class="tok-definition">rectangle</span>, <span class="tok-definition">pick</span>};

<span class="tok-keyword">const</span> <span class="tok-definition">baseControls</span> = [
  ToolSelect, ColorSelect, SaveButton, LoadButton, UndoButton
];

<span class="tok-keyword">function</span> <span class="tok-definition">startPixelEditor</span>({state = startState,
                           tools = baseTools,
                           controls = baseControls}) {
  <span class="tok-keyword">let</span> <span class="tok-definition">app</span> = <span class="tok-keyword">new</span> PixelEditor(state, {
    <span class="tok-definition">tools</span>,
    <span class="tok-definition">controls</span>,
    <span class="tok-definition">dispatch</span>(<span class="tok-definition">action</span>) {
      state = historyUpdateState(state, action);
      app.syncState(state);
    }
  });
  <span class="tok-keyword">return</span> app.dom;
}</pre><p><a class="p_ident" id="p-mvhc46WKC4" href="#p-mvhc46WKC4" tabindex="-1" role="presentation"></a>Cuando desestructuras un objeto o un array, puedes usar <code>=</code> despu√©s de un nombre de enlace para asignarle un valor por defecto, que se utiliza cuando la propiedad est√° ausente o tiene <code>undefined</code>. La funci√≥n <code>startPixelEditor</code> hace uso de esto para aceptar un objeto con una serie de propiedades opcionales como argumento. Si no proporcionas una propiedad <code>tools</code>, por ejemplo, <code>tools</code> se enlazar√° a <code>baseTools</code>.</p>

<p><a class="p_ident" id="p-rZawaYRcqb" href="#p-rZawaYRcqb" tabindex="-1" role="presentation"></a>As√≠ es como obtenemos un editor real en la pantalla:</p>

<pre tabindex="0" class="snippet" data-language="html"><a class="c_ident" id="c-eYhWs5adxG" href="#c-eYhWs5adxG" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">div</span>&gt;&lt;/<span class="tok-typeName">div</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  document.querySelector(<span class="tok-string">"div"</span>)
    .appendChild(startPixelEditor({}));
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<p><a class="p_ident" id="p-/mEJgrhggv" href="#p-/mEJgrhggv" tabindex="-1" role="presentation"></a>Adelante y dibuja algo.</p>

<h2><a class="h_ident" id="h-0bgBxHHAl2" href="#h-0bgBxHHAl2" tabindex="-1" role="presentation"></a>¬øPor qu√© es esto tan dif√≠cil?</h2>

<p><a class="p_ident" id="p-HMbn9UOVza" href="#p-HMbn9UOVza" tabindex="-1" role="presentation"></a>La tecnolog√≠a del navegador es asombrosa. Proporciona un poderoso conjunto de bloques de construcci√≥n de interfaz, formas de estilo y manipulaci√≥n, y herramientas para inspeccionar y depurar sus aplicaciones. El software que escribes para el navegador puede ejecutarse en casi todas las computadoras y tel√©fonos del planeta.</p>

<p><a class="p_ident" id="p-uqWgH1U6Ki" href="#p-uqWgH1U6Ki" tabindex="-1" role="presentation"></a>Al mismo tiempo, la tecnolog√≠a del navegador es rid√≠cula. Debes aprender una gran cantidad de trucos tontos y hechos oscuros para dominarla, y el modelo de programaci√≥n por defecto que proporciona es tan problem√°tico que la mayor√≠a de los programadores prefieren cubrirlo con varias capas de abstracci√≥n en lugar de tratar con √©l directamente.</p>

<p><a class="p_ident" id="p-AyiKfJ46L7" href="#p-AyiKfJ46L7" tabindex="-1" role="presentation"></a>Aunque la situaci√≥n definitivamente est√° mejorando, lo hace en su mayor√≠a en forma de a√±adir m√°s elementos para abordar deficiencias, creando a√∫n m√°s complejidad. Una caracter√≠stica utilizada por un mill√≥n de sitios web realmente no se puede reemplazar. Incluso si se pudiera, ser√≠a dif√≠cil decidir con qu√© deber√≠a reemplazarse.</p>

<p><a class="p_ident" id="p-QDBhnn+JkF" href="#p-QDBhnn+JkF" tabindex="-1" role="presentation"></a>La tecnolog√≠a nunca existe en un vac√≠o, estamos limitados por nuestras herramientas y los factores sociales, econ√≥micos e hist√≥ricos que las produjeron. Esto puede resultar molesto, pero generalmente es m√°s productivo tratar de comprender c√≥mo funciona la realidad t√©cnica <em>existente</em> y por qu√© es de la forma en que es, en lugar de luchar contra ella o esperar otra realidad.</p><p><a class="p_ident" id="p-iDBDoz+SYO" href="#p-iDBDoz+SYO" tabindex="-1" role="presentation"></a>Nuevas abstracciones <em>pueden</em> ser √∫tiles. El modelo de componentes y la convenci√≥n de flujo de datos que utilic√© en este cap√≠tulo es una forma rudimentaria de eso. Como se mencion√≥, hay bibliotecas que intentan hacer la programaci√≥n de interfaz de usuario m√°s agradable. En el momento de escribir esto, <a href="https://reactjs.org/">React</a> y <a href="https://svelte.dev/">Svelte</a> son opciones populares, pero hay toda una industria de marcos de trabajo de este tipo. Si tienes inter√©s en programar aplicaciones web, te recomiendo investigar algunos de ellos para entender c√≥mo funcionan y qu√© beneficios ofrecen.</p>

<h2><a class="h_ident" id="h-TcUD2vzyMe" href="#h-TcUD2vzyMe" tabindex="-1" role="presentation"></a>Ejercicios</h2>

<p><a class="p_ident" id="p-We+KsAI00v" href="#p-We+KsAI00v" tabindex="-1" role="presentation"></a>Todav√≠a hay espacio para mejorar en nuestro programa. A√±adamos unas cuantas caracter√≠sticas m√°s como ejercicios.</p>

<h3><a class="i_ident" id="i-BUum8+bZXE" href="#i-BUum8+bZXE" tabindex="-1" role="presentation"></a>Atajos de teclado</h3>

<p><a class="p_ident" id="p-FuGqJ+Eqr8" href="#p-FuGqJ+Eqr8" tabindex="-1" role="presentation"></a>Agrega atajos de teclado a la aplicaci√≥n. La primera letra del nombre de una herramienta selecciona la herramienta, y <span class="keyname">control</span>-Z o <span class="keyname">command</span>-Z activa el deshacer.</p>

<p><a class="p_ident" id="p-I2nI24RWRb" href="#p-I2nI24RWRb" tabindex="-1" role="presentation"></a>Haz esto modificando el componente <code>PixelEditor</code>. Agrega una propiedad <code>tabIndex</code> de 0 al elemento <code>&lt;div&gt;</code> contenedor para que pueda recibir el enfoque del teclado. Ten en cuenta que la <em>propiedad</em> correspondiente al <code>tabindex</code> <em>atributo</em> se llama <code>tabIndex</code>, con may√∫scula en la I, y nuestra funci√≥n <code>elt</code> espera nombres de propiedades. Registra los manejadores de eventos de teclado directamente en ese elemento. Esto significa que debes hacer clic, tocar o tabular hasta la aplicaci√≥n antes de poder interactuar con ella mediante el teclado.</p>

<p><a class="p_ident" id="p-Yzx5/UnTtd" href="#p-Yzx5/UnTtd" tabindex="-1" role="presentation"></a>Recuerda que los eventos de teclado tienen las propiedades <code>ctrlKey</code> y <code>metaKey</code> (para la tecla <span class="keyname">command</span> en Mac) que puedes usar para verificar si esas teclas est√°n presionadas.</p>

<pre tabindex="0" class="snippet" data-language="html"><a class="c_ident" id="c-9RBHLjfr9C" href="#c-9RBHLjfr9C" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">div</span>&gt;&lt;/<span class="tok-typeName">div</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-comment">// La clase PixelEditor original. Extiende el constructor.</span>
  <span class="tok-keyword">class</span> PixelEditor {
    <span class="tok-definition">constructor</span>(<span class="tok-definition">state</span>, <span class="tok-definition">config</span>) {
      <span class="tok-keyword">let</span> {tools, controls, dispatch} = config;
      <span class="tok-keyword">this</span>.state = state;      <span class="tok-keyword">this</span>.canvas = <span class="tok-keyword">new</span> PictureCanvas(state.picture, <span class="tok-definition">pos</span> =&gt; {
        <span class="tok-keyword">let</span> <span class="tok-definition">tool</span> = tools[<span class="tok-keyword">this</span>.state.tool];
        <span class="tok-keyword">let</span> <span class="tok-definition">onMove</span> = tool(pos, <span class="tok-keyword">this</span>.state, dispatch);
        <span class="tok-keyword">if</span> (onMove) {
          <span class="tok-keyword">return</span> <span class="tok-definition">pos</span> =&gt; onMove(pos, <span class="tok-keyword">this</span>.state, dispatch);
        }
      });
      <span class="tok-keyword">this</span>.controls = controls.map(
        <span class="tok-definition">Control</span> =&gt; <span class="tok-keyword">new</span> Control(state, config));
      <span class="tok-keyword">this</span>.dom = elt(<span class="tok-string">"div"</span>, {}, <span class="tok-keyword">this</span>.canvas.dom, elt(<span class="tok-string">"br"</span>),
                     ...<span class="tok-keyword">this</span>.controls.reduce(
                       (<span class="tok-definition">a</span>, <span class="tok-definition">c</span>) =&gt; a.concat(<span class="tok-string">" "</span>, c.dom), []));
    }
    <span class="tok-definition">syncState</span>(<span class="tok-definition">state</span>) {
      <span class="tok-keyword">this</span>.state = state;
      <span class="tok-keyword">this</span>.canvas.syncState(state.picture);
      <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">ctrl</span> <span class="tok-keyword">of</span> <span class="tok-keyword">this</span>.controls) ctrl.syncState(state);
    }
  }

  document.querySelector(<span class="tok-string">"div"</span>)
    .appendChild(startPixelEditor({}));
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-xwvacRuw4q" href="#p-xwvacRuw4q" tabindex="-1" role="presentation"></a>La propiedad <code>key</code> de los eventos para teclas de letras ser√° la letra en min√∫scula en s√≠ misma, si no se mantiene presionado <span class="keyname">shift</span>. No estamos interesados en eventos de teclas con <span class="keyname">shift</span> aqu√≠.</p>

<p><a class="p_ident" id="p-J2xT9ECn2k" href="#p-J2xT9ECn2k" tabindex="-1" role="presentation"></a>Un controlador de evento <code>"keydown"</code> puede inspeccionar su objeto de evento para ver si coincide con alguno de los accesos directos. Puedes obtener autom√°ticamente la lista de primeras letras del objeto <code>tools</code> para no tener que escribirlas.</p>

<p><a class="p_ident" id="p-+R29awWdUv" href="#p-+R29awWdUv" tabindex="-1" role="presentation"></a>Cuando el evento de la tecla coincida con un acceso directo, llama a <code>preventDefault</code> en √©l y despacha la acci√≥n apropiada.</p>

</div></details>

<h3><a class="i_ident" id="i-N6J15nL9us" href="#i-N6J15nL9us" tabindex="-1" role="presentation"></a>Dibujo eficiente</h3><p><a class="p_ident" id="p-IwtJehHo1s" href="#p-IwtJehHo1s" tabindex="-1" role="presentation"></a> Durante el dibujo, la mayor parte del trabajo que realiza nuestra aplicaci√≥n sucede en <code>drawPicture</code>. Crear un nuevo estado y actualizar el resto del DOM no es muy costoso, pero repintar todos los p√≠xeles en el lienzo es un trabajo considerable.</p>

<p><a class="p_ident" id="p-ttnFBSQKkT" href="#p-ttnFBSQKkT" tabindex="-1" role="presentation"></a> Encuentra una manera de hacer que el m√©todo <code>syncState</code> de <code>PictureCanvas</code> sea m√°s r√°pido al redibujar solo los p√≠xeles que realmente cambiaron.</p>

<p><a class="p_ident" id="p-usWBD49GQe" href="#p-usWBD49GQe" tabindex="-1" role="presentation"></a> Recuerda que <code>drawPicture</code> tambi√©n es utilizado por el bot√≥n de guardar, por lo que si lo cambias, aseg√∫rate de que los cambios no rompan el uso anterior o crea una nueva versi√≥n con un nombre diferente.</p>

<p><a class="p_ident" id="p-i2d6YLv1P1" href="#p-i2d6YLv1P1" tabindex="-1" role="presentation"></a> Tambi√©n ten en cuenta que cambiar el tama√±o de un elemento <code>&lt;canvas&gt;</code>, configurando sus propiedades <code>width</code> o <code>height</code>, lo borra, volvi√©ndolo completamente transparente de nuevo.</p>

<pre tabindex="0" class="snippet" data-language="html"><a class="c_ident" id="c-WYxUTPFclW" href="#c-WYxUTPFclW" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">div</span>&gt;&lt;/<span class="tok-typeName">div</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-comment">// Cambiar este m√©todo</span>
  PictureCanvas.prototype.syncState = <span class="tok-keyword">function</span>(<span class="tok-definition">picture</span>) {
    <span class="tok-keyword">if</span> (<span class="tok-keyword">this</span>.picture == picture) <span class="tok-keyword">return</span>;
    <span class="tok-keyword">this</span>.picture = picture;
    drawPicture(<span class="tok-keyword">this</span>.picture, <span class="tok-keyword">this</span>.dom, scale);
  };

  <span class="tok-comment">// Puede que tambi√©n quieras usar o cambiar esto</span>
  <span class="tok-keyword">function</span> <span class="tok-definition">drawPicture</span>(<span class="tok-definition">picture</span>, <span class="tok-definition">canvas</span>, <span class="tok-definition">scale</span>) {
    canvas.width = picture.width * scale;
    canvas.height = picture.height * scale;
    <span class="tok-keyword">let</span> <span class="tok-definition">cx</span> = canvas.getContext(<span class="tok-string">"2d"</span>);

    <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">y</span> = <span class="tok-number">0</span>; y &lt; picture.height; y++) {
      <span class="tok-keyword">for</span> (<span class="tok-keyword">let</span> <span class="tok-definition">x</span> = <span class="tok-number">0</span>; x &lt; picture.width; x++) {
        cx.fillStyle = picture.pixel(x, y);
        cx.fillRect(x * scale, y * scale, scale, scale);
      }
    }
  }

```html
document.querySelector("div")
    .appendChild(startPixelEditor({}));
&lt;/script&gt;</pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-hWnsI+3L35" href="#p-hWnsI+3L35" tabindex="-1" role="presentation"></a>Este ejercicio es un buen ejemplo de c√≥mo las estructuras de datos inmutables pueden hacer que el c√≥digo sea m√°s <em>r√°pido</em>. Dado que tenemos tanto la imagen antigua como la nueva, podemos compararlas y volver a dibujar solo los p√≠xeles que han cambiado de color, ahorrando m√°s del 99 por ciento del trabajo de dibujo en la mayor√≠a de los casos.</p>

<p><a class="p_ident" id="p-tH/EgkLe4/" href="#p-tH/EgkLe4/" tabindex="-1" role="presentation"></a>Puedes escribir una nueva funci√≥n <code>updatePicture</code> o hacer que <code>drawPicture</code> tome un argumento extra, que puede ser undefined o la imagen anterior. Para cada p√≠xel, la funci√≥n verifica si se pas√≥ una imagen anterior con el mismo color en esta posici√≥n y se salta el p√≠xel en ese caso.</p>

<p><a class="p_ident" id="p-iypPTMWN+N" href="#p-iypPTMWN+N" tabindex="-1" role="presentation"></a>Debido a que el lienzo se borra cuando cambiamos su tama√±o, tambi√©n debes evitar tocar sus propiedades <code>width</code> y <code>height</code> cuando la imagen antigua y la nueva tienen el mismo tama√±o. Si son diferentes, lo cual suceder√° cuando se carga una nueva imagen, puedes establecer la vinculaci√≥n que contiene la imagen antigua en null despu√©s de cambiar el tama√±o del lienzo porque no deber√≠as omitir ning√∫n p√≠xel despu√©s de haber cambiado el tama√±o del lienzo.</p>

</div></details>

<h3><a class="i_ident" id="i-lH0RbmdIJo" href="#i-lH0RbmdIJo" tabindex="-1" role="presentation"></a>C√≠rculos</h3>

<p><a class="p_ident" id="p-uQNKRPnnSU" href="#p-uQNKRPnnSU" tabindex="-1" role="presentation"></a>Define una herramienta llamada <code>circle</code> que dibuje un c√≠rculo relleno cuando arrastres. El centro del c√≠rculo se encuentra en el punto donde comienza el gesto de arrastre o toque, y su radio est√° determinado por la distancia arrastrada.</p>

<pre tabindex="0" class="snippet" data-language="html"><a class="c_ident" id="c-fUGegXGBaw" href="#c-fUGegXGBaw" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">div</span>&gt;&lt;/<span class="tok-typeName">div</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-keyword">function</span> <span class="tok-definition">circle</span>(<span class="tok-definition">pos</span>, <span class="tok-definition">state</span>, <span class="tok-definition">dispatch</span>) {
    <span class="tok-comment">// Tu c√≥digo aqu√≠</span>
  }

  <span class="tok-keyword">let</span> <span class="tok-definition">dom</span> = startPixelEditor({
    <span class="tok-definition">tools</span>: {...baseTools, <span class="tok-definition">circle</span>}
  });
  document.querySelector(<span class="tok-string">"div"</span>).appendChild(dom);
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">
```<p><a class="p_ident" id="p-n8gcP1wK10" href="#p-n8gcP1wK10" tabindex="-1" role="presentation"></a>Puedes tomar algo de inspiraci√≥n de la herramienta <code>rectangle</code>. Como esa herramienta, querr√°s seguir dibujando en la imagen <em>inicial</em>, en lugar de la imagen actual, cuando el puntero se mueva.</p>

<p><a class="p_ident" id="p-g4iL6doRwh" href="#p-g4iL6doRwh" tabindex="-1" role="presentation"></a>Para averiguar qu√© p√≠xeles colorear, puedes usar el teorema de Pit√°goras. Primero averigua la distancia entre la posici√≥n actual del puntero y la posici√≥n de inicio tomando la ra√≠z cuadrada (<code>Math.sqrt</code>) de la suma del cuadrado (<code>x ** 2</code>) de la diferencia en coordenadas x y el cuadrado de la diferencia en coordenadas y. Luego recorre un cuadrado de p√≠xeles alrededor de la posici√≥n de inicio, cuyos lados son al menos el doble del radio, y colorea aquellos que est√©n dentro del radio del c√≠rculo, nuevamente utilizando la f√≥rmula de Pit√°goras para averiguar su distancia desde el centro.</p>

<p><a class="p_ident" id="p-1OpVITsSOu" href="#p-1OpVITsSOu" tabindex="-1" role="presentation"></a>Aseg√∫rate de no intentar colorear p√≠xeles que est√©n fuera de los l√≠mites de la imagen.</p>

</div></details>

<h3><a class="i_ident" id="i-gbSk/YiRrs" href="#i-gbSk/YiRrs" tabindex="-1" role="presentation"></a>L√≠neas adecuadas</h3>

<p><a class="p_ident" id="p-9+5Lhu8/5P" href="#p-9+5Lhu8/5P" tabindex="-1" role="presentation"></a>Este es un ejercicio m√°s avanzado que los dos anteriores, y requerir√° que dise√±es una soluci√≥n para un problema no trivial. Aseg√∫rate de tener mucho tiempo y paciencia antes de comenzar a trabajar en este ejercicio, y no te desanimes por fracasos iniciales.</p>

<p><a class="p_ident" id="p-VU//OuPykO" href="#p-VU//OuPykO" tabindex="-1" role="presentation"></a>En la mayor√≠a de los navegadores, cuando seleccionas la herramienta <code>draw</code> y arrastras r√°pidamente sobre la imagen, no obtienes una l√≠nea cerrada. M√°s bien, obtienes puntos con brechas entre ellos porque los eventos <code>"mousemove"</code> o <code>"touchmove"</code> no se dispararon lo suficientemente r√°pido como para alcanzar cada p√≠xel.</p>

<p><a class="p_ident" id="p-MVVAQugFEf" href="#p-MVVAQugFEf" tabindex="-1" role="presentation"></a>Mejora la herramienta <code>draw</code> para que dibuje una l√≠nea completa. Esto significa que debes hacer que la funci√≥n manejadora de movimiento recuerde la posici√≥n anterior y la conecte con la actual.</p>

<p><a class="p_ident" id="p-7SM2TRnD47" href="#p-7SM2TRnD47" tabindex="-1" role="presentation"></a>Para hacer esto, dado que los p√≠xeles pueden estar a una distancia arbitraria entre s√≠, tendr√°s que escribir una funci√≥n general de dibujo de l√≠neas.</p>

<p><a class="p_ident" id="p-e6Gkv3bxv2" href="#p-e6Gkv3bxv2" tabindex="-1" role="presentation"></a>Una l√≠nea entre dos p√≠xeles es una cadena conectada de p√≠xeles, lo m√°s recta posible, yendo desde el inicio hasta el final. Los p√≠xeles diagonalmente adyacentes cuentan como conectados. Por lo tanto, una l√≠nea inclinada deber√≠a parecerse a la imagen de la izquierda, no a la imagen de la derecha.<figure><img src="fonts/line-grid.svg" alt="Diagrama de dos l√≠neas pixeladas, una clara, saltando a trav√©s de p√≠xeles diagonalmente, y una oscura, con todos los p√≠xeles conectados horizontal o verticalmente"></figure><p><a class="p_ident" id="p-+B4IUrham3" href="#p-+B4IUrham3" tabindex="-1" role="presentation"></a>Finalmente, si tenemos c√≥digo que dibuja una l√≠nea entre dos puntos arbitrarios, tambi√©n podr√≠amos usarlo para definir una herramienta de <code>l√≠nea</code>, que dibuja una l√≠nea recta entre el inicio y el final de un arrastre.</p>

<pre tabindex="0" class="snippet" data-language="html"><a class="c_ident" id="c-lYipUdu4TJ" href="#c-lYipUdu4TJ" tabindex="-1" role="presentation"></a>&lt;<span class="tok-typeName">div</span>&gt;&lt;/<span class="tok-typeName">div</span>&gt;
&lt;<span class="tok-typeName">script</span>&gt;
  <span class="tok-comment">// La antigua herramienta de dibujo. Reescribir esto.</span>
  <span class="tok-keyword">function</span> <span class="tok-definition">draw</span>(<span class="tok-definition">pos</span>, <span class="tok-definition">state</span>, <span class="tok-definition">dispatch</span>) {
    <span class="tok-keyword">function</span> <span class="tok-definition">drawPixel</span>({x, y}, <span class="tok-definition">state</span>) {
      <span class="tok-keyword">let</span> <span class="tok-definition">drawn</span> = {<span class="tok-definition">x</span>, <span class="tok-definition">y</span>, <span class="tok-definition">color</span>: state.color};
      dispatch({<span class="tok-definition">picture</span>: state.picture.draw([drawn])});
    }
    drawPixel(pos, state);
    <span class="tok-keyword">return</span> drawPixel;
  }

  <span class="tok-keyword">function</span> <span class="tok-definition">line</span>(<span class="tok-definition">pos</span>, <span class="tok-definition">state</span>, <span class="tok-definition">dispatch</span>) {
    <span class="tok-comment">// Tu c√≥digo aqu√≠</span>
  }

  <span class="tok-keyword">let</span> <span class="tok-definition">dom</span> = startPixelEditor({
    <span class="tok-definition">tools</span>: {<span class="tok-definition">draw</span>, <span class="tok-definition">line</span>, <span class="tok-definition">fill</span>, <span class="tok-definition">rectangle</span>, <span class="tok-definition">pick</span>}
  });
  document.querySelector(<span class="tok-string">"div"</span>).appendChild(dom);
&lt;/<span class="tok-typeName">script</span>&gt;</pre>

<details class="solution"><summary>Mostrar pistas...</summary><div class="solution-text">

<p><a class="p_ident" id="p-og+tGV8E9K" href="#p-og+tGV8E9K" tabindex="-1" role="presentation"></a>La cuesti√≥n sobre el problema de dibujar una l√≠nea pixelada es que en realidad son cuatro problemas similares pero ligeramente diferentes. Dibujar una l√≠nea horizontal de izquierda a derecha es f√°cil: recorres las coordenadas <em>x</em> y coloreas un p√≠xel en cada paso. Si la l√≠nea tiene una ligera inclinaci√≥n (menos de 45 grados o ¬ºœÄ radianes), puedes interpolar la coordenada <em>y</em> a lo largo de la pendiente. A√∫n necesitas un p√≠xel por posici√≥n de <em>x</em>, con la posici√≥n de <em>y</em> de esos p√≠xeles determinada por la pendiente.</p>

<p><a class="p_ident" id="p-mrTlGXQJo5" href="#p-mrTlGXQJo5" tabindex="-1" role="presentation"></a>Pero tan pronto como la pendiente supere los 45 grados, necesitas cambiar la forma en que tratas las coordenadas. Ahora necesitas un p√≠xel por posici√≥n de <em>y</em> ya que la l√≠nea sube m√°s de lo que va hacia la izquierda. Y luego, cuando cruzas los 135 grados, debes volver a recorrer las coordenadas <em>x</em>, pero de derecha a izquierda.</p><p><a class="p_ident" id="p-IfupYbaeUB" href="#p-IfupYbaeUB" tabindex="-1" role="presentation"></a>No es necesario escribir cuatro bucles en realidad. Dado que dibujar una l√≠nea de <em>A</em> a <em>B</em> es lo mismo que dibujar una l√≠nea de <em>B</em> a <em>A</em>, puedes intercambiar las posiciones de inicio y fin para las l√≠neas que van de derecha a izquierda y tratarlas como si fueran de izquierda a derecha.</p>

<p><a class="p_ident" id="p-vZuMoVM55H" href="#p-vZuMoVM55H" tabindex="-1" role="presentation"></a>Por lo tanto, necesitas dos bucles diferentes. Lo primero que debe hacer tu funci√≥n de dibujo de l√≠neas es verificar si la diferencia entre las coordenadas x es mayor que la diferencia entre las coordenadas y. Si lo es, se trata de una l√≠nea horizontal y si no, de una vertical.</p>

<p><a class="p_ident" id="p-J1kJbTfzUr" href="#p-J1kJbTfzUr" tabindex="-1" role="presentation"></a>Aseg√∫rate de comparar los valores <em>absolutos</em> de la diferencia de <em>x</em> y <em>y</em>, que puedes obtener con <code>Math.abs</code>.</p>

<p><a class="p_ident" id="p-I0ikmjASsq" href="#p-I0ikmjASsq" tabindex="-1" role="presentation"></a>Una vez que sepas a lo largo de qu√© eje vas a iterar, puedes verificar si el punto de inicio tiene una coordenada m√°s alta a lo largo de ese eje que el punto final y intercambiarlos si es necesario. Una forma concisa de intercambiar los valores de dos vinculaciones en JavaScript utiliza la asignaci√≥n por destructuraci√≥n de esta manera:</p>

<pre tabindex="0" class="snippet" data-language="javascript"><a class="c_ident" id="c-/XtfsVpMBL" href="#c-/XtfsVpMBL" tabindex="-1" role="presentation"></a>[<span class="tok-definition">inicio</span>, <span class="tok-definition">fin</span>] = [fin, inicio];</pre>

<p><a class="p_ident" id="p-kQN0DL7QjH" href="#p-kQN0DL7QjH" tabindex="-1" role="presentation"></a>Luego puedes calcular la pendiente de la l√≠nea, que determina cu√°nto cambia la coordenada en el otro eje en cada paso que das a lo largo de tu eje principal. Con eso, puedes ejecutar un bucle a lo largo del eje principal mientras rastreas tambi√©n la posici√≥n correspondiente en el otro eje, y puedes dibujar p√≠xeles en cada iteraci√≥n. Aseg√∫rate de redondear las coordenadas del eje no principal ya que es probable que sean fraccionarias y el m√©todo <code>draw</code> no responda bien a coordenadas fraccionarias.</p>

</div></details><nav><a href="18_http.html" title="cap√≠tulo anterior" aria-label="cap√≠tulo anterior">‚óÇ</a>&nbsp;<a href="index.html" title="portada" aria-label="portada">‚óè</a>&nbsp;<a href="20_node.html" title="pr√≥ximo cap√≠tulo" aria-label="pr√≥ximo cap√≠tulo">‚ñ∏</a>&nbsp;<button class="help" title="ayuda" aria-label="ayuda"><strong>?</strong></button>
</nav>
</article>

<script src="js/ejs.js"></script>
</body></html>